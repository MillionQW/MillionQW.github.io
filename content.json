[{"title":"《JavaScript高级程序设计》 第十章DOM","date":"2017-12-05T12:37:13.000Z","path":"2017/12/05/《JavaScript高级程序设计》-第十章DOM/","text":"现在还搞不清楚node类型、document类型、html、类型的区别，他们是对象吗？DOM（document object module）是针对HTML、XML文档的一个API（应用程序接口）。DOM描绘了层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。IE（应该是说IE几开始呢？）中的所有DOM对象都是以COM对象的形式实现的。这以为着IE中的DOM对象与原生JavaScript对象的行为或活动特点并不一致。 10.1节点层次（文档元素是什么）DOM将HTML或XML文档描绘成一个由多层节点构成的结构（DOM描绘了这个结构哦）。节点分为几种不同的类型。每种类型分别表示文档中不同的信息及标记。节点都有各自的特点、数据和方法。节点之间的关系构成了层次。所有页面标记则表现为一个以特定节点（文档节点，&lt;html&gt;是文档节点的子节点）为根节点的树形结构。例子：&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;文档节点是每个文档（比如HTML文档，不知道XML文档是不是）的根节点。在这个例子中（只是这个例子里文档节点只有一个子节点），文档节点只有一个子节点，即&lt;html&gt;元素，我们称之为文档元素。文档元素是文档的最外层元素，文档中所有其他元素都包含在文档元素中。每个文档只能有一个文档元素。在HTML中，&lt;html&gt;元素始终都是文档元素。在XML中，没有预定义的元素，因此任何元素都可能是文档元素。每一段标记都可以通过树中的一个节点来表示：HTML元素通过元素节点表示（HTML元素是什么？元素节点是什么？），特性（attribute）通过特性节点表示（特性节点？），注释通过注释节点表示。总共有12种节点类型，这些类型都继承自一个基类型。10.1.1Node类型（12个节点类型，判断是某种节点类型的方法）DOM1级定义了一个Node接口，该接口由DOM中的所有类型节点实现（实现是什么意思？）。Node接口在JavaScript中是作为Node类型实现的。除了IE外，其他所有浏览器都可以访问到这个类型（Node类型）。JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。每个节点都有一个nodeType属性，用于表明该节点的类型。节点类型有12个，任何节点其类型必居其一，无出其右。·Node.ELEMENT_NODE(1) element_node·Node.ATTRIBUTE_NODE(2) attribute_node·Node.TEXT_NODE(3) text_node·Node.CDATA_NODE(4) cdata_node·Node.ENTITY_REFERENCE_NODE(5) entity_reference_node·Node.ENTITY_NODE(6) entity_node·Node.PROCESSING_INSTRUCTION_NODE(7) processing_instruction_node·Node.COMMENT_NODE(8) ·Node.DOCUMENT_NODE(9) document.node·Node.DOCUMENT_TYPE_NODE(10) document_type_node·Node.DOCUMENT_FRAGMENT_NODE(11) document_fragment_node·Node.NOTATION_NODE(12) notation_node通过比较上面的常量，可以很容易地确定节点的类型，例如：if(someNode.nodeType == Node.Element_NODE){ console.log(&quot;Node is an element&quot;); //IE中无效，IE中不能访问Node类型，不能说没有Node类型吧}通过比较可以确定someNode是不是一个元素。由于IE无法访问Node；类型，因此上面的代码在IE会导致错误。为了确保兼容，最好将nodeType属性与数字值进行比较。例子：if(someNode.nodeType == 1){ //适用所有浏览器 console.log(&quot;Node is an element.&quot;)}并不是12个节点类型都受到Web浏览器的支持。开发人员最常用的就是元素节点和文本节点，本章后面将详细讨论每个节点类型的受支持情况及使用方法。1.nodeName和nodeValue属性使用nodeName和nodeValue属性可以了解节点的具体信息，使用前，最好先检查节点类型，判断是不是一个元素。对于元素节点，nodeNode中保存的始终都是元素的标签名（大写），nodeValue始终是null。2.节点关系（几个属性，NodeList类数组对象）就是父子这类的关系。每个节点都有一个childNodes属性，其中保存着NodeList对象。Nodelist是一种类数组对象。保存着一组有序的节点。要注意的是，虽然可以通过方括号语法来访问NodeList的值，其这个对象有length属性，但它并不是Array的实例。NodeList对象的独特之处在于：它是基于DOM结构动态执行查询的结果，DOM结构的变化能立即反应在NodeList对象中。所以说NodeLIst对象是有生命、会呼吸的对象。下面展示了访问在NodeList中的节点的方法：var firstChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1);var count = someNode.childNodes.length;两种访问方法无差别，但第一种最常用。亲测IE8里nodeName，nodeType这些属性都是可以访问的，不知道为什么前面说无法访问。书里说“IE没有公开Node类型的构造函数”。我们可以把arguments这个类数组对象用Array.prototype.slice（）方法转换为数组，NodeList对象也可以转换为数组。例子：//IE8及之前版本无效var arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0);由于IE8及之前将NodeList实现为一个COM对象，而我们不能像使用JScript对象那样使用这种对象，所以上面的代码会报错。要在IE中将NodeList转换为数组，必须手动枚举所有成员，下面是在所有浏览器都可以运行的代码：function convertToArray(nodes){ var array = null; try{ array = Array.prototype.slice.call(node,0); }catch(ex){ array = new Array; for(var i = 0; i&lt;nodes.length; i&lt;len; i++){ array.push(nodes[i]); } } return array;}按能力检测的原则，先创建最容易实现的方式，报错了，就进入catch块，这是另一种检测怪癖的形式。每个节点都有一个parentNode属性，指向文档树中的父节点。拿ChildNodes列表（不知道书里这样说对不对，ChildNodes列表，ChildNodes里的NodeList是个类数组，列表是NodeList，那这么说也对）举例，他们的parentNode都指向同一个节点。他们相互之间是同胞节点，通过使用列表中每个节点的previousSibling和nextSibling属性，可以访问同一列表中的其他节点。hasChildNodes（）也是一个非常有用的方法，该方法在节点至少包含一个子节点的情况下就会返回true。可以判断某节点有没有子节点。所有节点都有的最后一个属性是ownerDocument，该属性指向表示整个文档的文档节点（换句话说，文档节点表示整个文档）。这种关系表示的是任何节点都属于它所在的文档。通过这个属性，我们就不用使用parentNode属性层层往上回溯，直接可以访问文档节点（可是访问文档节点要干嘛？）。3.操作节点（使用appendChild（）的特殊情况）因为关系指针（parentNode、previousSibling、nextSibling等）都是可读的（想起上次写代码的时候好像想修改父节点的值什么的，怪不得无端报错），所以DOM提供了一些操作节点的方法（DOM提供的，不是node类型、document类型等提供的）。最常用的是appendChild（），用于向childNodes列表的末尾添加一个节点。appendChild（）的返回值是新增的那个节点。例子：var returnNode = someNode.appendChild(newNode); console.log(returnedNode == newNode); //trueconsole.log(someNode.lastChild == newNode); //true如果传入的节点已经是文档的一部分（不只是childNodes的一部分），那结果就是将节点从原来的位置移（不是复制）到新位置。因为任何DOM节点不能同时出现在文档中的多个位置。因此，如果把父节点中的第一个子节点用appendChild（）重新传入父节点中，那么该节点就会变成父节点的最后一个子节点，而不是复制出一份。例子：//someNode有多个子节点var returnedNode = someNode.appendChild(someNode.firstChild);console.log(returnedNode == someNode.firstChild); //falseconsole.log(returnedNode == someNode.lastChild); //true亲自实验appendChild（）方法很无语，在部分浏览器中，节点之间的空格也会被视为一个节点，如果是插入firstChild很可能插入的是空格，appendChild（）方法返回的值就是“#text”，去了括号就添加成功。例子：&lt;div id=&quot;dd&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;dd1&quot;&gt; &lt;div id=&quot;subdd1&quot;&gt;&lt;/div&gt; //如果是这种情况，returned=#text &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;var dd1 = document.getElementById(&quot;dd1&quot;);var dd = document.getElementById(&quot;dd&quot;);var returned = dd.appendChild(dd1.firstChild);console.log(returned) //#text&lt;/script&gt; 把空格去掉后添加成功，看代码运行后的文档树也证明了如果是文档中已经存在的节点，则该节点会转移到插入目的地的最后，而不是复制一份。如果想把节点放在childNods列表的特定位置，而不是末尾，可以使用insertBefore（）方法。该方法接受两个参数：要插入的节点和作为插入参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点（previousSibling），该放回返回的也是插入的那个节点。如果第二个参数，插入参照点是Null，则insertBefore（）与appendChild（）无异。例子：//插入后成为最后一个子节点returnedNode = someNode.insertBefore(newNode,null);console.log(newNode == someNode.lastChild);//插入后成为第一个子节点var returnNode = someNode.insertBefore(newNode,someNode.first.firstChild);console.log(returnNode == newNode);console.log(newNode == someNode.firstChild);//插入到最后一个子节点前面returnedNode = someNode.insertBefor(newNode,someNode.lastChild);console.log(newNode == someNode.childNodes[someNode.childNodes.length-2]);前面两个方法都是插入节点的，要移除节点，可以使用下面介绍的这个replaceChild（）方法。该方法接收两个参数：要插入的节点和要替换的节点。被替换的节点作为这个方法的返回值，并从文档树中被移除。从技术上讲，这个节点还在文档中，但它已经在文档中没有了自己的位置（好惨，被人上位）。如果想直接移除而不是替换，可以使用removeChild（）方法。与replaceChild（）方法一样，被移除的节点仍然为文档所有，但已经失去了自己的位置。可以发现，上面的4个方法操作的都是某节点的子节点，所以，要使用这4个方法就需要取得节点的父节点。4.其他方法不是所有节点都可以有子节点，所以上面的方法不是每个节点都有。有两个方法是所有类型的节点都有的。第一个是cloneNode（），顾名思义复制节点。该方法接收一个布尔值参数。参数为true，执行深复制，把节点及其整个子节点树复制过去。参数为false，执行浅复制，只复制节点本身。复制后返回的节点就归文档所有，但是它无依无靠，因为没有为克隆节点指定父元素。所以还要通过appendChild（）、insertBefore（）或replaceChild（）将它添加到文档中。例子：假设有下面的HTML代码：&lt;ul id=&quot;myList&quot;&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt;&lt;/ul&gt;假设我们已经取得&lt;ul&gt;元素的引用并保存在变量myList中，下列代码就是cloneNode（）方法的两种模式：var deepList = myList.cloneNode(true); //要先把克隆结果保存在一个变量中，很“不直接”的一个方法console.log(deepList.childNodes.length); //3（IE&lt;9）或7(4个空格)var shallowList = myList.cloneNode(false);console.log(shallowList.childNodes.length); //0IE9之前的版本不会为空白符创建节点。✎：cloneNode（）不会复制添加到DOM节点中的JavaScript属性，例如事件处理程序。这个方法只复制特性（id,class,style等）、子节点（true时），其他一切都不会复制。IE在此存在一个BUG，连事件处理程序也会复制过去，所以作者建议在复制前移除事件处理程序（指绑定在节点里面的那种事件处理程序吧？0级事件处理程序）。10.1.2Document类型JavaScript通过Document类型表示文档（这句话有玄机，不是很懂）。在浏览器中，document对象是HTMLDocument（继承自Document类型）的一个实例，表示整个HTML页面，而且，document对象是window对象的一个属性（global对象不是window对象的属性，是window对象可以代表global对象），所以我们可以把document对象作为全局对象来访问。Document节点（文档节点）具有下列特征：·nodeType的值为9（节点类型：Node.DOCUMENT_NODE(9)）；·nodeName的值为“#document”；·nodeValue的值为null；·parentNode的值为null；·ownerDocument的值为null；（其他节点的ownerDocument指向文档节点，所以它的ownerDocument是他本身）·其子节点可能是一个DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或Comment。Document类型可以表示HTML页面或者其他基于XML的文档（Document类型可以表示这两种文档？）。不过最常用的是作为HTMLDocument实例的document对象（HTMLDocument继承自Document类型，document对象又是HTMLDocument的实例，所以HTMLDocument也是一个对象，亲测，HTMLDocument是一个构造函数）✎：在Firefox、Safari、Chrome和Opera中，可以通过脚本访问Document类型的构造函数和原型。但在所有浏览器都可以访问HTMLDocument类型的构造函数和原型，包括IE8。1.文档的子节点虽然DOM标准规定Document节点（文档节点）的子节点可以是DocumentType、Element、ProcessingInstruction或Comment，但还有两个内置的访问其子节点的快捷方式（这个虽然…但是句真的不是病句吗？）。第一个就是documentElement属性，该属性始终指向HTML页面中的&lt;html&gt;元素（包括里面的子节点！不是只有&lt;html&gt;这个标签!）。另一个方式是通过childNodes列表访问文档元素。但通过documentElement属性更快捷、更直接。例子：&lt;html&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;下面通过两种方法访问&lt;html&gt;元素：var html = document.documentElement;console.log(html === document.childNodes[0]); //htmlconsole.log(html === document.firstChild); //html这个例子说明三个方法都指向&lt;html&gt;元素。作为HTMLDocument的实例，document对象还有一个body属性（两者有关系吗？）直接指向&lt;body&gt;元素。因为&lt;body&gt;使用频率非常高，所以document.body在JavaScript中出现的频率也非常高。所有浏览器都支持document.documentElement和document.body属性（终于有所有浏览器都支持的属性了！）。Document的另一个子节点是DocumentType。即&lt;!DOCTYPE&gt;。通常将&lt;!DOCTYPE&gt;标签看一个与文档其他部分不同的实体。可以通过doctype属性来访问它的信息。与document.body不同，浏览器对document.doctype属性的支持差别很大，书中说出了不同，最后说因为支持不一致，所以这个属性用处有限，就不写了。从技术上说，出现在&lt;html&gt;元素外部的注释（Comment）也算是文档的子节点。但不同的浏览器对注释算不算子节点的看法也是有很大差异的。这种浏览器差异也使&lt;html&gt;元素外部的注释没什么用处，而且要在&lt;html&gt;元素外注释什么啊。2.文档信息（title、URL、domain和referrer）作为HTMLDocument对象的一个实例，document对象还有一些标准的Document对象没有的属性（document对象和Document对象是不同的哦）。这些属性提供了document对象所表现的网页的一些信息。其中第一个属性是title。包含着&lt;title&gt;元素中的文本（体会一下，title属性不是&lt;title&gt;标签，是里面的文本）。可以通过document.title修改&lt;title&gt;元素里的文本信息。接下来要介绍的3个属性与网页的请求有关，他们是URL、domain和referrer。URL属性中包含完整的URL，domain属性中只包含页面域名，referrer属性中保存着链接到当前页面的那个页面的URL，如果网页没有来源，referrer属性中可能包含空字符串（是空字符串，不是null不是null）。所有这些信息都保存于请求的HTTP头部。亲测window.URL和document.URL是不一样的啊，window.URL是个构造函数，不知道是干嘛的前面忘了有没有讲过。这三个属性中，只有domain是可以设置的。而且不是什么值都可以设置。如果URL中包含一个子域名例如：p2p.wrox.com，那只能将domain设置为“wrox.com”，不能将这个属性设置为URL中不包含的域：//假设页面来自p2p.wrox.com域document.domain = &quot;wrox.com&quot; //成功document.domain = &quot;nczonline.net&quot;//出错！上面的代码是将域由紧（tight）的改成松（loose）的是可以的，但不能把“松”的改成“紧”的：//假设页面来自p2p.wrox.com域document.domain = &quot;wrox.com&quot; //改成松散的（成功）document.domain = &quot;p2p.wrox.com&quot; //紧绷的（失败）当页面包含来自不同子域的框架或内嵌框架时，出于安全考虑不同子域的页面无法通过JavaScript通信。但是如果将每个页面的document.domain设置为相同的值，这些页面就可以互相访问对方包含的JavaScript对象了。（不知道这样设置会不会使页面跳转，应该不会吧。框架就是frame不是jQuery这种吧2333）3.查找元素取得元素的操作可以使用document对象的几个方法来完成。其中Document类型为此提供了两个方法：getElementById（）和getElementsByTag（）（这两个不是document对象的方法吗，为什么说是Document类型提供的）不细说了，就讲个IE7及以前版本的怪癖：name特性与给定ID匹配的表单元素（&lt;input&gt;、&lt;textarea&gt;、&lt;button&gt;、&lt;select&gt;）也会被getElementById（）返回。所以现在都要求表单元素的name特性与id相同。了解了解这种历史问题。说说getElementsByTag（），在HTML文档中，这个方法会返回一个HTMLCollection对象，作为一个“动态”集合，该对象与NodeList非常类似。也可以使用方括号或item（）方法来访问HTMLCollection中的项。这个对象中元素的数量则可以通过其length属性来取得。HTMLCollection对象还有一个方法，叫namedItem（），使用这个方法可以通过元素的name特性取得集合中的项。例子：//假设还有其他&lt;img&gt;元素&lt;img src=&quot;myimage.gif&quot; name=&quot;myImage&quot;&gt;var images = document.getElementsByTag(&quot;img&quot;);var myImage = images.namedItem(&quot;myImage&quot;);除了提供按索引（0，1，2，3…）访问项，HTMLCollection还支持按名称访问项，例子：var myImage = images[&quot;myImage&quot;]; //用法跟按索引访问相同原理：对HTMLCollection而言，当我们用索引访问项的时候，后台就会调用item（），当我们传入的是字符串的时候，后台就会调用namedItem（）。亲测childNodes属性返回的不是HTMLCollection，还是叫类数组吧，HTMLCollection是HTMLCollection。第三个方法，也是只有HTMLDocument类型才有的方法：getElementsByName（）。这个方法返回的也是一个HTMLCollection对象。也可以用item（）和namedItem（）方法访问项。但是name是可以重复的，所以用namedItem（）访问的时候只会取得第一项。4.特殊集合除了属性和方法document对象还有一些特殊的集合。这些集合都是HTMLCollection对象。为访问文档常用的部分提供了快捷方式（书中没说这几个集合在IE能不能用啊），包括：·document.anchors：包含文档中所有带name特性的&lt;a&gt;元素；·document.forms：包含文档中所有&lt;form&gt;元素;·document.links：包含文档中所有带href特性的&lt;a&gt;元素（&lt;a&gt;元素？）;·document.images：包含文档中的所有img元素。5.DOM一致性检测由于DOM分为多个级别，也包含多个部分，因此检测浏览器实现了DOM的哪些部分就十分必要了。document.implementation属性就是为此提供相应信息和功能的对象，与浏览器对DOM的实现直接对应。DOM1级只为document.implementation规定了一个方法，即hasFeature（）。这个方法接收两个参数：要检测的DOM功能的名称，版本号。如果浏览器支持，则返回true。例子：var hasXmlDom = document.implementation.hasFeature(&quot;XML&quot;,&quot;1.0&quot;);晚上补图hasFeature（）也有缺点，即有些浏览器在有些DOM功能的实现上只实现了一部分，但hasFeature（）还是返回true。所以在使用DOM的某些特殊功能之前，用hasFeature（）的同时使用能力检测。6.文档写入write（）、writeln（）、open（）、close（）方法。write（）和writeln（）方法可以输出HTML代码，创建DOM元素，例子：&lt;script&gt; document.write(&quot;&lt;strong&gt;&quot;+(new Date()).toString()+&quot;&lt;/strong&gt;&quot;);&lt;/script&gt;此外，还可以动态地包含外部资源，例如JavaScript文件，写入的时候要注意将&lt;/script&gt;标签的正斜杠和标签中双引号用反斜杠转义。例子：&lt;script&gt; document.write(&quot;&lt;script type=\\&quot;text/javscript\\&quot; src=\\&quot;file.js\\&quot;&gt;&quot;+&quot;&lt;\\/script&gt;&quot;);上面的例子都是在页面被呈现的过程中使用document.write（）方法，如果是在文档已经加载结束之后再调用document.write（）方法，那么输出的内容会重写整个页面。方法open（）和close（）是用来打开和关闭网页的输出流，如果是在页面加载期间使用write（）或writeln（）方法，则不需要用到这两个方法。10.1.3Element类型除了Document类型，Element类型算是Web编程中最常用的元素。Element类型用与表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。Element节点具有以下特征：·nodeType的值为1；（Node.ELEMENT_NODE(1)）·nodeName的值为元素的标签名；·nodeValue的值为null；·parentNode可能是Document或Element；·子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection或EntityReference。要访问元素的标签名，即可以使用nodeName属性，也可以使用tagName属性，这两个属性会返回相同的值。但要注意：在HTML文档中，返回的标签名都是大写的；在XML文档中，返回的标签名跟源文档的大小写一致，所以在不确定自己的脚本会用在HTML文档或XML文档的情况下，建议在比较之前将标签名转换为相同的大小写格式。✎：可以在任何浏览器中通过脚本访问Element类型的构造函数及原型。包括IE8及之前版本。在Safari 2 之前和Opera 8之前的版本中，不能反问Element类型的构造函数。（访问Element类型的构造函数有什么用？）1.HTML元素所有HTML元素都由HTMLElement类型表示（不是通过Element类型表示），不是通过这个类型，也是通过它的子类型来表示。HTMLElement类型直接继承至Element类型并添加了一些属性。添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性：·id：元素在文档中的唯一标识符；·title：有关元素的附加说明信息；·land：元素内容的语言代码，很少使用；·dir：语言方向；·className：与元素的class特性相对应。上面的特性都可以被取得和被修改。（不像parentNode、lastChild可读不可写）前面说过所有HTML元素都是用HTMLElement类型或者更具体的子类型来表示的。下表展示了各元素和他们都是由HTML类型或HTML类型的什么子类型表示的。晚上补图2.取得特性操作特性的DOM方法主要有三个：分别是getAttribute（）、setAttribute（）和removeAttribute（）。这三个方法可以针对任何特性使用。注意：传递给getAttribute（）方法的特性名与实际特性名相同，即使是className，也要用“class”访问。className只有在通过对象属性访问特性时（比如myList.className）才使用。如果给定名称的特性不存在，getAttribute（）会返回null。特性的名称不区分大小写，即“ID”与“id”代表同一个特性。getAttribute（）也可以取得自定义特性。BTW，根据HTML5规范，自定义特性应该加上data-前缀以便验证。有两类特殊的特性，他们虽然有对应的属性名，但属性的值与通过getAttribute（）返回的值并不相同。第一类特性就是style，通过getAttribute（）访问时，返回的style特性值返回的是CSS文本，而通过属性来访问它则会返回一个对象。亲测：通过属性访问返回的是所有CSS样式（即使没有设置）的对象，通过getAttribute（）只返回定义在标签内style写的样式，在&lt;style&gt;里定义的不返回。书中说是因为“style属性是用于以编程方式访问元素样式的(本章后面讨论)，因此style属性没有直接映射到style特性。”第二个特性是onclick这样的事件处理程序，如果用getAttribute（）方法访问，会返回相应代码的字符串。如果是访问onclick属性，则返回一个JavaScript函数。由于这些差别，在通过JavaScript操作DOM时，开发人员不经常使用getAttribute（）方法，而是直接使用对象的属性。只在取自定义特性值的情况下，才会使用这个方法。（我还以为经常用呢）3.设置特性setAttribute（）方法。如果特性已存在，则替换原来的值。如果不存在，就创建并赋值。既可以操作HTML特性，也可以操作自定义特性。因为所有特性都是属性，所以直接给属性赋值就可以设置特性的值。例子：div.id=&quot;someOtherId&quot;;div.align=&quot;left&quot;;但是自定义特性就不可以那样做了：div.mycolor = &quot;red&quot;;console.log(div.getAttribute(&quot;mycolor&quot;)); //null（IE除外）✎：因为setAttribute（）在IE7及之前版本有BUG。作者推荐优先通过属性来设置特性。突然明白为什么JavaScript修改CSS样式要用“XX.style.width=XX”去修改具体样式，因为style是元素节点的属性，是个对象，样式都是style对象里的属性，所以要那样修改。一句话：具体样式是style属性的属性。最后一个方法是removeAttribute（）。用于彻底删除元素特性，不仅删除特性的值，也会从元素完全删除特性。这个方法并不常用，但在序列化DOM元素时，可以通过它来确切地指定要包含哪些特性。4.attributes属性Element类型是唯一使用attributes属性的DOM节点类型。attributes属性中包含一个NamedNodeMap，与NodeList类似，也是一个“动态”的集合。元素的每个特性都由一个Attr节点表示并保存在NamedNodeMap对象中。NameNodeMap对象拥有下列方法：·getNamedItem（name）：返回nodeName属性等于name的节点；·removeNamedItem（name）：从列表中移除nodeName属性等于name的节点；·setNamedItem（node）：向列表中添加节点，以节点的nodeName属性为索引；·item（pos）：返回位于数字pos位置处的节点；其实简单来说，即使每个HTML元素都有特性，特性有attributes属性，这个属性是个NamedNodeMap，里面包含着这个特性的名称，特性的值。element类型的attributes属性的方法可以用来修改、添加特性，修改特性的值。下面举例用两种方法取得元素的id特性：var id = element.attributes.getNamedItem(&quot;id&quot;).nodeValue;//使用方括号语法通过特性名称访问节点的简写方式：var id = element.attributes[&quot;id&quot;].nodeValue;记得ChildNodes属性也是一个NodeList类型，也能用方括号代替namedItem（）访问。还有设置特性的值，删除特性，修改特性的值因为作者说这些attributes属性的方法都不够方便，开发人员更喜欢使用get/set/removeAttribute（）方法。不过，作者说如果想要遍历元素特性，attributes属性可以派上用场。在需要将DOM结构序列化成XML或HTML字符串时，会涉及遍历元素特性，但是我也不知道序列化有什么用，直接贴针对IE7的怪癖的改进版吧：function outputAttribute(element){ var pairs = new Array(),attrName,attrValue,i,len; for(i=0, len=element.attributes.length; i&lt;len; i++){ attrName = element.attributes[i].nodeName; attrValue = element.attributes[i].nodeValue; if(element.attributes[i].specified){ pairs.push(attrName + &quot;=\\&quot;&quot;+attrValue+&quot;\\&quot;&quot;); } } return pairs.join(&quot; &quot;);}这个改进的函数可以确保即使在IE7及更早的版本中，也会返回指定的特性。5.创建元素使用document.createElement（）方法可以创建元素。该方法只接收一个参数，就是要创建元素的标签名。这个标签名在HTML文档中不区分大小写，在XML文档中区分大小写。创建的元素直接使用元素的特性属性设置特性（没必要用setAttribute（）），然后再用appendChid（）、insertBefore、insertAfter（）、replaceChild（）方法插入文档中。例子：var div = document.creatElement(&quot;div&quot;);div.id = &quot;myNewDiv&quot;;div.className = &quot;box&quot;;document.body.appendChild(div); //插入文档的&lt;body&gt;元素中在IE中，要用另一种方式使用createElement（）方法，即为方法传入完整的元素标签。例子：var div = document.createElement(&quot;&lt;div id=\\&quot;myNewDiv\\&quot; class=\\&quot;box\\&quot;&gt;&lt;div&gt;&quot;);这种方式是为了避开IE7及更早版本中用动态创建元素会带来的问题。问题在书中写了就不打进来了。只有IE支持这种写法，其他浏览器都不支持这种写法。createElement（）方法会返回一个DOM元素的引用，利用这个引用把元素插入文档中，或对其加以增强（添加特性）。6.元素的子节点讲的就是子节点内存在空格的问题。例子：&lt;ul id=&quot;myList&quot;&gt; &lt;li&gt;Item1&lt;/li&gt; &lt;li&gt;Item2&lt;/li&gt; &lt;li&gt;Item3&lt;/li&gt;&lt;/ul&gt;如果是IE解析这些代码，那么&lt;ul&gt;元素有3个子节点，如果是其他浏览器，就会有7个子节点。如果需要通过childNodes属性遍历子节点，不要忘记浏览器之间的这种差别。这意味着在执行某些操作前，通常要先检查nodeType属性。例子：for(var i=0,len=element.childNodes.length; i&lt;len; i++){ if(element.childNodes[i].nodeType == 1){ //执行某些操作 }}上面代码表示只在子节点的nodeType等于1（表示是元素节点）的情况下，才会执行这些操作。如果想通过某个特定的标签名取得子节点或后代节点，可以在元素上使用getElementsByTagName（）方法。返回的结果只会返回当前元素的后代，注意：如果它包含更多层次的后代元素，那么哥哥层次中包含的元素也会被返回。（应该是变成二维数组）例子：var ul = document.getElementById(&quot;myList&quot;);var items = ul.getElementsById(&quot;li&quot;);10.1.4Text类型就是HTML代码中的文本。Text节点具有以下特征：·nodeType的值为3；（Node.TEXT_NODE）·nodeName的值为“#text”;（空格的nodeName就是“#text”）·nodeValue的值为节点所包含的文本；·parentNode是一个element；·不支持子节点节点中包含的文本可以通过nodeValue属性或data属性访问到。两个属性中包含的值相同。以下是操作节点中文本的方法：·appendData（text）：将text添加到节点末尾。·deleteData（offset,count）；从offset指定的位置开始删除count个字符。·insertData（offset，text）：从offset指定的位置插入text。·replaceData（offset,count,text）：用text替换从offset指定位置到offset+count为止处的文本。·splitText（offset）：从offset位置将当前文本节点分成两个文本节点。·substringData（offset，count）：提取从offset位置开始到offset+count为止处的字符串。文本节点还有length属性，保存着节点中字符的数目。而且nodeValue.length和data.length也保存同样的值。默认情况下，每个可以包含内容的元素最多只能有一个文本节点，而且必须有内容存在。例子&lt;!–没有内容，没有文本节点–&gt;&lt;div&gt;&lt;/div&gt;&lt;!–有一个空格，有文本节点–&gt;&lt;div&gt; &lt;/div&gt;&lt;!–有内容，有文本节点–&gt;&lt;div&gt;Hello World&lt;/div&gt;跟自己想的有出入，以为文本节点是&lt;p&gt;或&lt;span&gt;里的才叫文本节点，然而只要在可以包含内容的元素内的文本，都叫文本节点。如此一说，就知道为什么空格也被算一个节点了，因为空格也是文本。上面又说默认情况下只有一个文本节点。还记得上面的只有三个&lt;li&gt;子元素的&lt;ul&gt;元素有7个子元素，说明有4个文本节点，这就有别于默认情况了。文本内容可以通过nodeValue或data属性修改，无法在文本里写入HTML代码。例子：div.firstChild.nodeValue = &quot;some &lt;strong&gt;other&lt;/strong&gt;message&quot;;//输出的结果是：&quot;some &amp;lt;other&amp;gt;message&quot;1.创建文本节点使用document.createTextNode（）创建新文本节点。创建后再插入文档中。如果使用了两次这个方法，再分别插入同一个元素节点中，就会变成两个文本节点（并不会融合为一个文本节点）2.规范化文本节点为了解决相邻节点容易导致混乱问题，于是催生了normalize（）方法能够将相邻文本节点合并。例子：var element = document.createElement(&quot;div&quot;);element.class=&quot;message&quot;;var textNode = document.createTextNode(&quot;Hello World&quot;); //创建了第一个文本节点element.appendChild(textNode);var anotherTextNode = document.createTextNode(&quot;Yippee!&quot;); //创建了第二个文本节点element.appendChild(anotherTextNode);document.body.appendChild(element);console.log(element.childNodes.length); //2element.normalize(); //调用这个方法就启动合并console.log(element.childNodes.length); //1console.log(element.firstChild.nodeValue); //Hello WorldYippee!浏览器解析文档时觉得不会创建相邻文本节点，这种情况只会作为DOM操作的结果出现（现在做的事叫DOM操作）。3.分割文本节点使用splitText（）方法可以把一个文本节点按指定位置切割成两个相邻文本节点。分隔文本节点是从文本节点中提取数据的一种常用的DOM解析技术。10.1.5Comment类型注释在DOM中是通过Comment类型来表示的，Comment节点具有下列特征：·nodeType的值是8；·nodeName的值是“#comment”;·nodeValue的值是注释的内容；·parentNode可能是Document或Element;·不支持子节点。Comment类型与Text类型继承自相同的基类。因此它拥有除splitText（）之外的所有字符串操作方法。也可以通过nodeValue或data属性来取得注释内容。可以用document.createComment（）方法创建注释节点，参数是注释文本。10.1.6CDATASection类型CDATASection类型只针对基于XML的文档。表示的是CDATA区域。与comment类似，CDATASection类型继承自Text类型（前面说的是来自相同的基类吧），因此它拥有除splitText（）之外的所有字符串操作方法。CDATASection节点具有下列特征：·nodeType的值是4；·nodeName的值是“#cdata-section”;·nodeValue的值是CDATA区域中的内容；·parentNode可能是Document或Element；·不支持子节点。CDATA区域只会出现在XML文档中，因此多数浏览器会把CDATA区域错误地解析为Comment或Element.在真正的XML文档中可以使用document.createCDataSection（）来创建CDATA区域。10.1.7DocumentType类型DocumentType类型在Web浏览器中并不常用。前面说过支持的情况各浏览器都不同。仅有Firefox、Safari和Opera支持它。DocumentType包含着doctype有关的所有信息，它具有下列特征：·nodeType的值是10；·nodeName的值是doctype的名称;·nodeValue的值是null；·parentNode可能是Document；·不支持子节点。这种支持情况不太好的类型就不细写了。10.1.8DocumentFragment类型在所有节点类型中，只有DocumentFragment类型在文档中没有对应的标记。DOM规定文档片段（document fragment）是一种“轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。DocumentFragement节点具有以下特征：·nodeType的值是11；·nodeName的值是“#document-fragment”;·nodeValue的值是null；·parentNode的值是null;·子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection或EntityReference。虽然文档片段不能添加到文档中，但可以将它作为一个“仓库”来使用，可以在里面保存将可能会添加到文档中的节点。要创建文档片段，可以使用document.createDocumentFragment（）方法。例子：var fragment = document.createDocumentFragment();文档片段继承了Node的所有方法，通常用于执行那些针对文档的DOM操作。如果将文档中的节点添加到文档片段中，就会从文档树中移除该节点。可以通过appendChild（）或insertBefor（）方法将文档片段中的内容添加到文档中。在将文档片段作为参数传递给两个方法时，只会将文档片段中的所有子节点添加到相应位置，文档片段永远不会成为文档树的一部分。例子：&lt;ul id=&quot;myList&quot;&gt;&lt;/ul&gt;假设我们想为&lt;ul&gt;元素添加三个&lt;li&gt;，如果逐个地添加，将会导致浏览器反复渲染（呈现）新信息。为避免这个问题，可以像下面这样使用一个文档片段来保存创建的列表项，然后再一次性地将他们添加到文档中：var fragment = document.createDocumentFragment();var ul = document.getElementById(&quot;myList&quot;);var li = null;for(var i=0; i&lt;3; i++){ li = document.createElement(&quot;li&quot;); li.appendChild(document.createTextNode(&quot;Item&quot;+(i+1))); //给元素插入文本节点也是用appendChild()方法 fragment.appendChild(li); //把元素插入文档片段中}ul.appendChild(fragment); //把文档片段插入ul执行最后一步的时候，文档片段的所有子节点都会在文档片段中被删除并转移到&lt;ul&gt;元素中。10.1.9Attr类型元素的特性在DOM中以Attr类型表示（换句话说，将元素特性归在DOM中的Attr类型中）。从技术上讲，特性就是存在于元素的attributes属性中的节点。特性节点具有下列特征：·nodeType的值为2；·nodeName的值是特性的名称；·nodeValue的值是特性的值；·parentNode的值为Null；·在HTML中不支持子节点；·在XML中子节点可以是Text或EntityReference。尽管特性节点也是节点，但特性节点不被认为是文档树的一部分。开发人员通常使用getAttribute（）、setAttribute（）、removeAttribute（）方法，很少直接引用特性节点。Attr对象有3个属性：name、value和specified。name是特性名称，value是特性值，而specified是一个布尔值，用以区别特性是否在代码中被设置。作者说并不推荐直接访问特性节点，使用getAttribute（）、setAttribute（）、removeAttribute（）方法更方便。就不细讲这个类型了，知道有就行了。10.2DOM操作技术10.2.1动态脚本（动态地引入脚本或传入脚本代码）使用&lt;script&gt;元素传入JavaScript代码的方式有两种。一种是通过src特性引入外部文件，另一种是直接在&lt;script&gt;标签中写代码。这一节要讨论的动态脚本，指的是在页面加载时不存在，但将来的某一时刻通过修改DOM动态添加的脚本。创建动态脚本的方法也有两种：插入外部文件或直接插入JavaScript代码。下面的例子展示动态加载外部的JavaScript文件：var script = document.createElement(&quot;script&quot;);script.type=&quot;text/javascript&quot;;script.src=&quot;client.js&quot;;document.body.appendChild(script);只有在执行到最后一行代码把&lt;script&gt;元素添加到页面中，才会下载外部文件。我们可以把整个过程用下面的函数封装起来：function loadScript(url){ var script = document.createElement(&quot;script&quot;); script.type = &quot;text/javascript&quot;; script.src = url; document.body.appendChild(script);}loadScript(&quot;client.js&quot;);另一种指定JavaScript代码的方式是行内方式，例如这个：&lt;script&gt; function sayHi(){console.log(&quot;Hello World!&quot;);}&lt;/script&gt;从逻辑上讲，下面的DOM代码是有效的：var script = document.createElement(&quot;script&quot;);script.type = &quot;text/javascript&quot;;script.appendChild(document.createTextNode(&quot;function sayHi(){console.log(&quot;Hello World!&quot;);}&quot;));document.body.appendChild(script);在Firefox、Safari、Chrome和Opera中，这些代码是可以正常运行的。但在IE中，则会导致错误。因为IE将&lt;script&gt;视为一个特殊的元素，不允许DOM访问&lt;script&gt;子节点。但是，我们可以用&lt;script&gt;元素的text属性来指定JavaScript代码。例子：var script = document.createElement(&quot;script&quot;);script.type = &quot;text/javascript&quot;;script.text = &quot;function sayHi(){console.log(&quot;Hello World!&quot;);}&quot;;document.body.appendChild(script);上面代码在各大浏览器都可以运行，除了Safari3及以前的版本。但是Safari 3是2008年的东西了，应该不用特地写吧。还是写写兼容Safari3及以前的添加JavaScript代码的封装函数：function loadScriptString(code){ var script = document.createElement(&quot;script&quot;); script.type = &quot;text/javascript&quot;; try{ script.appendChild(document.createTextNode(code)); }catch(ex){ script.text = code; } document.body.appendChild(script);}loadScriptString(&quot;function sayHi(){console.log(‘hi’)}&quot;);实际上，这样执行代码，跟把相同的字符串传入eval（）是一样的。（惊了）其实为什么要只有写代码呢，直接写进全局作用域不好吗。10.2.2动态样式能够把CSS样式包含到HTML页面的元素有两个。其中&lt;link&gt;用来包含来自外部的文件，&lt;style&gt;用来指定嵌入的样式。动态样式也是在代码运行的过程中动态添加到页面中的。下面函数的样式载入方法在所有主流浏览器都可以运行：function loadStyles(url){ var link = document.createElement(&quot;link&quot;), link.rel = &quot;stylesheet&quot;, link.type = &quot;text/css&quot;, link.href = url; var head = document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(link);}loadStyles(&quot;styles.css&quot;);加载外部样式文件是异步的，也就是加载样式与执行JavaScript代码的过程没有固定的次序。另一种定义样式的方式是用&lt;style&gt;元素来包含嵌入式CSS（这种是嵌入式，那写在标签里的呢？），如下所示：&lt;style type=&quot;text/css&quot;&gt;body{ background-color:red;}&lt;/style&gt;按照相同的逻辑，下面的代码应该是有效的：var style = document.createElement(&quot;style&quot;);style.type = &quot;text/css&quot;;style.appendChild(document.createTextNode(&quot;body{background-color:red}&quot;));var head = document.getElementsByTagName(&quot;head&quot;)[0];head.appendChild(style);意思代码可以在Firefox、Opera、Safari和Chrome中运行，在IE中报错。IE将&lt;style&gt;视为与&lt;script&gt;一样特殊的，不允许访问其子节点的节点。要解决这个方法，就要先访问&lt;style&gt;元素的styleSheet属性，再访问这个属性里的cssText属性，该属性可以接受CSS代码。让我们把添加嵌入式样式封装为一个函数，通用的解决方法如下：function loadStyleString(css){ var style = document.createElement(&quot;style&quot;); style.type = &quot;text/css&quot;; try{ style.appendChild(document.createTextNode(css)); }catch(ex){ style.styleSheet.cssText = css; //cssText是在style的styleSheet属性里的 } var head = document.getElementsByTagName(&quot;head&quot;)[0]; head.appendChild(style);}loadStyleString(&quot;body{background-color:red}&quot;);✎：针对IE编写代码时，使用cssText属性要特别小心，在重用同一个&lt;style&gt;元素并再次设置这个属性时，还有将cssText属性设置为空字符串时，这两个情况都会导致浏览器崩溃，至于是在版本几会这样就未可知了。10.2.3操作表格总而言之，就是如果要创建一个下面的表格：&lt;table border=&quot;1&quot; width=&quot;100%&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;需要反反复复用大量的createElement（）和appendChild（）方法，代码很长。为了方便创建表格，HTML DOM为&lt;table&gt;、&lt;tbody&gt;、&lt;tr&gt;元素添加了一些属性和方法，具体晚上补图吧。但是记得上次软件设计大赛直接用document.write（）写入元素节点更加简单粗暴。10.2.4使用NodeList理解NodeList及其“近亲”HTMLCollection和NamedNodeMap，是从整体上透彻理解DOM的关键所在。这三个集合都是“动态的”；每当文档结构发生变化，他们都会马上更新。例如，下列代码会导致无限循环：var divs = document.getElementsByTagName(&quot;div&quot;),i,div;for(i=0; i &lt; divs.length; i++){ div = document.createElement(&quot;div&quot;); document.body.appendChild(div);}因为document.getElementsByTagName（）返回的是一个HTMLCollection，每在循环中插入一个div，divs.length就+1，所以会陷入无限循环。所以如果想迭代一个NodeList，最好是使用length初始化第二个变量，如下所示：var divs = document.getElementsByTagName(&quot;div&quot;),i,div;for(i=0,len=divs.length; i &lt;len; i++){ div = document.createElement(&quot;div&quot;); document.body.appendChild(div);}由于len中保存着对divs.length在循环开始时的一个快照，因此避免了上一个例子中出现的无限循环问题。（说明每次for循环只会在i&lt;len,，i++和下面的代码块上跑N次不会再确认第一个参数？）一般来说，应该尽量减少访问NodeList的次数，因为每访问一次NodeList，都会运行一次基于文档的查询。可以考虑从NodeList中取得的值缓存起来（缓存起来？保存起来？）。不止NodeList，HTMLCollection和NamedNodeMap也可以缓存起来吧。","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"高程","slug":"高程","permalink":"https://millionqw.github.io/tags/高程/"}]},{"title":"《JavaScript高级程序设计》 第九章 客户端检测","date":"2017-11-14T01:32:17.000Z","path":"2017/11/14/《JavaScript高级程序设计》-第九章-客户端检测/","text":"目录9.1能力检测9.1.1更可靠的能力检测（用typeof检测某属性是不是自己要的类型，避免重名）9.1.2能力检测，不是浏览器检测（不要用能力检测推测浏览器）9.2怪癖检测9.3用户代理检测9.3.1用户代理字符串的历史9.3.2用户代理字符串检测技术1.识别呈现引擎2.识别浏览器3.识别平台4.识别window操作系统9.3.3完整代码9.3.4使用方法就是最蛋疼的跨浏览器检测。作者做只要能找到更通用的方法，就优先采用更通用的方法。先设计最通用的方案，然后再使用特定于浏览器的技术增强该方案。9.1能力检测最常见且被广泛接受的客户端检测形式是能力检测（又称特定检测）。能力检测的目标不是识别特定的浏览器。而是识别浏览器的能力。用这种方式不用顾及特定的浏览器如何如何，只要确定浏览器支持特定的能力，就可以给出解决方案。能力检测的基本模式如下：if(object.propertyInQuestion){ //使用object.propertyInQuestion}else if(object.otherPropertyInQuestion){ //第二种方法}else{ //第三种或者抛出错误}要理解能力检测，必须理解两个重要的概念：第一个概念就是先检测达成目的最常用的特性，后检测比较刁钻的特性。第二个概念是必须测试实际要用到的特性，不要用其他特性。一个特性存在，不一定以为着另一个特性也存在（或者不意味着就是你项针对的那个浏览器）。例子：function getWindowWidth(){ if(document.all){ //假设是IE return document.documentElement; //错误的用法 }else{ return window.innerWidth; }}document.all是IE的用法，小伙子以为检测document.all通过，就说明这是个IE浏览器，然而其实Opera也支持document.all方法。所以直接拿想用的特定去检测别用其他特性，就是第二个概念。9.1.1更可靠的能力检测先看一个错误的例子：function isSortable(object){ return !!object.sort}双非运算符：根据自己的检测，应该是可以把所有类型的值转换成布尔值的运算符比如 !!0返回false、！！true返回true、！！字符串返回true。使用这个运算符就可以不用写 if 语句直接知道真假。上面的例子通过检测对象是否存在sort（）方法，来确定对象是否支持排序方法。问题是，如果有一个自定义对象定义了一个sort属性（不是方法），那这个对象也会返回true：var result = isSortable({sort:&quot;Nicholas&quot;});所以检测某个属性是否存在不能确定对象是否支持排序，更好的方式：不如直接检测sort是不是一个函数：function isSortable(object){ return typeof object.sort == &quot;function&quot;;}如果检测确定sort是个函数，那就可以调用它对数据排序。在可能的情况下，要尽量使用typeof进行能力检测。特别是，宿主对象（DOM对象）没有义务让typeof返回合理的值（那还用typeof？？？）。最令人发指的事就发生在IE中（233333），大多数浏览器在检测到document.createElement（）存在的时候，都会返回true。但是在IE8及之前版本中，会返回false [摊手]。因为typeof document.createElement返回的是&quot;object&quot;，而不是&quot;function&quot;。如前所属，DOM对象是宿主对象，IE及更早的版本中的宿主对象是通过COM而非JScript实现的。因此，document.createElement（）函数确实是一个COM对象没毛病。IE9纠正了这个问题，对所有DOM方法都返回&quot;function&quot;。结论就是不能用typeof操作符检测IE8及之前版本的一些DOM方法。关于typeof的行为不标准，IE中还可以举出例子来。Active对象（只有IE支持）与其他对象的行为差异很大。例如，不使用typeof测试某个属性会导致错误。例子：var xhr = new ACtiveXObject(&quot;Microsoft.XMLHttp&quot;);if(xhr.open){ //这里会发生错误 //执行操作}像这样直接把函数作为属性访问会导致JavaScript错误。使用typeof操作符会靠谱一点，但IE对typeof xhr.open会返回&quot;unknown&quot;。这就意味着，在浏览器环境下测试任何对象的某个特性是否存在，要使用下面这个函数：function isHostMethod(object,property){ var t = typeof object[property]; return t == ‘function’||(!!(t=’object’ &amp;&amp; object[property]))||t==’known’; 第二个判断条件是类型要是对象，且属性存在，是对象不就存在了吗？}result = isHostMethod(xhr,&quot;open&quot;); //falseresult = isHostMethod(xhr,&quot;foo&quot;); //false虽然这个函数现在还算可靠，但是不能保证在未来宿主对象保持目前的实现方式不变，也不一定会模仿已有的宿主对象的行为（来达到统一）。所以这个函数，包括其他类似能力检测函数，都不能百分百保障永远可靠。刚刚测试了一下，Edge里没有ActiveObject对象！好奇怪，百度了一下，果然，Edge不支持ActiveX这种老技术了！9.1.2能力检测，不是浏览器检测简而言之，不能通过判断几个特性存不存在就确定浏览器。来看这个错误的例子：//错误！不够具体var isFirefox = !!(navigator.vendor &amp;&amp; navigator.vendorSub);//错误！假设过头了var isIE = !!(document.all &amp;&amp; document.uniqueID);上面代码就是典型的能力检测误用。以前确实可以通过检测navigator.vendor和navigator.vendorSub来确定Firefox浏览器，但是后来Safari也实现了相同的属性，于是这个方法就不能使用了。为检测IE，代码测试了document.all和document.uniqueID。这就相当于假设IE将来的版本会继续存在这两个属性，同时假设未来其他浏览器也没这两个属性，很显然这种不向未来看的检测方法确定浏览器是不靠谱的。实际上，根据浏览器不同将能力组合起来是更可取的方式。如果你知道自己的应用程序需要使用哪些浏览器特性，那么一次性检测所有相关特性，不要分别检测是最好选择。例子：//确定是否有支持Netscape插件var hasNSPlugins = !!(navigator.plugins &amp;&amp; navigator.plugins.length);//确定是否浏览器具有DOM1级规定的能力var hasDOM1 = !!(document.getElementById &amp;&amp; document.createElement &amp;&amp; document.getElementByTagName);感觉这种代码是一口气知道自己的应用程序会用在哪才能做的能力检测吧，就是先检测，再根据能力写代码。不能根据能力的不同做出相应措施。总结：不要用能力检测的结果去确定用户使用的浏览器。9.2怪癖检测与能力检测类似，怪癖检测（quirks detection）的目标是识别浏览器的特殊行为。但与能力检测确认浏览器有什么能力不同，怪癖检测是(ˇ?ˇ) 想检查浏览器有没有什么BUG。通常需要运行一段小代码来确定某特性能不能工作。例如，IE8及更早版本存在一个BUG：如果某个实例属性与[[Enumerable]]标记为false的某个原型属性同名，那么该实例属性将不会出现在 for - in 循环中。可以用下面这段代码检测：var hasDontEnumQuirk = function(){ var o = {toString : function(){}}; for(var prop in o){ if(prop == &quot;toString&quot;){ return false; //函数是检测有怪癖，return false就是没有怪癖。 } } return true;}();以上代码在局部环境创建了一个对象并重写toString（）（刻意与原型属性同名），并用 for - in循环，判断toString（）有没有在循环中，有则确定不是IE8（最好不要这样说，犯了用能力检测判断浏览器的忌讳）没这个quirks。还有一个怪癖在Safari 3以前的版本：会枚举被隐藏的属性（通过继承得到的属性吧）。可以用下面的代码检测：var hasEnumShadowQuirk = function(){ var o = {toString:function(){}}; var count = 0; for(var prop in o){ if(prop == &quot;toString&quot;){ count++; } } return (count &gt; 1);}();枚举的时候当然没必要把toString（）、toLocalestring（）等从Object继承过来的方法枚举出来啦，所以算是被“隐藏”的属性。如果是Safari 3以前版本，就会返回两个toString的实例。9.3用户代理检测第三种，也是争议最大的一种客户端检测技术，叫做用户代理检测。通过检测用户代理字符串来确定实际使用的浏览器。在每一次HTTP请求过程中，用户代理字符串是作为响应首部发送的。用户代理字符串可以通过JavaScript的navigator.userAgent属性访问。在服务器端，通过检测用户代理字符串来确定用户使用的浏览器是常用且广为接受的做法。而在客户端，用户代理检测被视为一种万不得已的做法，其优先级在能力检测和怪癖检测之后。9.3.1用户代理字符串的历史用那么大篇幅讲的竟然是用户代理字符串的历史。总而言之，就是所有浏览器都为了使自己的浏览器能被服务器认可，用户代理字符串都不写自己的真实的浏览器名称，基本都叫做“Mozilla”。除了Opera的几个版本是“Opera”。但是后来Opera好像很狗地伪装成其他的浏览器。用户代理字符串还有很多其他信息，就不列出来了，因为根据浏览器版本不同，格式，显示信息都不同。（亲测当前版本的各浏览器开头都是“Mozilla5.0”）9.3.2用户代理字符串检测技术由于各种历史遗留问题，通过用户代理字符串检测浏览器不是件容易的事。因此，首先要确定你要多么具体的浏览器信息。一般情况下，确定呈现引擎和最低限度的版本就能决定正确的操作方法了。最好不要只为特定的浏览器版本写代码，例如：if(IE6 || IE7){ //不推荐 //代码}上面显示代码在浏览器是IE6，7的时候会执行，这样的代码其实很脆弱。因为它要依据特定的版本来做什么。如果是IE8怎么办？只要有新版本出来，代码就要随之更新。像下面这样就可以避免此问题：if(ieVer &gt;= 6){ //代码}上面代码检测浏览器是否是IE6及6以上。这样能确保代码将来也能起作用。下面的浏览器检测脚本就是本着这种思路写的（向后兼容？）。1.识别呈现引擎我们编写的脚本主要检测五大引擎：IE、Gecko、WebKit、KHTML和Opera（Opera是呈现引擎名字？）为了不在全局作用域添加多余的变量，我们使用模块增强模式来封装检测脚本。检测脚本的基本代码结构如下：function client = function(){ var engine = { //呈现引擎 ie:0, gecko:0, webkit:0, khtml:0, opera:0, //版本号 ver:null }; var browser = { //浏览器 ie:0, firefox:0, safari:0, konq:0, opera:0, chorme:0, //具体的版本 ver:null } var system = { win:false, mac:false, xll:false //移动设备 iphone:false, ipod:false, ipad:false, ios:false, android:false, nokiaN:false, winMobile:false //这里是检测呈现引擎、平台和设备的代码 return { engine:engine browser:browser };}();代码中的私有变量browser用于保存每个浏览器的注意属性。如果是当前使用的浏览器，则这个属性保存的是浮点数值形式的版本号。同样，ver属性中在必要时将会包含字符串形式的浏览器完整版本号。对Opera和IE而言，browser对象中的值等于engine对象中的值。对Konqueror而言，browser.konq和browser.ver属性分别等于engine.khtml和engine.ver属性。最后的代码超级长，好多正则，看得陈某头都大。代码可以检测浏览器，平台，内核，网上也有代码。在P242。9.3.4使用方法前面强调过，不到万不得已不要使用用户代理检测。用户代理检测适用于下列情形：·不能直接准确地使用能力检测或怪癖检测。·同一款浏览器在不同平台下具备不同的能力，这个时候就要确定浏览器在哪个平台。·为了分析跟踪等目的需要确切地知道浏览器。原来以前写的跨浏览器代码叫能力检测。能力检测，怪癖检测，用户代理检测统称客户端检测。","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"高程","slug":"高程","permalink":"https://millionqw.github.io/tags/高程/"}]},{"title":"《JavaScript高级程序设计》 第八章 BOM","date":"2017-11-12T02:45:54.000Z","path":"2017/11/12/《JavaScript高级程序设计》-第八章-BOM/","text":"目录8.1window对象8.1.1全局作用域（window对象）8.1.2窗口关系及框架8.1.3窗口位置（一直没统一的属性。screenLeft、screenTop；screenX、screenY，几个移动窗口的方法，不过一些浏览器没反应）8.1.4窗口大小（仍未统一。innerWidth、innerHeight、outerHeight、outerHeight；clientWidth、clientHeight。几个名词：可见视口、布局视口。几个调整窗口大小的方法）8.1.5导航和打开窗口1.弹出窗口（window.open（））2.安全限制3.弹出窗口屏蔽程序（检测弹出窗口是否被阻止弹出） 8.1.6间歇调用和超时调用（一个间歇调用在开始计时等待执行的那段时间里会往下执行其他代码。它们都会在调用后返回一个数值ID，用于取消它们）8.1.7系统对话框（alert（）、confirm（）、prompt（））8.2location对象8.2.1查询字符串参数8.2.2位置操作（location.assign（）、location.replace（）、location.reload（））8.3navigator对象8.3.1检测插件8.3.2注册处理程序8.4screen对象（“用处不大”）8.5history对象 JavaScript的核心是ECMAScript，但如果要在Web中所以JavaScript，那么BOM（浏览器对象模型，Browser Object Module）无疑才是真正的核心。BOM提供了很多对象，用于访问浏览器的功能。这些功能与任何网页内容无关。多年来，缺少事实上的闺房导致BOM既有意思又有问题。W3C为了把浏览器中JavaScript最基本部分的标准化，已经将BOM的主要方面纳入了HTML5规范中。8.1window对象BOM的核心对象——window。它代表浏览器的一个实例。window对象在浏览器有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。这意味着在网页中定义的任何一个对象、变量和函数，都以window作为其Global对象，因此有权访问parseInt（）等方法。8.1.1全局作用域因为ECMAScript中Global对象的角色由window对象扮演，所以所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。虽然全局变量会成为window对象的属性。但是定义全局变量与在window对象上直接定义属性还是有一点差别的：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。（delete可以删除对象属性，但不能删除用var关键字定义的变量）例子：var age = 29;window.color = &quot;red&quot;; //直接在window对象上定义属性作为全局变量delete window.age; //IE&lt;9会报错，其他浏览器返回false(删除失败)delete window.color //IE&lt;9会报错，其他浏览器返回true（删除成功）console.log(window.age) //29 变量仍存在console.log(window.color) //undefined 已删除真正的原理：通过var语句添加的window属性有一个名为[[Configurable]]的特性，这个特定的值被设置为false，因此这样定义的属性不可以通过delete操作符删除。有意思的是，我想试试能不能通过Object.defineProperty(obj,prop,descriptor）把age的[[Configurable]]修改为true然后删除，直到敲了代码，运行报错了才想起来，[[Configurable]]被设置为false后就不能再改回true（其他三个特性还能修改，以前以为configurable为false后其他三个也不能修改了）。意味着var关键字定义的变量永远不能被delete操作符删除。另外，记住一件事：尝试访问未声明的变量会抛出错误。但是通过查询window对象，可以知道某个可能未声明的变量是否存在。例如：//这里抛出错误，因为oldValue未定义var newValue = oldValue; //这就叫访问一个变量//这里不会报错，因为这是一次属性查询var newValue = window.newValue //undefined本章后面讨论的很多JavaScript对象（location 和navigator）实际上都是window对象的属性（对象是一个对象的属性，要习惯这件事）8.1.2窗口关系及框架如果页面包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames集合中，可以通过数组索引或者框架名称来访问相应的window对象。每个window对象都有一个name属性，其中包含框架的名称，看了数觉得框架这部分会很少用到，写了也用处不大，要就看书P194。8.1.3窗口位置用来确定和修改window对象位置的属性和方法有很多。IE、Safari、Opera和Chrome都提供了screenLeft和screenTop属性，分别表示窗口相对于屏幕左边和上边的位置。Firefox则在screenX和screenY属性中提供相同的窗口位置信息.。Safari和Chrome也同时支持这两个属性。Opera表面上支持，但与screenLeft和screenRight属性并不对应，因此不建议在Opera中属于它们。下面的代码是跨浏览器获得窗口左边和上边的位置：var leftPos = (typeof window.screenLeft == &quot;number&quot;)?window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == &quot;number&quot;)?window.screenTop : window.screenY;优先使用screenLeft和screenTop，不行再用Firefox的screenX、Y。浏览器蛋疼时间：在IE和Opera（亲测Opera最新版没这个问题）中，screenLeft和screenTop中保存的是从屏幕左边和上班到由window对象表示的页面可见区域的距离。换句话说，假设window对象是最外层对象，而且浏览器紧贴屏幕最上端——即y轴左边为0，那么screenTop的值即是位于页面可见区域上方的浏览器工具栏的像素高度。但是在Chrome、Firefox和Safari中，screenY和screenTop中保存的是整个浏览器窗口相对于屏幕的坐标值，即在窗口的y轴左边为0时返回0。（意思就是IE即使整个浏览器顶在左上角，Y轴也不为0，因为有浏览器的工具栏在上面使页面无法真的贴在左上角）更蛋疼的是，Firefor、Safari和Chrome始终返回页面中每个框架的top.screenX和top.screenY值。即使在页面由于被设置了外边距而发生偏移的情况下，相对于window对象用screenX和screenY每次也都会返回相同的值。而IE和Opera则会给出框架相对于屏幕边界的精确坐标值（top对象：top对象始终指向最高（最外）层的框架，也就是指向浏览器窗口）。（这段不懂）最终结果，就是无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值（这部分浏览器和那部分浏览器返回的数值不一致）。然而，使用moveTo（）和moveBy（）方法倒是有可能将窗口精确地移动到一个新位置。这两个方法都接收两个参数，但参数意思不同。·moveTo（）：接收的是新位置的x和y坐标。（其实看to和by就知道参数会不同）·moveBBy（）：接收的是在水平和垂直方向上移动的像素数。亲测只有IE11、Safari（10及以前都没用）是有效果的。Opera，Chrome，Edge都没反应。8.1.4窗口大小跨浏览器确定窗口大小不是一件简单的事（gg）。IE9+、Firefox、Safari、Opera、Chrome均为此提供了4个属性：innerWidth、outerHeight、innerHeight和outerWidth。在IE9+、Safari和Firefox中，outerWidth和outerHeight返回浏览器窗口本身的尺寸（无论从最外层的window对象还是从某个框架访问）。在Opera中，这两个属性的值表示页面视图容器（值Opera中单个标签页对应的浏览窗口）的大小。而innerWidth和innerHeight则表示该容器中页面视图区的大小。在Chrome中。outerWidth、outerHeight与innerWidth和innerHeight返回相同的值。即视口（viewport）大小而非浏览器大小。（又是无法统一）IE8及之前没有提供获得当前浏览器尺寸的属性。不过，它通过DOM提供了页面可见区域的相关信息。在IE、Firefox、Safari、Opera、Chrome中，document.documentElement.clientWidth和document.documentElement.clientHeight中保存了页面视口（viewport）信息。IE6中，这些属性必须在标准模式下才有效。如果是混杂模式，就必须通过document.body.clientWidth和document.body.clientHeight取得相同的信息。虽然最终无法确定浏览器窗口的大小，但可以取得页面视口（viewport）的大小，如下：if(typeof pageWidth != &quot;number&quot;){ if(document.compatMode == &quot;CSS1Compat&quot;){ pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; }else{ pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; }}document.compatMode将在第十章讨论，通过它来确定页面是否处于标准模式。是就用documentElement那个，混杂模式就用body那个。对于移动设备，window.innerWidth和window.innerHeight保存着可见视口，也就是屏幕上可见页面区域的大小（不是整个屏幕，也不是整个页面）。移动IE浏览器不支持这些属性。但通过document.documentElement.clientWidth和document.documentElement.clientHeight可以得到相同的信息。随着页面缩放，这些值也会相应变化。在其他移动浏览器中，document.documentElement度量的是布局视口，即渲染后页面的实际大小（与可见视口不同，可见视口只是整个页面的一小部分）。移动IE浏览器把布局视口信息保存在document.body.clientWidth和document.body.clientHeight中。布局视口的值不会随缩放变化（理所应当）。使用resizeTo（）和resizeBy（）方法可以调整浏览器窗口的大小。都接收两个参数，参数意义：·resizeTo（）：浏览器窗口的新宽度和新高度。·resizeBy（）：新窗口与原窗口的宽度和高度之差。这两个方法也可能被浏览器禁用，没试过。同样两个方法不适用于框架。只对最外层window对象使用。8.1.5导航和打开窗口window.open（）方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。这个方法可以接收4个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览历史记录中当前加载页面的布尔值。通常只需传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。如果为window.open（）传递第二个参数（窗口目标），而且该参数是已有窗口或框架的名称，那么就会在具有该名称的窗口或框架中加载第一个参数指定的URL。例子：window.open(&quot;http://www.wrox.com&quot;,&quot;topFrame&quot;);//等价于：&lt;a href=&quot;http://www.wrox.com&quot; target=&quot;topFrame&quot;&gt;&lt;/a&gt;如果没有窗口或框架叫“topFrame”，则会创建一个新窗口并将其命名为“topFrame”。此外，第二个参数可以是下列任何一个特殊的窗口名称：_self、_parent、_top或_blank（要加引号，_parent、_self、_top都是从自己窗口打开，只有_blank会打开新窗口，不知道前三个有什么区别）。1.弹出窗口如果给window.top（）传递的第二个参数不是一个已经存在的窗口或框架，那么该方法就会根据第三个参数位置上传入的字符串创建一个新窗口或新标签页。如果没有传入第三个参数，那么就会打开一个带有全部默认设置（工具栏、地址栏、状态栏等）的新浏览器窗口（或者打开一个新标签页——根据浏览器设置）。在不会打开新窗口的情况下，会忽略第三个参数。第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些特性。下表列出可以出现在这个字符串中的设置选项：注意：整个字符串不允许出现空格。例子：window.open(&quot;http://www.baidu.com&quot;,&quot;&quot;,&quot;height=600,width=600,top=100,left=500,toolbar=yes,location=no&quot;);//第二个参数没有给窗口目标就会默认弹出新窗口那些toolbar,location,menubar设置yes,no好像都没什么变化啊。又试了试，Firefox可以显示工具栏，其他都不可以，Safari根本没弹出新窗口。window.open（）方法会返回一个指向新窗口的引用（window.open（）有返回值）。引用的对象与其他window对象大致相似，但我们可以对其进行更多控制。例如，有些浏览器默认不允许我们针对主浏览器窗口调整大小或移动位置，但却允许我们针对通过window.open（）创建的窗口调整大小或移动位置。通过这个返回的对象，可以像操作其他窗口一样操作新打开的窗口。例子：var wroxWin = window.open(&quot;http://www.baidu.com&quot;,&quot;&quot;,&quot;height=600,width=600,top=100,left=500,toolbar=yes,resizable=yes&quot;);wroxWin.resizeTo(600,500); //设置打开窗口大小的方法wroxWin.moveTo(300,100); //设置打开坐标的方法wroxWin.close();如果Safari的设置里“阻止弹出式窗口”是被打勾的，Safari就会一点反应都没有，连阻止了弹窗都不说一声，其他浏览器都测试正常。对于浏览器的主窗口，如果没有用户允许是不能关闭它的。不过，弹出窗口可以调用top.close（）在不经用户允许的情况下关闭自己。弹出窗口关闭后，窗口的引用仍然还在，但除了能被检测到closed属性之外，已经没有用处了。wroWin.close();console.log(wroWin.closed); //true弹出窗口虽然有一个指针指向打开它的原始窗口，但原始窗口并没有这样的指针指向弹出窗口。因此，我们只能在必要的时候自己手动来实现跟踪。有些浏览器（如IE和Chrome）会在独立的进程中运行每个标签页。当一个标签页打开另一个标签页时，如果两个window对象之间需要彼此通信，那么新标签页就不能运行在独立的进程中。如果想让新创建的标签页在独立的进程中运行，只要把新标签页的opener属性设置为null即可。例子：var wroxWin = window.open(&quot;http://www.baidu.com&quot;,&quot;&quot;,&quot;height=600,width=600,top=100,left=500,toolbar=yes,resizable=yes&quot;);wroWin.opener = null; //把“打开者”属性关掉，就能在独立进程中运行标签之间的联系一旦被切断，将没有办法恢复。2安全限制简单的说为了防止弹出的网页伪装成系统提示框让用户误点，浏览器的弹出页面都会加上状态栏或地址栏。各浏览器对弹出窗口做出的各种限制。3.弹出窗口屏蔽程序其实我觉得标题应该叫“弹出窗口检测程序”合适。屏蔽弹出窗口一般用户有两种方法：浏览器自己把窗口屏蔽；利用第三方浏览器插件屏蔽。情况不同，window.open（）方法在无法打开时的返回值就不同。第一种无法打开很可能会返回null，第二种无法打开window.open（）会报错。有时候我们的弹出是为了实现某些功能什么的，窗口屏蔽了可能导致一些信息或功能无法给用户，所以我们要检测我们的窗口是不是被屏蔽了。针对第一种情况：var wroxWin = window.open(&quot;http://www.baidu.com&quot;,&quot;_blank&quot;);if(wroxWin == null){ console.log(&quot;The popup was blocked!&quot;);}针对第二种情况，因为window.open（）会抛出错误，所以，在检测返回值的同时，将对window.open（）封装在一个try-catch块中。如下所示：var blocked=false; //因为要用在最下面的if判断，所以要把布尔值放在一个变量中try{ var wroxWin = window.open(&quot;http://www.baidu.com&quot;,&quot;_blank&quot;); if(wroxWin == null){ blocked = true; //try-catch语句修改的blocked在外部环境会同步，说明try-catch语句块不是一个局部环境 }}catch(ex){ blocked = true; //会进到catch，说明抛出错误了，所以blocked在这里为true}if(blocked){ console.log(&quot;The popup was blocked!&quot;);}8.1.6间歇调用和超时调用JavaScript是单线程语言。超时调用需要用到window对象的setTimeout（）方法。第一个参数是可以包含JavaScript代码字符串（和eval（）函数中使用的字符串一样）。例子：//不建议传递字符串setTimeout(&quot;alert(‘Hello World’)&quot;,1000);//推荐的调用方式setTimeout(function(){ console.log(&quot;Hello World&quot;);},1000)由于传递字符串可能导致性能损失，因此不建议以字符串作为第一个参数。调用setTimeout（）调用后，会返回一个数值ID，表示超时调用。这个数值ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用clearTimeout（）方法并将相应的超时调用ID作为参数传递给它。//设置超时调用var timeoutId = setTimeout(function(){ console.log(&quot;Hello World&quot;);},1000);//把它取消：clearTimeout(timeoutId);只要在指定时间尚未过去之前调用setTimeout（），就完全可以取消超时调用。上面的代码在设置超时调用后立即取消，结果就跟什么也没有发生一样（亲测：原来超时调用在等待调用的时候会继续昂下执行代码。）。✎：超时调用的代码是在全局作用域中执行，因此this在非严格模式指向window对象，严格模式下是undefined。间歇调用与超时调用一样会返回一个见间歇调用ID。取消间歇调用的重要性要重于取消超时调用，因为在不加干涉的情况下，间歇调用会一直执行到页面卸载。一般认为，使用超时调用来模拟间歇调用是一种最佳模式。在开发环境下，很少真正使用间歇调用。原因：一个间歇调用可能在前一个间歇调用结束前就启动。使用超时调用可以避免这一点，所以，作者建议最好不要使用间歇调用（亲测超时调用也会在上一个未结束就执行下一个啊）。8.1.7系统对话框alert（）、confirm（）和prompt（）方法能调用系统对话框向用户显示 信息（是用这些方法去，调用，系统对话框）；这几个对话框都是同步和模态的。也就是说，有对话框显示时，代码停止执行，关闭对话框后才恢复执行。alert（）就不解释了。·confirm（）：会有两个按钮，一个OK，一个Cancel（取消）按钮。为了检测用户是点击了OK还是Cancel，可以检查confirm（）返回的布尔值。例子：//这一段写在全局环境会马上执行！if(confirm(&quot;Are you sure&quot;)){ //就不用变量去接返回值了 console.log(&quot;I’m sure&quot;);}else{ console.log(&quot;NO&quot;);}·prompt（）：这是一个“提示”框，提示用户输入一些文本。prompt（）接收两个参数：要显示给用户的文本，文本输入域默认值（可以是空字符串）、例子：prompt(&quot;What’s your name&quot;,&quot;Michael&quot;);如果点击了OK按钮，prompt（）方法返回文本输入值；如果单击了Cancel或没有单击OK按钮，通过其他方式关闭对话框，该方法返回null。（亲测除了Safari点多少次都没有复选框，其他浏览器第一次点就有复选框了）现在的浏览器都会有“如果当前脚本执行过程中会打开两个或多个对话框，那么从第二个对话框开始，每个对话框会有一个复选框，问你要不要阻止后续的对话框”，除非用户刷新页面。如果用户勾选了，那么后续的系统对话框（包括警告框、确认框和提示框）都会被屏蔽。浏览器不会就对话框有没有显示向开发人员提示任何信息，以为着我们不知道后续的对话框有没有打开成功。书里说“如果两次独立的用户操作分别打开两个警告框（仅限警告框），那么这两个警告框中都不会显示复选框。而如果是同一次用户操作会生成两个警告框，那么第二个警告框中就会显示复选框”这句不是很懂。8.2location对象location是最有用的BOM对象之一。它提供给了与当前窗口加载的文档有关的信息，更有导航功能。location对象既是window对象的属性，又是document对象的属性。也就是说，document.location和window.location引用的是同一个对象。location不止保存着当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员根据不同属性访问这些片段。下面是location对象的所有属性：8.2.1查询字符串参数尽管location的search属性可以访问URL包含的查询字符串，但有时候我们想单独获得每个查询字符串参数。可以像下面这样创建一个函数，解析（decode）查询字符串，然后返回包含所有参数的一个对象：function getQueryStringArgs(){ //取得查询字符串并去掉开头的问号 var qs = (location.search.length &gt; 0?location.search.substring(1) : &quot;&quot;), //保存数据的对象 args= {}, //取得每一项 items = qs.length ? qs.split(&quot;&amp;&quot;) : []; //把qs里的字符串按遇“&amp;”就放进一个项，split()返回一个数组 item = null, name = null, value = null, 在for循环里使用 i = 0, len = items.length; //逐个每一项添加到args对象中 for(i=0; i&lt;len; i++){ item = items[i].split(&quot;=&quot;); //遇&quot;=&quot;放在一个数组，这个数组只有一项 name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if(name.length){ args[name] = value; //name是变量，使用中括号连接 } } return args;}8.2.2位置操作使用location对象可以通过很多方式来改变浏览器的位置。最常用的是assign（）方法，参数是一个URL。location.assign(&quot;http://www.wrox.com&amp;quot;);上面代码可以立即打开新URL并在浏览记录里生成一条记录。如果是将location.href或window.location设置为一个URL值，也会以该值调用assign（）方法。下面两行代码与显式调用assign（）方法效果一样（亲测都不能后退）：location.href = &quot;http://www.baidu.com&amp;quot;window.location = &quot;http://www.baidu.com&amp;quot;第一次看到这种看起来像属性，用起来却跟方法一样的属性。在改变浏览器位置的方法中，最常用的是设置location.href属性。此外，还可以通过改变location对象的其他属性改变当前加载的页面。下面的例子通过将hash、search、hostname、pathname、和port属性设置为新值来改变URL。（可以用来像PHP添加&amp;后面的值来实现效果诶）：//假设初始URL为&quot;http://www.wrox.com/WileyCDA/&amp;quot;//将URL修改为&quot;http://www.wrox.com/WileyCDA/#section1&amp;quot; hash：URL中的散列location.hash = &quot;#section1&quot;;//将URL修改为&quot;http://www.wrox.com/WileyCDA/?qijavascript&amp;quot; search：URL的查询字符串location.search = &quot;?q = javascript&quot;;//将URL修改为&quot;http://www.yahoo.com/WileyCDA/&amp;quot; hostname：不带端口号的服务器名称location.hostname = &quot;www.yahoo.com&quot;//将URL修改为&quot;http://www.yahoo.com/mydir/&amp;quot; pathname：URL中的目录和文件名location.pathname = &quot;mydir&quot;;//将URL修改为&quot;http://www.yahoo.com:8080/mydir/&amp;quot; port：端口号location.port = 8080;通过以上方法修改URL之后，浏览器的历史记录就会生成一条记录。所以用户可以通过“后退”按钮导航到前一个页面。要禁用这种行为，可以使用replace（）方法。replace（）方法接收一个参数，即要导航到的URL。这个方法跳转浏览器位置不会在历史记录中生成新纪录，就无法回到前一个页面：location.replace(&quot;http://www.baidu.com&amp;quot;)与位置有关的最后一个方法是reload（）；作用是重新加载当前显示的页面。如果没有给这个方法传递参数，页面就会用最有效的方式重新加载：从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要加true参数：location.reload(); //重新加载（有可能从缓存中加载）location.reload(true); //重新加载（从服务器重新加载）位于reload（）方法后面的代码可能执行也可能不执行，这取决于网络延迟与系统资源等因素。8.3navigator对象navigator对象现在已经成为识别客户端浏览器的事实标准。虽然其他浏览器提供了其他相同或相似的信息（例如IE中的window.clientInformation和Opear中的window.opera），但navigator对象却是所有支持JavaScript的浏览器共有的。与其他BOM对象（location对象、window对象）一样，navigator对象也有自己的一套属性，下列列出了存在所有浏览器的属性和方法，以及支持他们的浏览器版本。8.3.1检测插件plugins数组可以用来检测浏览器是否安装了特定的插件。该数组中的每一项都包含下列属性（这么说每一项都是数组咯）。·name：插件的名字。·description：插件的描述。·filename：插件的文件名。·length：插件所处理的MIME类型。检测插件的方法：检测插件时，需要像下面这样循环迭代每个插件并将插件的name与给定的名字进行比较：//检测插件（在IE中无效）function hasPlugin(name){ name = name.toLowerCase(); for(var i=0; i&lt;navigator.plugins.length; i++){ //navigator.plugins的每一项都是对象 if(navigator.plugins[i].name.toLowerCase().indexOf(name)&gt;-1){ //返回的name有一大串，只要找到里面有插件名就好 return true; } } return false;}console.log(hasPlugin(&quot;Flash&quot;)); //trueconsole.log(hasPlugin(&quot;QuickTime&quot;)); //false一开始以为这个函数可以循环出所有插件名称，结果原来是要传参只能检测一个太垃圾，后来又发现navigator.name里已经有所有插件的名称，只要for循环出来就好。这个方法在Firefox、Safari、Chrome、Opera中都可以用来检测插件。✎：每个插件本身也是一个MimeType对象的数组，这些对象可以通过方括号语法来访问。每个MimeType对象有4个属性：包含MIME类型描述的description、回指插件对象的enabledPlugin、表示与MIME类型对应的文件扩展名的字符串suffixes（以逗号分隔）和表示完整MIME类型字符串的type。亲测我的浏览器有39个插件，用了第6个插件试试，打印出第6个插件，发现前6个属性都是MimeType对象，真的有上面那4个属性。我以为作者说插件是MimeType对象，原来是MimeType对象的数组，但是我检测了又不是数组啊：console.log(navigator.plugins[5] instanceof Array) // falseconsole.log(navigator.plugins[5])//Plugin {0: MimeType, 1: MimeType, 2: MimeType, 3: MimeType, 4: MimeType, 5: MimeType, name: &quot;iTrusChina iTrusPTA,XEnroll,iEnroll,hwPTA,UKeyInstalls Firefox Plugin&quot;, filename: &quot;npcombrg.dll&quot;, description: &quot;iTrusPTA&amp;XEnroll hwPTA,IEnroll,UKeyInstalls for FireFox,version=1.0.0.2&quot;, length: 6}好像只计算了前面六个MimeType为属性，后面的name、filename、description是什么？还是前面的6个是数组，后面那些是属性？console.log(navigator.plugins[5][0]) //用方括号访问，点号无法访问检测IE中的插件比较麻烦，因为IE不支持Netscape式的插件。在IE中检测插件的唯一方式就是使用专有的ActiveXObject类型，并尝试创建一个特定插件的实例。IE是以COM对象的方式实现插件的，而COM对象使用唯一标识符来标志。因此，要想检查特定插件，就必须知道其COM对象标识符（要知道插件的COM对象标识符）。下面的例子找到了Flash的标识符ShockwaveFlash.ShockwaceFlash。知道标识符就可以编写下面代码检测IE中的插件：function hasIEPlugin(name){ try{ new ActiveXObject(name); //实例化ActiveXObject,用try-catch证明如果无法穿件带某个标识符为参数的实例（（书中说叫创建未知COM对象会抛出错误），会报错，而不是返回false return true; }catch(x){ return false; }}console.log(hasIEPlugin(&quot;ShockwaveFlash.ShockwaceFlash&quot;));如果实例化成功，函数返回true，否则抛出错误，返回false。因为IE是要传入特定插件标识符来判断存不存在某个插件的，所以不可能创建一个万能跨浏览器函数来检测是否含有某些插件，只能一个个写，像这样：function hasFlash(){ //单独检测Flash插件的函数 var result = hasPlugin(&quot;Flash&quot;); if(!resule){ result = hasIEPlugin(&quot;ShockwaveFlash.ShockwaceFlash&quot;) } return result}console.log(hasFlash());plugins集合有一个名叫refresh（）的方法，用于刷新plguins以反映最新安装的插件。接收一个参数：表示是否刷新页面的布尔值。如果为true，则会重新加载包含插件的所有页面；否则只更新plugins集合，不重新加载页面。8.3.2注册处理程序这一节不太懂啊，什么RSS，MIME类型，RSS。Firefox2为navigator对象新增了registerContentHandler（）和registerProtocolHandler（）方法（这两个方法是在HTML5定义的）。这两个方法可以让一个站点指明它可以处理特定类型的信息（病句？）。随着RSS阅读器和在线电子邮件程序的兴起，注册处理程序就为像使用桌面应用程序一样默认使用这些在线应用程序提供了一种方式。registerContentHandler（）方法接收三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL、应用程序的名称。举个例子，要将一个站点注册为处理RSS源的处理程序（将站点注册为程序？）：navigator.registerContentHandler(&quot;application/rss+xml&quot;,&quot;http://www.somereader.com?feed=%s&quot;,&quot;Some Reader&quot;);第一个参数是RSS源的MIME类型，第二个参数是接收RSS源URL的URL，其中表示RSS源URL（把源URL加在接收这个URL的URL的后面），浏览器会自动插入。下一次请求RSS源时，浏览器就会打开指定的URL，而相应的Web应用程序就以适当方式来处理该请求。类似的调用方法也适用于registerProtocolHandler（）方法，也接收三个参数：要处理的协议（例如mailto或ftp）（第一个方法接收的是MIME类型）、处理该协议的页面的URL和应用程序的名称。例如，想将一个应用程序注册为默认的邮件客户端：navigator.registerProtocolHandler(&quot;mailto&quot;,&quot;http://www.somemailclient.com?cmd=%s&quot;,&quot;Some Mail Client&quot;);这个例子注册（feed）了一个mailto协议的处理程序，该程序指向一个基于Web的电子邮件客户端。同样，第二个参数仍然是处理相应请求的URL，%s表示原始的请求。8.4screen对象JavaScript中有几个在编程总用处不大的对象，而screen对象就是其中之一（233333）。这些信息经常居中出现在测定客户端能力的站点跟踪工具中，但通常不会用于影响功能。不过，有时候也可能会用到其中的信息来调整浏览器窗口的大小，使其占据屏幕的可能空间，例如：window.resizeTo(screen.availWidth,screen.availHeight);然而几大浏览器都测了，就Firefox听话。浏览器会变得跟屏幕一样大，但浏览器不会移动位置，即变大那部分会被藏在屏幕看不到的地方。8.5history对象history对象是window对象的属性。出于安全考虑，开发人员无法知道用户浏览过的URL。但可以借助用户访问过的页面列表，在不知道实际URL的情况下实现前进和后退。使用go（）方法可以在用户的历史记录中任意跳转。可向前可向后。接受一个参数，表示向前向后跳转的页面数的一个整数值。负数退后，正数前进。例子：history.go(-1); //后退一页history.go(1); //前进一页history.go(2); //前进两页神奇的是可以传递一个字符串，浏览器会根据历史记录中包含该字符串的第一个位置——可能后退，可能前进，看哪个位置更近。如果历史记录不包含该字符串，就什么都不做。例子：//跳转到最近的wrox.com页面history.go(&quot;wrox.com&quot;);//跳转到最近的nczonline.net的页面history.go(&quot;nczonline.net&quot;);这个方法没返回值？回去试试。另外，两个简写方法back（）和forward（）来代替go（）。顾名思义，这两个方法模仿浏览器的“后退”和“前进”按钮。不解释。history对象还有一个length属性，保存历史记录的数量。既包括向前的也包括向后的记录。对刚打开的第一个页面而言，history.length等于0。下面的函数可以检测你的网站是不是用户第一个打开的页面（可以检测是不是被设置为首页吧）：if(history.length==0){ //进到这里说明是打开浏览器第一个访问的网站}✎：当页面的URL改变时，就会生成一条历史记录。在IE8及更高的版本、Opera、Firefox、Safari 3及更高版本、Chrome中，改变URL中的hash值也会生成一条历史记录。","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"高程","slug":"高程","permalink":"https://millionqw.github.io/tags/高程/"}]},{"title":"《JavaScript高级程序设计》 第七章 BOM","date":"2017-11-11T07:07:05.000Z","path":"2017/11/11/《JavaScript高级程序设计》-第七章-函数表达式/","text":"目录7.1递归（arguments.callee（）的作用和用法）7.2闭包（活动对象是函数内的东西，执行环境，作用域链，闭包与内存）7.2.1闭包与变量（闭包保存的是整个变量对象的指针，用立即执行函数获得每次for循环的i值）7.2.2this对象（that = this保存this对象使闭包访问到某个对象）7.2.3内存泄漏（循环引用）7.3模仿块级作用域（利用匿名函数模仿块级作用域； （function（））（）这种特殊的函数表达式）7.4私有变量（利用闭包+构造函数模式创建公有方法来访问私有变量）7.4.1静态私有变量（构造函数模式+原型模式，不加var的全局函数）7.4.2模块模式（用对象字面量创造单例模式）7.4.3增强的模块模式 定义函数的方式有两种，一种是函数声明，一种是函数表达式。函数声明的语法function functionName(arg0,arg1){}函数表达式的语法var functionName = function(arg0,arg1){}用函数表达式创建的函数是匿名函数！这样只算将匿名函数赋值给了一个变量，可以通过这个变量调用这个函数，但不能说这个变量是这个函数的名字。函数声明和函数表达式的不同之处一、JavaScript引擎在解析Javascript代码时会函数声明提升（Function declaration Hoisting）当前执行环境（作用域）上的函数声明，而函数表达式必须等到JavaScript引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式。二、函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以functionName( )形式调用。因为有函数声明提升的存在，所以不建议利用函数声明在判断条件下定义函数//不要这样做！if(condition){ function sayHi(){ alert(‘Hi’); }}else{ function sayHi(){ alert(‘Yo’); }}这在ECMAScript中属于无效语法，JavaScript引擎会修正错误。但是浏览器不同修复的结果不同，所以这样做很危险。不过如果是使用函数表达式，就没什么问题。//可以这样做var sayHi;if(condition){ sayHi = function(){ alert(‘Hi’); }}else{ sayHi = function(){ alert(‘Yo’); }}7.1递归本节重点介绍的不是递归，而是保证递归能够被正确使用的两种方法，及arguments对象中arguments.callee( )方法的使用有一个递归函数like this：function factorial(num){ if(num&lt;=1){ return 1; }else{ return numfactorial(num-1); }}以上函数没毛病，但下面的代码会导致它出错var anotherFactorial = factorial;factorial = null;alert(anotherFactorial(5));代码先把factorial( ）函数保存在变量anotherFactorial中，然后将factorial变量设置为null,结果指向原始函数的引用只剩下一个。但在接下来调用anotherFactorial( )时，由于必须执行factorial（）而factorial已经被设置为Null，所以就导致出错，因为此时函数相当于function anotherFactorial(num){ if(num&lt;=1){ return 1; }else{ return numfactorial(num-1); //此时factorial是null所以调用出现错误 }}这种情况下，使用arguments.callee可以解决这个问题。arguments.callee是一个指向正在执行的函数的指针（专业解释，其实就是arguments.callee（）可以等价与现在正在执行中的那个函数），因此可以用它来实现对函数的递归调用，例如：function factorial(num){ if(num&lt;=1){ return 1; }else{ return numarguments.callee(num-1); //此时arguments.callee（）等价与factorial() }}所以通过arguments.callee（）来代替函数名总比使用函数名更保险。但arguments对象在严格模式下是被禁止使用的，我们可以使用命名函数表达式来达成相同的结果，例如：var factorial = (function f(num){ if(num&lt;1){ return 1; }else{ return numf(num-1); }})以上代码创建了一个名为f( )的命名函数表达式，然后将它赋值给变量factorial。即便把函数赋值给了另一个变量，函数的名字f仍然有效，所以递归调用照样能正确使用。这种方式在严格模式和非严格模式下都行得通。（亲测过即使在外面把 f 设置为null ( f=null )也可以完成调用，因为 f 是在（function f(){ }）括号里定义的，括号里定义的变量不受外部的影响。试过在括号内的函数定义 i = 100，再在外部alert( i )会报错 i 未定义。7.2闭包闭包：指有权访问另一个函数函数作用域中的变量的函数（闭包，是一个函数）要理解闭包，就要先理解作用域和作用域链，这对理解闭包至关重要。所以下面会讲作用域和作用域链。以前面的createComparisonFunction（）函数为例：function creatComparisonFunction(propertyName){ return function(obj1,obj2){ var val1 = obj1[propertyName]; var val2 = obj2[propertyName]; if(val1&lt;val2){ return -1; }else if(val1&gt;val2){ return 1; }else{ return 0; } };}作为返回值返回的函数也算内部函数。很显然内部函数可以使用外部函数的propertyName变量。因为内部函数的作用域中包含createComparisonFunction（）的作用域。当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象（activation object）。在作用域中，外部函数的活动对象（即外部对象的arguments和其他命名参数的值）始终位于第二位，外部函数的外部函数的活动对象位于第三位，直到作用域链终点的全局执行环境。在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量，例子：function compare(val1,val2){ if(val1&lt;val2){ return -1; }else if(val1&gt;val2){ return 1; }else{ return 0; }}var result = compare(5,10);以上代码先定义了compare（）函数，然后又在全局作用域中调用了它、当调用compare（）时，会创建一个包含arguments，val1和val2的活动对象。全局执行环境的变量对象（包含result和compare）在compare（）执行环境的作用域链则处于第二位。图展示了包含上述关系的compare（）函数执行时的作用域链：第0位是compare（）的活动对象，第1位是全局变量对象。后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像compare（）函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare（）函数时（还没开始调用），会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare（）函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链（执行环境在函数调用时才产生，执行环境里有作用域链）。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的最前端（作用域链里是变量对象）。对于这个例子中compare（）函数的执行而言，其作用域链包含两个变量对象：本地活动对象（被当变量对象）和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实例包含变量对象（倒不如说作用域链是人为从JavaScript中看出来的一个“规律”，不可能真的JavaScript里有一个指针“表”吧。）。无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕之后，局部活动对象就会被销毁，内存中仅保存全局作用域。但是闭包的情况又有所不同。在另一个函数内部定义的函数会被包含函数（即外部函数）的活动对象添加到它的作用域链中，因此，在createComparisonFunction（）函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数createComparisonFunction（）的活动对象（arguments，定义的变量 ）。图展示了当下列代码执行时，包含函数与内部匿名函数的作用域链：var compare = createComparisonFunction(&quot;name&quot;);var result = compare({name:&quot;Nicholas&quot;},{name:&quot;Greg&quot;}) //createComparisonFunction()返回的是一个函数，所以这行调用了compare()在匿名函数从createComparisonFunction（）被返回后，它的作用域链被初始化为包含createComparisonFunction（）函数的活动对象（arguments，定义的变量 ）和全局变量对象。这样，匿名函数就可以访问在createComparisonFunction（）中定义的所有变量。compare（）就可以访问createComparisonFunction（）中定义的变量。更重要的是，当createComparisonFunction（）执行完毕后，其活动对象（arguments，定义的变量）不会被销毁。因为匿名函数的作用域链仍然在引用这个活动对象（销毁了不就引用不了了）。换句话说，当createComparisonFunction（）函数返回后，其执行环境的作用域链被销毁（包含函数执行完毕后执行环境的作用域链就销毁），但它的活动对象仍然会留在内存中（活动对象就还在内存中）；直到匿名函数也被销毁，createComparisonFunction（）的活动对象才会被销毁。例如：//创建函数var compareNames = createComparisonFunction(&quot;name&quot;);//调用函数var result = compareNames({name:&quot;Nicholas&quot;},{name:&quot;Greg&quot;}); //别忘了compareNames是函数，没毛病//解除对匿名函数的引用（以便释放内存）compareNames = null; //所以乱用闭包会占用大量内存首先，把返回的比较函数保存在变量compareNames中。最后通过对compareNames设置null解除该函数的引用（体会一下，解除引用，变量compareNames 只是指针），等于通知垃圾收集机制将其清除。随着匿名函数的作用域链被销毁，其他作用域（除了全局作用域）也都可以安全地销毁了。下图展示了调用compareNames（）的过程中产生的作用域链之间的关系：✎：由于闭包会写到包含它的函数的作用域，因此会占用很多内存过度使用闭包会导致内存占用过多，作者建议谨慎使用闭包。也可以手动关闭闭包。内存占用如果过多，在IE可能造成内存泄漏。7.2.1闭包与变量作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。下面这个例子可以清晰地说明这个问题：function createFunction(){ var result = new Array(); for (var i = 0; i &lt;10; i++) { result[i] = function(){ //数组result里保存的是一个个函数，不是i return i; }; } return result; //一个有10个函数在里面的数组}这个函数会返回一个函数数组（项里保存着函数的数组）。表面上看，似乎每个函数都应该返自己的索引值，即位置0的函数返回0，位置1的函数返回1，以此类推。但实际上，每个函数都返回10。因为每个函数的作用域链中都保存着createFunction（）的活动对象，所以他们引用的都是同一个变量i。当createFunction（）函数返回后（createFunction（） 调用结束后），变量 i 的值是10（createFunction（） 的变量对象中 i = 10），此时每个函数都引用着（体会下！引用！，函数里并不保存 i ，i是createFunction（） 他们家的）保存变量 i 的同一个变量对象，所以在每个函数内部 i 的值都是10。（自己的理解：函数被返回但并没有调用，闭包只有被调用时，指针才会去找（引用）那个外部函数的变量对象，此时 i 已经是10。意味着闭包里变量的值不是在赋值时马上保存进变量（这么说并不正确，i 并不是赋值来的），变量只是指针，指向有那个变量的地方（外部函数的变量对象））。一点小亲测：上面的代码，如果这样打印数组的项，只会返回一个函数的源代码：var a = createFunction(); //返回一个数组，a是个数组（说得好别扭，明明a只是一个指向一个数组的指针）console.log(a[1]); //function(){ return i} 就是i，而不是一个数值函数源代码里是return i 而不是return 10.要得到 i 的值，要调用那个函数：console.log(a1); //10就是觉得自己能想到调用这个函数觉得很吊233333所以用下面的立即调用函数返回后马上调用函数，闭包就能得到 i 是0，1，2，3…的变量对象：function createFunction(){ var result = new Array(); for (var i = 0; i &lt;10; i++) { result[i] = function(num){ return function(){ return num //return的是num，return写错写成i的话每个数组里的函数都还是返回10 }; }(i); //立即执行函数最后的括号里带参数，参数的值会赋给函数的命名参数，所以每立即执行一次，num=i } return result;}（这里又让我觉得困惑了：这样数组里每一项函数都会返回各自从0—9的数，因为带参数num的函数被马上执行，环境对象里的num分别是0-9，有10个环境对象，难道有10条作用域链，10个函数在内存里？不会被重写？后来觉得想明白了因为是匿名函数所以不会被重写，但我给带num参数的函数命名之后，还是能成功返回0-9的值，难道没有被重写？）在重写了前面的createFunction（）函数后，每个函数都会返回各自不同的索引值了。在这个版本中，我们没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋给数组。这里匿名函数有一个参数num，也就是最终的函数要返回的值。在调用每个匿名函数时，我们传入了变量 i 。由于函数参数是按值传递的，所以就会将变量 i 的当前值复制给参数num。而在这个匿名函数内部，又创建并返回了一个访问num的闭包。这样一来，result数组中的每个函数都有自己num变量的一个副本。因此就可以返回各自不同的数组了。7.2.2this对象 在闭包中使用this对象也可能会导致一些问题。我们知道this对象是在运行时基于函数的执行环境绑定的：在全局环境中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。不过，匿名函数的执行环境具有全局性，因此其this通常指向window。但有时候由于编写闭包的方式不同，这一点可能不会那么明显。例子：var name=&quot;The window&quot;;var object={ name:&quot;My Object&quot;, getNameFunc:function(){ return function(){ //返回一个闭包 return this.name } }};console.log(object.getNameFunc()();) //“The Window” getNameFunc()返回的是一个函数，所以再加个括号让那个函数执行以上代码先创建一个全局变量name，又创建一个包含name属性的对象。这个对象包含一个方法——getNameFunc（），它返回一个匿名函数，匿名函数返回this.name。调用匿名函数的结果返回一个字符串：The Window。为什么匿名函数没有取得其包含作用域的this对象呢？前面曾经提到过，每个函数在被调用时都会自动取得两个特殊的变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量（难道这两个变量不在活动对象里？活动对象前面说过有arguments和属性，难道只有window环境下的活动对象里的属性才能被纳入活动对象里？）（后来去找了资料想知道什么是活动对象，有人说活动对象的定义是：活动对象就是作用域链上正在被执行和引用的变量对象。要正处于被执行和引用状态下的变量对象才称为活动对象，window下的变量对象应该都是属于被执行和引用的，所以会被闭包找到。而object对象的name变量并没有被执行和引用，所以不会被找到吧）一句话：内部函数（闭包）只会找活动变量，不活的（没有被执行和引用的）不要！不过，把外部作用域（指object对象）的this保存在闭包能够保存的变量里，就可以让闭包访问到该对象了，例子：var name=&quot;The window&quot;;var object={ name:&quot;My Object&quot;, getNameFunc:function(){ var that = this; return function(){ //返回一个闭包 return that.name } }};console.log(object.getNameFunc()();) //&quot;My Object&quot;闭包确实访问不到object环境对象，但你把object环境对象的指针this包装好了放在他面前，它也就只能用这个环境对象下的this了。或者用call（）函数object.getNameFunc()。call(object)也能访问到object对象里的name属性。✎：arguments和this一样也存在这个问题。如果想访问作用域中的arguments对象，必须将对该对象的引用保存在另一个闭包能够访问到的变量里。后面的几个关于this的问题与闭包无关。在几种特殊的情况下，this的值可能会意外地改变。比如：下面的代码是修改前面例子的结果：var name=&quot;The window&quot;;var object={ name:&quot;My Object&quot;, getName:function(){ return this.name; }};以下是几种调用object.getName（）的方式和产生的不同结果：object.name; //&quot;My Object&quot;(object.name)(); //&quot;My Object&quot;(object.getName=object.getName)(); //&quot;The Window&quot; 非严格模式下第一行不解释。第二行在调用这个方法前给它加上了括号。虽然加上括号后，就好像只是在引用一个函数（引用一个函数？），但this的值得到维持，因为object.name和（object.getName（）的定义是相同的）。第三句代码先执行了一条再赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以this的值不能得到维持，结果就返回了“The window”（也就是说赋的值只是getName函数的源代码，已经与object对象无关）。当然我们很少会用到第二三行的那种写法，不过，这个例子有助于说明即使是语法的细微变化，都有可能意外地改变this的值。7.2.3内存泄漏由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集例程（第四章讨论过），因此闭包在IE的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个HTML元素，那么意味着该元素将无法被销毁。例子：function assignHandler(){ var element = document.getElementById(&quot;someElement&quot;); element.onclick = function(){ console.log(element.id); };}以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用（有吗？自己引用自己？）。由于匿名函数保存了一个对assignHandler（）的活动对象的引用，因此就会导致无法减少element的引用数（垃圾回收机制的引用计数机制）。只要匿名函数存在，element的引用数至少会是1.因此它所占用的内存就永远不会不会被回收。这个问题可以通过下面的代码得到解决：function assignHandler(){ var element = document.getElementById(&quot;someElement&quot;); var id=element.id element.onclick = function(){ console.log(id); }; element=null;}上面的代码通过把element.id的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用，但做到这一步还无法解决内存泄漏的问题。必须要记住：闭包会引用包含函数的整个活动对象（看到这里好像懂了为什么上面在一个对象字面量下的闭包不引用那个在对象里的属性，因为闭包只搜索作用域链里的活动对象，而活动对象是函数里的活动对象），而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个引用。因此，有必要把element变量设置为null。这样，就能够解除对DOM对象的引用，顺利地减少引用数，确保正常回收其占用的内存。当然这个只是IE9之前的问题，其他浏览器没这个问题。7.3模仿块级作用域前面说过，JavaScript没有块级作用域，如下面这个例子，在块语句中定义的变量，实际上是在包含函数中而非语句中创建的，例子：function outputNumber(count){ for (var i = 10; i &gt;= 0; i–) { console.log(i) } console.log(i) //-1}即使像下面这样错误地（不知道是这种方式不好还是“错误地”又定义了一边）重新声明一个变量，也不会改变它的值：function outputNumber(count){ for (var i = 10; i &gt;= 0; i–) { console.log(i) } var i; console.log(i) //-1}JavaScript不会跟你说你多次声明了同一个变量，遇到这种情况，JavaScript只会对这个后续声明视而不见。匿名函数可以用来模仿块级作用域并避免这个问题。 用作块级作用域（一般成为私有作用域）的匿名函数的语法如下所示：(function(){ //注意这里，用了函数声明的样子，却没有函数名 //这里是块级作用域})();上面的代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。怎么理解这是个函数表达式呢，正常的函数表达式是这样的：var someFunction = function(){}; someFunction(); 如果我们直接对函数表达式加括号立即调用，将会导致出错：function(){ //块级作用域}(); //出错！因为JavaScript将function关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号。但是函数表达式后面可以跟圆括号啊，要将函数声明转换成函数表达式，只要在函数声明上加上一对圆括号即可：(function(){ //这里是块级作用域 //把一个函数表达式不赋给变量，而是用括号“包装”起来，就有种“被装起来”的感觉吧})()无论在什么地方，只要临时需要一些变量，就可以使用私有作用域，例如：function outputNumbers(count){ (function(){ for(var i=0; i&lt;count; i++){ console.log(i); } })(); console.log(i); //报错：i is not defined} 使用这种特别的函数表达式方法，大概是为了不产生多余的函数名，变量名，因为真的想不出其他让完全无名的函数（这都不能算匿名函数吧，匿名函数还有一个变量在左边）立即执行的方法。 私有作用域中可以访问变量count，是因为这个匿名函数是一个闭包，它能够访问包含作用域中的所有变量。✎：这种做法可以减少闭包占用内存的问题，因为没有指向匿名函数的引用（ i 没有在其他地方用到了）。只要函数执行完毕，就可以立即销毁其作用域链了。7.4私有变量严格来讲， JavaScript中没有私有变量的概念，所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数，局部变量好在函数内部定义的其他函数。例子：function add(num1,num2){ var sum=num1+num2; return sum;}在这个函数中，有三个私有变量：num1和num2和sum，外部无法访问。如果这个函数内部有闭包，那么闭包通过自己的作用域链可以访问这些变量。利用这点，可以创建用于访问私有变量的公有方法。（函数内部的变量可以被访问到）我们把有权访问私有变量的公有方法称为特权方法（privileged method）。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下：function MyObject(){ //这是构造函数 var privateVariable = 10; function privateFunction(){ return false; } //特权方法 this.publicMethod = function(){ //不知道为什么要加this privateVariable++; return privateFunction(); }; //函数表达式本质是给变量赋值，还是要分号}只有作为闭包的特权方法有权访问在构造函数中定义的所有变量和函数（privateVariable和函数privateFunction（））。在创建MyObject的实例后，除了使用publicMethod（）这一个途径外，没有其他方法可以访问到构造函数中定义的变量和函数。利用私有和特权成员，可以隐藏那些不应该被直接修改的数据。例如：function Person(name){ this.getName = function(){ return name; }; this.setName = function(value){ name = value; };}var person = new Person(&quot;Nicholas&quot;);console.log(person.getName());person.setName(&quot;Greg&quot;);console.log(person.getName());以上代码定义了两个特权方法：getName（）和setName（）。这两个方法都可以在构造函数外部使用（当然是要在构造函数的实例下，怪不得要用构造函数，用普通函数这两个方法还怎么调用）。私有变量name在Person的每一个实例中都不相同，因为每次调用构造函数都会重新创建这两个方法（构造函数模式每次方法都会重新创建，原型模式则是共享方法，记得吗）。不过，在构造函数中定义特权方法也有缺点，就是必须使用构造函数来达到这个目的，如上面说的对每个实例都会创建一组同样的新方法。使用静态私有变量来实现特权方法就可以避免这个问题（可以没有一大堆方法在内存）。7.4.1静态私有变量通过在私有作用域（（function（）｛｝）（））中定义私有变量或函数创建特权方法：基本模式如下：(function(){ //私有变量和私有函数 var privateVariable=10; function privateFunction(){ return false; } //构造函数 MyObject = function(){}; //注意这里MyObject变量没有用var关键字，是全局变量 //公有/特权方法 MyObject.prototype.publicMethod = function(){ privateVariable++; return privateFunction(); }})()从代码可以看到，公有方法定义在原型上。这点体现了典型的原型模式。要注意的是，这个方式在定义构造函数时没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数（开始不知道，现在知道为什么了，函数声明没有用到var关键字，在一个函数里，就是一个局部函数了，而函数表达式只要那个变量不使用var关键字，就能变全局函数）。因此，Object就成了一个全局变量，能够在私有作用域之外被访问到。但也要知道，严格模式下定义变量不使用var关键字会报错。这个模式用到了原型模式，所以还是那个问题，方法共享，方法里要修改的变量修改的结果也会被共享：(function(){ var name=&quot;&quot;; Person = function(value){ name = value; }; Person.prototype.getName = function(){ return name; } Person.prototype.setName =function(value){ name = value; };})()var person1 = new Person(&quot;Nicholas&quot;);console.log(person1.getName()); //&quot;Nicholas&quot;person1.setName(&quot;Greg&quot;);console.log(person1.getName()); //&quot;Greg&quot;var person2 = new Person(&quot;Michael&quot;);console.log(person1.getName()); //&quot;Michael&quot;console.log(person2.getName()); //&quot;Michael&quot;例子中的Person构造函数与getName（）和setName（）方法一样，都有权访问私有变量name。在这种模式下，变量name就变成了一个静态的、由所有实例共享的属性。也就是说，在一个实例上调用setName（）会影响所有的实例，而结果就是影响所有实例都会返回相同的值。已这种方式创建静态私有变量会因为使用原型而增加代码复用，但每个实例都没有自己的私有变量（别人想改就改叫私有变量？）。到底是使用实例变量还是静态私有变量，最终还是视具体需求而定。7.4.2模块模式前面的模式是用于为自定义类型创建私有变量和特权方法的（一句话总结上面）。而道格拉斯所说的模块模式（module pattern）则是为单例创建私有变量和特权方法的。所谓单例（singleton），指的就是只有一个实例的对象。JavaScript以对象字面量的方式来创建单例对象：var singleton = { name:value, method:function(){ //方法的代码 }}模块模式通过为单例添加私有变量和特权方法能够使其得到增强。语法形式如下：var singleton = function(){ //私有变量和私有函数 var privateVariable = 10; function privateFunction(){ return false; } //特权/公有方法和属性被返回 return{ //返回一个对象字面量，就是对象 publicProperty:true, publicMethod:function(){ privateVariable++; return privateFunction(); } }}();这个模块模式使用了一个返回对象的匿名函数（singleton不是函数名，只是一个接收返回值的变量）。在这个匿名函数内部，首先定义了私有变量和函数，然后，将一个象字面量作为函数的值返回。返回的对象字面量只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的，例如：var application = function(){ var components = new Array(); components.push(new BaseComponent()); //把构造函数BaseComponent的实例push进数组components return{ getComponentCount:function(){ return components.length; //只返回components的长度，外面无法看到内容 }, registerComponent:function(component){ if(typeof component == &quot;object&quot;){ //小写的&quot;object&quot;，typeof返回的小写的object components.push(component); } } };};function BaseComponent(){ //假设有个BaseComponent构造函数 var name=&quot;Micheal&quot;;}var o={ //假设有个对象o name:&quot;XS&quot;}var person = application();console.log(person.getComponentCount()) //1person.registerComponent(o); //把对象 o push进去console.log(person.getComponentCount()) //2在Web应用程序中，经常需要使用一个单例来管理应用程序级的信息。这个简单的例子创建了一个用于管理组件的application对象。在创建这个对象的过程中，首先声明了一个私有的components数组，并向数组添加了一个BaseComponent的新实例（书中没给出这个构造函数的例子，我自己写了一个，目的是初始化components数组）。返回对象的getComponentCount（）和registerComponent（）方法，都有权访问数组componts的特权方法。前者只放回已注册的组件的数目，后者用于注册主件。.（不明白为什么叫单例，明明再多实例出几个也是可以的，而且对每个实例push数组项并没有互相影响）简而言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是Object的实例，因为返回的都是对象字面量。事实上，这也没什么；毕竟，单例通常都是作为全局对象存在的，我们不会将它传递给一个函数。因此，也就没什么必要使用instanceof操作符检查其对象类型了。（要传给一个对象就要用instanceof操作符检查它的对象类型吗？）7.4.3增强的模块模式有人进一步增强了模块模式。即在返回对象之前对齐增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况。例子：var singleton = function(){ //私有变量和私有函数 var privateVariable = 10; function privateFunction(){ return false; } //创建对象 var object = new CustomType(); //不用关心CustomType()的代码 //公有方法和属性都属于object对象 object.publicProperty = true; object.publicMethod = function(){ privateVariable++; return privateFunction(); }; return object;}();如果前面演示模块模式的例子中的application对象必须是BaseComponent的实例，那么即可以使用以下代码：var application = function(){ //私有变量和函数（这里没私有函数） var components = new Array(); //初始化 components.push(new BaseComponent()); //创建一个application的局部副本 var app = new BaseComponent(); //公共接口 app.getComponentCount = function(){ return components.length; }; app.registerComponent = function(component){ if(typeof component == &quot;object&quot;){ components.push(component); } }; //返回这个副本 return app;}();这个重写后的应用程序（application）单例中，首先也是像前面例子中一样定义了私有变量。主要的不同之处在于命名对象app的创建过程，因为它必须是BaseCompoonent的实例。这个实例实际上是application对象的局部变量版（这句不懂）。此后，我们又为app对象添加了能够访问私有变量的公有方法。最后一步是返回app对象，结果仍然是将它赋给全局变量application。（看到最后一句我就知道为什么我上面对模块模式的使用实例是错的，且知道为什么叫单例模式了。）其实我并不用，也不能再创建一个person变量去“接”application返回出来的对象，因为返回的对象已经被application这个全局变量“接住”了。直接用application调用返回对象的公有方法就好了，var person = application相当于复制了一份对象指针，就不能叫单例了。第七章完结撒花 一会开始第八章","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"高程","slug":"高程","permalink":"https://millionqw.github.io/tags/高程/"}]},{"title":"《JavaScript高级程序设计》第六章 面向对象的程序设计","date":"2017-11-11T05:06:25.000Z","path":"2017/11/11/《JavaScript高级程序设计》第六章-面向对象的程序设计/","text":"目录6.1理解对象6.1.1属性类型（对象有两种属性：数据属性和访问器属性） 1.数据属性（[ [Configurable] ]、[ [Enumerable] ]、[ [Writable] ]、[ [Value] ] ；修改默认特性的方法） 2.访问器属性（[ [Configurable] ] 、[ [Enumerable] ] 、[ [Get] ] 、[ [Set] ]；Object.defineProperty（）修改属性特性 ）6.1.2定义多个属性（Object.defineProperties（）方法修改多个属性特性）6.1.3读取属性的特性（Object.getOwnPropertyDescriptor（））6.2创建对象6.2.1工厂模式（缺点是没解决对象识别问题）6.2.2构造函数模式（缺点是每实例化一个对象就要重写一次方法；实例的constructor属性）1将构造函数当作函数（把构造函数当构造函数用和当普通函数用，函数里的方法的作用环境对象不同）2构造函数的问题6.2.3原型模式（prototype属性、原型对象的constructor属性；实例的[[Prototype]]属性；isPrototypeOf（）、getPrototypeOf（）、hasOwnProperty（）） 1.理解原型对象2.原型与in操作符（in操作符、for-in循环、getOwnPropertyNames（）、keys（））3.更简单的原型语法（用对象字面量法重写原型属性）4原型的动态性（对象字面量修改法要放在使用实例的前面，否则修改在旧实例下无效）5.原生对象的原型（原生对象的方法都是写在原生对象的原型里的）6.原型对象的问题（属性是引用类型值的时候，修改结果也会被共享）6.2.4组合使用构造函数模式和原型模式（属性写在构造函数，方法写在原型）6.2.5动态原型模式6.2.6寄生构造函数模式（存在无法对象识别的问题）6.2.7稳妥构造函数模式（问题同上）6.3继承（JavaScript只有实现继承）6.3.1原型链（利用实例内部指向超类型原型对象的指针[[Prototype]]实现继承）1.别忘记默认的原型（Object是所有函数的默认原型）2.确定原型和实例的关系（使用instanceof操作符和isPrototypeOf（）方法确定原型和实例的关系）3.谨慎地定义方法（子类添加或改写超类型方法的代码一定要写在替换原型的语句之后；对象字面量法重写原型链会导致继承关系断裂）4原型链的问题（还是引用类型值放在原型属性中的问题）6.3.2借用构造函数（有缺陷的方法）1.传递参数2.借用构造函数的问题（还是方法无法复用的问题）6.3.3组合继承6.3.4原型式继承（create（）就是实现原型式继承的方法）6.3.5寄生式继承首先要知道的：ECMAScript中没有类这个概念。ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值，对象或者函数。”每个对象都是基于一个引用类型创建的，这个引用类型可以是第五章讨论的原生类型（Array，Object，Function等），也可以是开发人员定义的类型。6.1理解对象这节就是告诉我们定义对象的时候不要用Object的构造函数那种方法，直接用对象字面量创建对象更好。例子：var person = { name:&quot;Nicholas&quot;, age:29, job:&quot;Software Engineer&quot;, sayName:function(){ console.log(this.name); }};6.1.1属性类型ECMAScript的对象中有两种不同的属性：数据属性和访问器属性。ECMA-262第5版在定义只有内部才有的特性（attribute）时，描述了属性（property）的各种特征。ECMA-262定义特性是为了实现JavaScript引擎用的，所以在JavaScript中无法直接访问特性。为了表示特性是内部值，该规范把他们放在了两对方括号中。例如[[Enumerable]]（[[特性]]）1.数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值（这两句还不懂）。数据属性有4个描述其行为的特性：·[ [Configurable] ]：表示能否通过delete删除属性，能否修改属性的特性，能否把属性从数据属性修改为访问器属性。直接在对象上定义的属性，[ [Configurable] ]的默认值一般为true。·[ [Enumerable] ]：表示能否通过for - in循环返回属性。直接在对象上定义的属性，[ [Enumerable] ] 的默认值一般为true。·[ [Writable] ]：表示该属性是否可写（属性值能不能修改）。直接在对象上定义的属性，[ [Writable ] ] 的默认值一般为true。·[ [Value] ]：包含这个属性的数据值，读取属性值的时候，就是在这个位置读。写入属性值的时候，新值就保存在这个位置。这个特性的默认值为undefined。例子：var person = { name:&quot;Nicholas&quot;,};这里创建了一个名为name的属性，为它指定的值是“Nicholas”。也就是说，[[value]]特性将被设定为“Nicholas”，而对这个值的任何修改都将反映在这个位置。name属性的[Configurable] ]，[ [Writable] ]，[ [Enumerable] ]都默认为true。要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty（）方法。这个方法接收三个参数：属性所在的对象、属性的名字、一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable、value中的其中一个或多个。例子：var person = {};Object.defineProperty(person,&quot;name&quot;,{ writable:false, value:&quot;Nicholas&quot; //利用Object.defineProperty给属性name赋值，顺便设置了这个本来没有的属性});console.log(person.name); //&quot;Nicholas&quot;person.name = &quot;Greg&quot;;console.log(person.name); //&quot;Nicholas&quot;这里例子创建了一个名为name的属性，设置name属性的[ [Writable] ]为不可写。如果尝试为它指定新值，在非严格模式下，赋值操作被忽略，在严格模式下，赋值操作将会导致抛出错误。类似的“非忽严错”的规则也适用于把[ [Configurable] ]设置为false的属性：var person = {};Object.defineProperty(person,&quot;name&quot;,{ configurable:false, value:&quot;Nicholas&quot;});console.log(person.name); //&quot;Nicholas&quot;delete person.nameconsole.log(person.name); //&quot;Nicholas&quot;configurable被设置为false，则无法从对象中删除属性，若进行删除操作，则会“非忽严错”。注意：一旦把属性定义为不可配置的，就不能把它变回可配置的了（有意思）。此时，再调用Object.defineProperty（）方法修改特性，就会抛出错误。注意：在调用Object.defineProperty（）修改属性的特性时，如果不指定，则configurable、enumerable、writable的默认值就会变成false！属性就会自动变成不可配置，不能通过for - in循环返回属性。所以设置的时候最好四个都写上去。不过作者说，在多数情况下，没有必要利用到Object.defineProperty（）。不过，理解这些概念对理解JavaScript对象非常有用。✎IE8是第一个实现Object.defineProperty（）的浏览器版本，但是仍然存在限制，实现不完全。建议不要在IE8上使用这个方法。2.访问器属性需要使用getter和setter函数才能读写的属性。（但是这两个函数都不是必需的）。在读取访问器属性时，会调用getter函数，在写入访问器属性时，会调用setter函数并传入新值。访问器属性有4个特性：·[ [Configurable] ]：表示能否通过delete删除属性，能否修改属性的特性，能否把属性从数据属性修改为访问器属性。直接在对象上定义的属性，[ [Configurable] ]的默认值一般为true。·[ [Enumerable] ]：表示能否通过for - in循环返回属性。直接在对象上定义的属性，[ [Enumerable] ] 的默认值一般为true。·[ [Get] ]：在读取属性时调用的函数。默认值为undefined。·[ [Set] ]：在写入属性时调用的函数。默认值为undefined。访问器属性不能直接定义，必须使用Object.defineProperty（）定义。例子：var book = { _year:2004, edition:1};Object.defineProperty(book,&quot;year&quot;,{ get:function(){ return this._year; }, set:function(newValue){ if(newValue&gt;2004){ this._year = newValue; this.edition += newValue-2004; } }});book.year = 2005;console.log(book.edition); // 2以上代码创建了一个book对象，并给它定义两个默认的属性：_year和edition。_year前面的下划线是一种常用的人为规定的记号（没有程序上的作用），用于表示只能通过对象方法访问的属性（亲测console.log(book._year)可以访问到，大概是因为有用到对象方法访问）。注意这个_year属性并不是访问器属性。访问器属性是year。year包含一个getter函数和setter函数。getter函数返回_year的值，setter函数通过计算来确定正确的版本。因此，把year属性修改为2005会导致_year变成2005（setter属性set的属性不仅是自己的，还可以是同一对象下的其他属性）。而edition变为2。这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。支持ECMAScript5的这两个方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。在这个方法之前，要创建访问器，一般都使用两个非标准的方法：defineGetter（）和defineSetter（）。这两个方法最初都是由Firefox引入的，后来Safari 3、Chrome 1和Opera 9.5也给出了相同的实现。使用这两个遗留的方法，可以像下面这样重写前面的例子：var book = { _year:2004, edition:1};book.defineGetter(&quot;year&quot;,function(){ return this._year;});book.defineSetter(&quot;year&quot;,function(newValue){ if(newValue&gt;2004){ this._year = newValue; this.edition += newValue-2004; }});book.year = 2005;console.log(book.edition);console.log(book.year); // 2在不支持Object.defineProperty（）方法的浏览器中不能修改[ [Configurable] ]和[ [Enumerable] ]特性。6.1.2定义多个属性由于为对象定义多个属性的可能性很大，ECMAScript5又定义了一个Object.defineProperties（）方法。利用这个方法可以一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加或修改属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。例子：var book1 = {};object.defineProperties(book,{ _year:{ writable:true, value:2004 }, edition:{ writable:true, value:1 }, year:{ get:function(){ return this._year; }, set:function(){ if(newValue &gt; 2004){ if(newValue &gt; 2004){ this._year = newValue; this.edition += newValue -2004; } } } }});支持Object.defineProperties（） 方法的浏览器有：IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。 6.1.3读取属性的特性使用ECMAScript5的Object.getOwnPropertyDescriptor（）方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象。是访问器属性就有访问器属性的四个特性，是数据属性就有数据属性的四个特性。例如上面的book对象为例子：console.log(Object.getOwnPropertyDescriptor(book,&quot;_year&quot;));//返回：Object {value: 2004, writable: true, enumerable: true, configurable: true}console.log(Object.getOwnPropertyDescriptor(book,&quot;year&quot;));//返回：Object {enumerable: false, configurable: false} 很奇怪set和get特性要通过Object.getOwnPropertyDescriptor(book,&quot;year&quot;).get和~.set去得到里面set和get里面的函数。在JavaScript中，可以针对任何对象——包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor（）方法。支持这个方法的浏览器有：IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。6.2创建对象为了不写重复代码讨论了很多创建对象的方法。6.2.1工厂模式工厂模式是软件工程领域广为人知的设计模式，这种模式抽象了创建具体对象的过程（把创建对象的过程抽象简化）。因为在ECMAScript中没有类，开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节。例子：function createPerson(name,age,job){ var o = new Object(); //显式地创建对象 o.name = name; o.age = age; o.job = job; o.sayName = function(){ console.log(this.name) }; return 0; //有return语句，不知道有什么不好}var person = createPerson(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);工厂模式解决了创建多个相似对象要写重复代码的问题，但没有解决对象识别的问题（即怎样知道一个对象的类型，后面的由Person对象实例化的对象的类型就是Person类型而不是Object类型，解决了对象识别问题）。随着JavaScript的发展，又一个模式出现了。6.2.2构造函数模式前面几章说过，ECMAScript中的构造函数可以用来创建特定类型的对象（？说过？还不知道原来特定类型的对象可以自己定义，比如后面的Person对象）。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如，可以使用构造函数模式将前面的例子重写如下：function Person(name,age,job){ //构造函数首字母大写，普通函数首字母小写 this.name = name; this.age = age; this.job = job; this.sayName = function(){ console.log(this.name); };}var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);console.log(person1.name);在这个例子中，Person（）与createPerson（）的不同之处在于：没有显式地调用对象，直接将属性和方法赋给了this对象，没有return语句。✎注意：遵照其他OO语言的惯例，构造函数始终都以大写字母开头，非构造函数用小写字母开头。目的是为了区别于ECMAScript中的其他函数。要创建Person对象的实例，必须使用new操作符。以这种方式调用构造函数会经历以下4个步骤：（1）创建一个新对象；（2）将构造函数的作用域赋给新对象（环境变量对象就变成了这个对象，因此this就指向了这个对象）；（3）执行构造函数中的代码（为这个新对象添加属性）；（4）返回新对象。（对象实例诞生！）在前面例子的最后，person1和person2分别保存着Perso的一个不同的实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person（亲测console.log(person1.constructor)打印出了整个构造函数Person的源代码）。例子：console.log(person1.constructor == Person); //trueconsole.log(person1.constructor) //打印出上面构造函数Person的源代码对象的constructor属性最初是用来标识对象类型的。但是想要检测对象类型，还是instanceOf操作符更可靠一些。例子中创建的所有对象既是Object的实例，也是Person的实例，这一点可以通过instanceOf（）操作符验证：console.log(person1 instanceof Object); //trueconsole.log(person1 instanceof Person); //true创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式完胜工厂模式的地方。在这个例子中person1和person2之所以同时是Object的实例，是因为所有对象均继承自Object（详细内容稍后讨论）。✎：以这种方式定义的构造函数是定义在Global对象（在浏览器中是window对象）中的。（？？？又说所有对象继承自Object？？？）第八章会详细讨论浏览器对象模型（BOM）1将构造函数当作函数构造函数与其他函数的唯一区别，就在于调用他们的方式不同。但是归根到底构造函数还是函数。任何函数，只要通过new操作符调用，它就可以作为构造函数。而构造函数如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中的Person（）函数，可以用下面的任一方式调用，例子的重点是，体会用构造函数的方式调用和用普通方式调用两种方法，他们的作用域有什么不同：//当作构造函数调用var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);person1.sayName();//作为普通函数调用Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);window.sayName();//作为普通函数在另一个对象的作用域中调用var o = new Object();Person.call(o,&quot;Kristen&quot;,25,&quot;Nurse&quot;);o.sayName();第一种用法是构造函数的经典用法。第二种用普通的函数调用法：属性和方法都添加给了window对象（window.sayName（）正确的过程是，方法内的this总是指向Global对象，在浏览器中就变成了window对象）。第三种是重点：使用call（）在对象o的作用域中调用Person函数，类似在window对象中调用Person，调用后o也拥有 了所有属性和sayName（）方法。2构造函数的问题还是有人挑出了构造函数的问题。构造函数的问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName（）的方法，但那两个方法不是同一个Function的实例，因为他们在不同的对象环境中创建。从逻辑上讲，此时的构造函数可以这样定义：function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.sayName = new Function(&quot;console.log(this.name)&quot;); //与声明函数在逻辑上是等价的}从这个角度来看构造函数，就更容易明白每个Person实例都包含一个不同的Function实例（但他们的用途完全一样，就是显示name属性）（感觉学到了JavaScript不可言传的东西，这两个方法看起来一模一样，但是他们是两个不同的实例，要纠结他们是不同的实例的原因是，这样会产生不同的作用域链和标识符解析）。但创建Function新实例的机制仍然是相同的。因此，不同对象实例上的同名函数是不相等的，即person1的sayName（）不等于person2的sayName（）。以下代码可以证明这点：console.log(person1.sayName == person2.sayName); // false然而，创建两个完成同样任务的Function实例的确没有必要（导致产生不同的作用域链和标识符解析 ）；况且有this对象在，根本不用在执行代码前把函数绑定到每一个要实例的对象上，因此，可以像下面这种“等一下就要被作者推翻的方法”一样，把函数定义转移到构造函数外面来解决这个问题：function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.sayName sayName; //与声明函数在逻辑上是等价的}function sayName(){ console.log(this.name);}不知道这样会不会产生不同的作用域链，但是这样的好处是Function不用实例两次吧，可能是Function的作用域链不会产生两个，但是实例对象的作用域链还是会产生的。亲测console.log(person1.sayName == person2.sayName)返回的是true。证明他们用到的是一样的在全局环境下的sayName（）函数。但是这样又有一个问题，你在全局作用域定义的函数实际上只被某一个对象调用，如果对象需要很多个这样的方法，那不就要定义很多的全局函数吗。如此一来，我们这个自定义的引用类型就没有丝毫封装性可言了（太多函数暴漏在全局作用域中）。好在，我们可以用原型模式解决这个问题。6.2.3原型模式我们创建的每个函数都有一个prototype（原型）属性。这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的对象的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象（刚又说prototype是函数属性，现在又说是那个又构造函数实例出来的对象的原型对象？）使用原型对象的好处是可以让所有对象实例共享他们所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中（相当于对属性和方法设置一个默认值，在没有明确赋值的情况下，属性和方法的值就等于这个默认值）。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var person1 = new Person();person1.sayName();在此，我们将所有属性和sayName（）直接添加到Person的prototype属性中，构造函数变成了空函数。即便如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法，而且这些属性和方法是所有对象实例共享的。换句话说，person1和person2访问的都是同一组属性和同一个sayName（）函数。console.log(person1.sayName == person2.sayName)//true.要理解原型模式的工作原理，必须先理解ECMAcript中原型对象的性质。1.理解原型对象无论什么情况，只要创建了一个新函数，就会根据一组特定的规则（没有详讲）为该函数创建一个prototype属性（所有函数自带prototype属性）。这个属性指向函数的原型对象（前面又说prototype是原型对象现在又说是指向原型对象，大概因为prototype是个指针指向了原型对象，所以也可以说prototype属性是原型对象吧，有点函数名是函数的指针，所以也可以说这个函数是XX函数名，XX函数名是这个函数的意思）。在默认情况下，所有原型对象（暂且说是prototype，因为prototype指向原型对象）都会自动获得一个constructor（构造函数）属性（每个原型对象自带constructor属性），这个属性是一个指向prototype属性所在函数的指针。就拿前面的例子来说，Person.prototype.constructor指向Person这个函数，这个构造函数（也就是说一个函数里的prototype属性里的constructor属性是个指针，指向这个函数自己）。创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性，至于其他方法和属性，则都是从Object继承而来。当调用构造函数创建一个实例后（注意，这里开始讲的是实例，不是原来那个构造函数了），该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262管这个指针叫[[Prototype]]。虽然在JavaScript中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性protp；而在其他浏览器中，[[Prototype]]则是完全不可见的。要明确的一点是，这个连接是在实例与构造函数的原型对象之间，而不是在实例与构造函数之间（即[[Prototype]]指向构造函数的prototype而不是指向构造函数）。以前面的Person构造函数和Person.prototype创建实例的代码为例，图6-1展示了各个对象之间的关系：上图展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。在此Person.prototype指向了原型对象，而原型对象中的constructor属性又指向了Person.prototype。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例——person1和peron2都包含一个内部属性[[Prototype]]，该属性又指向了原型对象（书里这里写的指向Person.prototype，但应该是指向原型对象才对）；换句话说，他们与构造函数没有直接关系（实例与构造函数没有直接关系！？）。此外，要格外注意的是，虽然这两个实例都不包括属性和方法，但我们却可以调用person1.sayName（）。这是通过查找对象属性的过程来实现的。虽然没有标准的方式访问[[Prototype]]（书里说所有实现（即浏览器）都无法访问到[[Prototype]]，但前面已经说了有三个浏览器可以用proto访问，亲测也确实可以），但可以通过isPrototypeOf（）方法来确定对象之间知否存在这种关系。从本质上讲，如果[[Prototype]]指向调用isPrototypeOf（）方法的这个对象（Person.prototype），那么这个方法就返回true。例子：console.log(Person.prototype.isPrototypeOf(person1)); //trueconsole.log(Person.prototype.isPrototypeOf(person2)); //trueperson1，2的原型对象是Person.prototype，所以返回true，也说明person1，2的[[Prototype]]指向Person.prototype。记住[[Prototype]]是实例对象的内部属性，是一个指针。ECMAScript5还增加了一个新方法，叫Object.getPrototypeOf（），在所有支持的实现（浏览器）中，这个方法返回[[Prototype]]的值。例子：console.log(Object.getPrototypeOf(person1)==Person.prototype); //true，相等，可以证明person1的[[Prototype]]是指向Person.prototype的console.log(Object.getPrototypeOf(person1).name); //&quot;Nicholas&quot; Object.getPrototypeOf（）可以用来获取对象原型的属性第一行代码确定了Object.getPrototypeOf（）返回的对象实际就是这个对象的原型（又跟我自己在注释里写的见解不一样）。第二行代码取得对象原型中name属性的值，即“Nicholas”。使用Object.getPrototypeOf（）可以方便地取得一个对象的原型（prototype）。而这在利用原型实现继承的情况下是非常重要的。支持这个方法的浏览器有： IE9+、Firefox 3.5+、Safari 5+、Opera 12+和Chrome。知道了构造函数有prototype属性之后，我们可以知道，当代码读取某个对象的某个属性时，都会执行一次搜索，目的是找到具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性值；如果没有找到，就继续搜索指针（[[Prototype]]）指向的原型对象（prototype），在原型对象中查找具有给定名字的属性，如果在原型对象中找到这个属性，就返回这个属性的值。所以我们在调用实例对象的属性和方法时会执行两次搜索。这正是多个对象实例共享原型对象所保存的属性和方法的基本原理。✎：前面提到过，原型对象最初只包含一个constructor属性，这个属性也是共享的，可以通过对象实例访问。（亲测访问这个属性会返回构造函数的源代码，之前亲测过了？）虽然我们可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加一个与原型对象中存在的同名属性，则我们就在实例中创建该属性。该属性会屏蔽掉原型中那个属性。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var person1 = new Person();var person2 = new Person();person1.name=&quot;Mike&quot;person1.sayName(); //“Mike” ←来自实例person1.sayName(); //&quot;Niicholas&quot; ←来自原型当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性（书中对“屏蔽”两个字黑体加粗，但是我觉得屏蔽的原理估计又有一大篇文章要讲）。如果把实例中的属性设置为null，也只会在实例中设置这个属性，无法恢复其指向原型的连接。要恢复其指向原型的连接，方法就是使用delete操作符完全删除实例属性，从而我们就可以重新访问原型中的属性。例子：person1.name = &quot;Mike&quot;;person1.name = null;person1.sayName(); //nulldelete person1.name person1.sayName(); //&quot;Nicholas&quot;使用hasOwnProperty（）（注意是Property不是prototype了，property是属性的意思）方法可以检测一个属性是存在实例中，还是原型中。这个方法（不要忘了这个方法继承自Object）在检测的属性是存在实例中的时候，返回true。例子：var person1 = new Person();person1.name=&quot;Mike&quot;delete person1.name;console.log(person1.hasOwnProperty(&quot;name&quot;)); //false，把第三行注释掉就变成true通过hasOwnProperty（）方法，我们访问属性的时候到底访问的是原型对象中的属性还是实例重新定义的属性就一清二楚了。（做了有趣的实验，把实例中的属性保存为跟原型对象属性一样的值，用hasOwnProperty（）方法返回的是true。可不可以说明他们存放的空间不一样？）person1.name=&quot;Nicholas&quot; 与原型对象中的属性值相同console.log(person1.hasOwnProperty(&quot;name&quot;)); //true✎：ECMAScript5的Object.getOwnPropertyDescriptor（）方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用Object.getOwnPropertyDescroptor（）方法。原来前面已经讲过这个方法竟然忘了。不知道什么是属性的描述符，测试了一次发现返回的是对象的属性的四个特性：console.log(Object.getOwnPropertyDescriptor(person1,&quot;name&quot;));//Object {value: &quot;Nicholas&quot;, writable: true, enumerable: true, configurable: true}注意上面的那句话啊！！！每个词都是关键啊！上面说要在原型对象上调用，不是直接用构造函数名调用啊，用构造函数名调用很奇怪，console.log(Object.getOwnPropertyDescriptor(person1,&quot;name&quot;));返回的描述符中的value是“Person”，第二个参数改成“job”或“age”返回的却是undefined。用console.log(Object.getOwnPropertyDescriptor(Person.prototype,&quot;name&quot;));就能返回value是“Nicholas”的描述符。例子：console.log(Object.getOwnPropertyDescriptor(Person,&quot;job&quot;)); //undefinedconsole.log(Object.getOwnPropertyDescriptor(Person,&quot;name&quot;)); //Object {value: &quot;Person&quot;, writable: false, enumerable: false, configurable: true}console.log(Object.getOwnPropertyDescriptor(Person.prototype,&quot;name&quot;));//Object {value: &quot;Nicholas&quot;, writable: true, enumerable: true, configurable: true}后来又继续测试console.log(Person.name);返回的也是“Person”，难道name是每个函数都有的属性返回函数的函数名？2.原型与 in 操作符in操作符的使用有两种方式，一种是单独使用和在for - in循环中使用。在单独使用时，in操作符用于判断某一属性是否在对象中，无论是在实例中还是原型中，只要有就返回true。例子：console.log(&quot;name&quot; in person1) //true 无论name是在实例中还是原型中console.log(&quot;name&quot; in Person) //顺便做了个实验，name属性确实在Person构造函数中console.log(&quot;name&quot; in Person) //false这让我想到一个问题，Person已经有一个name属性的值是“Person”，我们又通过原型对象给原型对象中添加了name属性的值是Nicholas，那值为“Person”的name属性又是来自哪里？？做了个实验，创建一个叫zoo的空函数：function zoo(){}console.log(&quot;name&quot; in zoo); //truein操作符判断后也是返回true，这个name不在原型对象中，也不在实例中，仍然返回true，这个name到底是放在哪？有意思。又做了好多实验，发现用函数声明，函数表达式创建出来的函数都有name属性，但是把这个自定义的函数当构造函数用，实例出来的对象就没有这个name属性。所以还是只有函数有咯。用Object（）构造函数实例的对象也没有name属性。利用 in操作符，结合hasOwnProperty（）方法，我们可以创建一个函数来判断一个属性值到底是来自实例还是原型：function hasPrototypeProperty(object,name){ return !object.hasOwnProperty(name)&amp;&amp;(name in object);}这个是书里定义的函数，我觉得有点绕。这个是检测属性是原型属性返回true。是实例中的属性就返回假，跟我想的相反。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var person = new Person();console.log(hasPrototypePerty(person,&quot;name&quot;)) //trueperson.name = &quot;Greg&quot;;console.log(hasPrototypePerty(person,&quot;name&quot;)) //falsefor - in循环的作用，返回的是所有能通过对象访问的，可枚举的（enumerated）属性，其中既包括实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（[[Enumerable]]：false）的实例属性也会在for - in属性中返回（意思是：比如toString（）方法是Object的原生方法，一般这类方法都是不可枚举的，如果你在实例对象中重写了toString（），那toString（）就变成了可枚举的，会在for - in循环中被列出来）。因为根据规定，所有开发人员定义的属性都是可枚举的。但是IE8及更早版本会有BUG，即屏蔽不可枚举属性的实例属性也不会出现在for - in循环中。例如：var o = { toString : function(){ //重写toString（）方法 return &quot;My Object&quot;; }};for(var prop in o){ if(prop == &quot;toString&quot;){ console.log(&quot;Found String&quot;); //IE8中不会显示 }}上面的例子，本来我已经改写了toString（）了，应该是可以被for - in循环枚举出来的，但是在IE8及更早版本并不会被枚举出来。这个BUG会影响默认不可枚举的所有属性和方法，包括：hasOwnProperty（）、propertyIsEnumerable（）、toLocalString（）、toString（）和valueOf（）。ECMAScript5把constructor和property属性的[[Enumerable]]特性设置为false，但并不是所有浏览器都乖乖听ECMAScript的。要想获取对象上所有可枚举的实例属性（实例属性！原型对象中的属性不会被列举出来），可以使用ECMAScript5的Object.keys（）方法，这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var keys = Object.keys(Person.prototype);console.log(keys) //[&quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]var peron1 = new Person();person1.name = &quot;Mike&quot;;console.log(Object.keys(person1)) //[&quot;name&quot;]有什么实例，数组里才有什么属性，property里定义的属性是Person.prototype对象的实例属性，不是person1的实例属性，person1的实例属性只有一个。如果想要得到所有实例属性，无论是否可枚举，可以使用Object.getOwnPropertyNames（）方法。例子：console.log(Object.getOwnPropertyNames(Person.prototype)); //[&quot;constructor&quot;, &quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]person1.age=28;Object.defineProperty(person1,&quot;name&quot;,{ writable:false, value:&quot;Mike&quot;, enumerable:false}); console.log(Object.keys(person1)); // [&quot;age&quot;]console.log(Object.getOwnPropertyNames(person1)); // [&quot;name&quot;, &quot;age&quot;]还记得前面说的ECMAScript5把constructor（构造函数）属性也设置为不可枚举吗？看来这个浏览器遵循ECMAScript5的规定。Object.keys（）和Object.getOwnPropertyNames（）都可以用来替代for - in循环。支持这两个方法的浏览器有：IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。记住他们返回的都是实例属性，不包括原型对象中的属性。3.更简单的原型语法作者介绍给我们，前面的每添加一个原型属性就要敲一遍Person.prototype的方法太傻了，为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。例子：function Person(){}Person.prototype = { constructor : Person, name : &quot;Nicholas&quot;, age :29, job : &quot;Software Engineer&quot;, sayName : function(){ console.log(this.name); }}理清除，Person.property是指针指向原型对象，所以用对象字面量法给原型对象添加属性和方法是没毛病的。但是这种写法本质上重写了Person.prototype对象，而每个prototype属性都自带有constructor属性，如果在重写中没有加入constructor属性，为constructor重新赋值，则constructor属性将从原型对象中消失。说消失是不准确的，这时候原型对象的constructor属性不再指向Person构造函数，而是指向Object构造函数。但是Person对象的实例仍然是Person的实例。下面的例子假设重写时没有加入constructor属性：console.log(friend instanceof Object); //trueconsole.log(friend instanceof Person); //trueconsole.log(friend.constructor == Person); //falseconsole.log(friend.constructor == Object); //true还有一点要注意的是，重写之后的constructor属性，它的[[Enumerable]]特性会被设置为true（当然是在ECMAScript5已经规定了constructor属性的[[Enumerable]]特性 默认为false且浏览器听它的的情况下）。如果想让它重新变为false，可以人工用Object.defineProperty（）方法设置。4.原型的动态性由于在原型中查找值是一次搜索，所以即使先创建实例后修改原型也是可以的。例子：var friend = new Person();Person.prototype.sayHi = function(){ console.log(&quot;Hi&quot;);};friend.sayHi(); //&quot;Hi&quot; （正常运行）可以看到我们先实例化了Person对象为friend，再修改Person的原型对象。firend仍然能访问到sayHi（）方法。其原因可以归结为实例与原型之间的松散连接关系。因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的sayHi属性并返回保存在那里的函数。尽管可以随时为原型添加属性和方法，但如果是重写整个原型对象，情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototyoe]]指针，而把原型重写为另外一个对象就等于切断了构造函数与最初原型之间的联系（从书中关系图来看，最初原型（旧原型对象）仍指向构造函数，但是构造函数指向了新的原型对象，所以也不是完全切断吧）。作者写到这里突然要我们记住：实例中的指针仅指向原型，不指向构造函数（实例与构造函数之间没有联系）例子：function Person(){}var friend = new Person();Person.prototype = { constructor : Person, name : &quot;Nicholas&quot;, age :29, job : &quot;Software Engineer&quot;, sayName : function(){ console.log(this.name); }};friend.sayName(); //报错： friend.sayName is not a function在这个例子中，我们先创建了一个Person对象，先实例化出一个friend，再重写了原型对象。然后在调用friend.sayName（）的时候就出现了错误。因为friend指向的原型是旧原型，不包含以该名字命名的属性。图6-3展示了这个过程。可以看到重写原型对象会切断现有原型与任何之前已经存在的对象实例之间的关系；之前已经存在的对象实例 仍然引用的是最初的原型。也就是说用重写原型的方式给原型对象添加属性的方法要在重写的那段代码之后再实例化对象，如果是用Person.prototype.属性 = XX这种方法则不存在这种问题。5.原生对象的原型这节讲的是原生对象的原型，什么是原生对象？就是原生的引用类型（Array，Object，String and so on）所有原生引用类型都在其构造函数的原型上（注意原型是谁的属性（prototype是个属性，这个属性是个指针），是构造函数的属性）定义了方法。例如Array类型的sort（）方法就是定义在Array.prototype中的。String类型的substring（）方法就是定义在String.prototype中的。证明例子：console.log(typeof Array.prototype.sort); //functionconsole.log(typeof String.prototype.substring); //functionconsole.log(typeof Array.sort); //undefinedtypeof Array.sort竟然是undefined是令我惊讶的，我以为后台会自动规定sort是Array的方法（所以以前的每次array.sort( )的调用都是在调用Array对象的原型对象中的方法，向Array.prototype致敬！）通过原生对象的原型，不仅可以取得所有默认方法的引用，而且可以定义新方法，可以像修改自定义对象的原型一样修改原生对象的原型，在里面添加新的方法。亲测可以改写原本已经定义的方法，比如toString（）这些。但是不要这样做。书中给出了在原生对象的原型中添加方法的例子，但是他建议不哟这样做，避免命名冲突。就不举例了。6.原型对象的问题原型对象也是有问题的（不能说BUG，合情合理）。原型对象的好处是可以共享属性，但最大的问题也处在了共享的问题上，属性的值是基本类型值还好，如果是包含引用类型的属性，就会出问题了：function Car(){}Car.prototype={ constructor:Car, friends:[&quot;Shelby&quot;,&quot;Court&quot;]}var car1 = new Car();var car2 = new Car();car1.friends.push(&quot;Van&quot;);console.log(car1.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]console.log(car2.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]本来只是像给实例对象car1的friends属性中的数组加入“Van”而已，但是最后car2也有了。因为car1并没有自己重写friends属性，而是直接在默认有的属性值中添加数据，而这个数组是保存在Person.prototype中的，所以刚刚提到的修改也会通过person2.friends反映出来。所以很少有人单独使用原型模式。6.2.4组合使用构造函数模式和原型模式创建自定义类型的最常见方式，是组合使用构造函数模式和原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。这样，每个实例都有自己的一份实例属性的副本（不懂这个实例属性的副本是什么意思），但同时共享对方法的引用，最大限度地节省了内存。重写前面的代码的例子：function Person(name,age,job){ //通过对构造函数传参给独特的属性赋值 this.name = name; this.age = age; this.job = job; this.friends = [&quot;Shelby&quot;,&quot;Court&quot;]; //引用类型写在构造函数中}Person.prototype = { constructor:Person, //别忘了重写constructor属性 sayName:function(){ //一样的方法可以共用 console.log(this.name); }}var person3 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);var person4 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);person3.friends.push(&quot;Van&quot;);console.log(person3.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]console.log(person4.friends); //[&quot;Shelby&quot;, &quot;Court&quot;]console.log(person3.friends == person4.friends); //falseconsole.log(person3.sayName == person4.sayName); //true这种构造函数与原型混成的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。后面几节讲的都是定义引用类型的几种方法，既然说上面的是最好用的，后面的就不写了。6.2.5动态原型模式为看不惯上面的写法的有其他OO语言开发人员使用的方法。6.2.6寄生构造函数模式作者不推荐这种方法，因为这个方法返回的对象与构造函数或者与构造函数的原型属性之间没有关系。也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。也就是说假设用创建了一个Person构造函数，用这个构造函数实例出来的对象并不属于Person，而是属于Object。6.2.7稳妥构造函数模式这个方法也是创建的对象与构造函数之间没有什么关系。6.3继承许多OO语言都支持两个继承方式：接口继承和实现继承。接口继承只继承方法签名。而实现继承则继承实际的方法。如前面章节讲过的，由于函数没有签名（函数没有“函数名”只是一个指针，所以叫没有签名？），在ECMAScript中无法实现接口继承。实现继承主要是依靠原型链实现的。6.3.1原型链ECMAScript中描述了原型链的概念。并将原型链作为实现继承的主要方法。其基本思想是：利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型链实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针（constructor），而实例都包含一个指向原型对象的内部指针（[[Prototype]]）。那么，如果我们让原型对象等于另一个类型的实例，会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针。相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条，这就是所谓原型链的基本概念。实现原型链的基本模式如下：function SuperType(){ this.property = true; //定义的变量名有点复杂，看得有点晕，其实就是一个值为true的变量}SuperType.prototype.getSuperValue = function(){ return this.property;};function SubType(){ this.subproperty = false; //另一个false的变量}//继承了SuperTypeSubType.prototype = new SuperType(); //让一个构造函数A的原型等于另一个构造函数B的实例，这个实例又有一个指向B的原型的指针SubType.prototype.getSubValue = function(){ //这里看得有点懵，其实就是给子对象的原型定义了一个方法，跟上面的代码无关，也没用上 return this.subproperty;}var instance = new SubType(); //创建子对象的实例console.log(instance.getSuperValue()); //true 发现子对象的实例可以调用父对象的方法，返回保存在父对象的变量以上代码定义了两个类型：SuperType和SubType。每个类型各有一个属性一个方法。他们的区别是SubType继承了SuperType。继承的步骤是：通过创建SuperType的实例（new SupperType），并将该实例赋给了SubType.prototype实现。实现的本质是重写原型对象，给原型对象赋值为一个新类型的实例（所以SubType.prototype里的constructor属性也改变了，不是没有了，变成了新类型实例里指向父构造函数的constructor属性，此时constructor为SuperType）。换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了。在确定了继承关系后，我们又不知道有什么卵用地给SubType.prototype添加了一个方法。这样就在继承了SuperType的实例的属性和方法后，又有了自己的方法。这个例子中的实例以及构造函数和原型之间的关系如图：在代码中，我们没有使用SubType默认提供的原型，而是把它重写成了一个新原型，这个新原型就是SuperType的实例。于是，新原型不仅具有作为一个SuperType的实例所拥有的全部属性和方法，而且内部还有一个指针（[[Prototype]]，通了，一开始觉得叫[[Prototype]] 不恰当，想明白了根本不会！因为这个[[Prototype]]属性本来就是SuperType实例中有的），指向SuperType的原型。结果就是这样：instance的[[Prototype]]指向SubType的原型，SubType的原型里的[[Prototype]]又指向SuperType的原型。注意：getSuperValue（）方法仍然还在SuperType.prototype里，SubType.prototype里没有，但property则在SubType.prototype中。书中的解释是：因为property是一个实例属性，而getSuperValue（）是一个原型方法（实例属性会跟着继承在子对象中，原型方法仍然留在父对象的原型中）。解释：既然SubType.prototype现在是SuperType的实例，那么property当然位于实例中了，而getSuperValue（）是在原型中，不在实例中。此外，要注意instance.constructor现在指向的是SuperType，这是因为原来Subtype的原型指向了另一个对象SuperType 的实例，这个实例指向了对象SuperType的原型，SuperType的原型里的constructor属性就是指向SuperType。（书里这样写，可是为什么instance会有constructor属性？constructor不是原型对象才有吗？亲测每个实例都有这个属性，返回这个实例的构造函数。字符串类型的constructor返回到是String（）构造函数）通过原型链的介绍，原型搜索机制又要重新扩展：当以读取模式访问一个实例属性时，首先会在实例中搜索该属性，如果没有找到该属性，就继续搜索实例的原型，在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用instance.getSuperValue（）会经历三个搜索步骤：1）搜索实例；2）搜索SubType.prototype；3）搜索SuperType.prototype，最后一步找到这个方法。搜索过程总是这样一环一环地走到原型链末端才停下来。1.别忘记默认的原型事实上，前面例子中展示的原型链少了一环。我们知道，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是Object的实例（new Object( )），因此默认原型都会包含一个内部指针，指向Object.prototype（又不说这个指针的名字）。这也正是所有自定义类型都会继承toString（）等默认方法的原因（上面讲原型对象的时候说过，原生引用类型的方法都是定义在prototype上的）。所以所有函数的toString（）等默认方法不是在他们自己的prototype属性中，而是通过指针，一层层地找到那些放在Object.prototype里的原型方法的，这样就减少了还能多内存占用吧。所以上面例子展示的原型链中还应包括另外一个继承层次，如图才是真正完整的原型链：2.确定原型和实例的关系可以通过两种方式来确定原型和实例之间的管理，第一种方式使用instanceOf操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。例子：console.log(instance instanceof Object) //trueconsole.log(instance instanceof SubType) //trueconsole.log(instance instanceof SuperType) //true由于原型链的关系，我们可以说instance是Object、SuperType、SubType中任何一个类型的实例。因此三个构造函数的结果都返回true。第二种方式是使用isPrototypeOf（）方法，同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf（）也会返回true:console.log(Object.prototype.isPrototypeOf(instance)); //trueconsole.log(SubType.prototype.isPrototypeOf(instance)); //trueconsole.log(SuperType.prototype.isPrototypeOf(instance)); //true3.谨慎地定义方法子类型有时候会需要覆盖超类型中的某个方法，或者添加超类型中不存在的某个方法。但无论如何，给原型添加方法的代码一定要放在替换原型的语句之后。例子：function SuperType(){ this.property = true;}SuperType.prototype.getSuperValue = function(){ return this.property;};function SubType(){ this.subproperty = false;}//继承了SuperTypeSubType.prototype = new SuperType(); //无论是覆盖还是添加，都要放在替换原型的语句之后//添加新方法SubType.prototype.getSubValue = function(){ return this.subproperty;}//重写超类型中的方法SubType.prototype.getSuperValue = function(){ return false;}var instance = new SubType();console.log(instance.getSuperValue()); //false在上面代码中，加粗部分是两个方法的定义。第一个方法getSubValue（）被添加到了SubType中，第二个方法getSuperValue（）是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的那个方法。换句花说，当通过SubType的实例（instance）调用getSuperValue（）时，调用的是这个重新定义的方法；但通过SuperType的实例调用getSuperValue（）时，还会继续调用原来的那个方法。这里要格外注意的是，必须在用SuperType的实例替换原型之后，再定义这两个方法。从前面的原型链关系图我们知道SuperType的实例调用的是SuperType的原型里的getSuperValue（），SubType的实例一开始是用指针调用SuperType的原型里的getSuperValue（），后来就通过重写在自己的SubType里添加了自己的getSuperValue（）。还有一点要注意到是，在通过原型链实现了继承之后，不能使用对象字面量法重写原型方法，因为这样就重写了原型链，继承就断了。例子：function SuperType(){ this.property = true;}SuperType.prototype.getSuperValue = function(){ return this.property;};function SubType(){ this.subproperty = false;}//继承了SuperTypeSubType.prototype = new SuperType();//使用字面量添加新方法，会导致上一行代码失效SubType.prototype = { getSubValue : function(){ return this.subproperty; }. someOtherMethod : function(){ return this.false; }}var instance = new SubType();console.log(instance.getSuperValue()); //error! 继承关系已断以上代码展示了刚把SuperType的实例赋给Subtype的原型，下面的代码马上就把SubType的原型给重写了，相当于上面的那行赋值被替换了，无效了。相当于现在的原型里包含的是Object的实例（所有函数的默认原型都是Object的实例），而不是SuperType的实例。原型链被切断，SubType和SuperType之间已经没有关系了。4.原型链的问题通过原型链的继承还是存在问题的，就是包含引用类型的那个问题。包含引用类型值的原型属性会被所有实例共享；当其中一个实例修改了原型属性中的引用类型值，整个引用类型值就被修改了。例子：function SuperType(){ this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];}function SubType(){}SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var instance2 = new SubType();console.log(instance2.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]还是引用类型值共享会导致修改类型值会直接修改原型属性里的值的问题。原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数，实际上，应该说是没有办法在不影响所有对象的情况下，给超类型的构造函数传递参数（意思是说不能在SubType.prototype = new SuperType() 给构造函数赋值吗？）。由于前面的两个问题，很少会单独使用原型链。6.3.2借用构造函数为了解决前面的问题，开始人员开始使用一种叫借用构造函数（constructor stealing）的技术（有时候也叫做伪造对象或经典继承）。这种技术的思想相当简单：在子类型构造函数的内部调用超类型的构造函数。别忘了，函数只不过是在特定环境中执行代码的对象。因此，通过使用apply（）和call（）方法也可以在（将来）新创建的对象上执行构造函数。例子：function SuperType(name){ //另一个好处是可以给构造函数赋值 this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; this.name = name;}function SubType(){ //继承了SuperType ，同时传递了参数 SuperType.call(this,&quot;Nicholas&quot;); //不知道这个this有什么用，this不是指向window吗，可能“将来”实例化变成对象之后就指向SubType对象了 this.age = 29}var instance1 = new SubType(); //前面说的将来就是指这个时候，调用了内部的SuperType构造函数instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var instance2 = new SubType();console.log(instance2.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]console.log(instance1.name) //&quot;Nicholas&quot;console.log(instance1.age) //29代码中加粗那行代码“借调”了超类型的构造函数。通过使用call()方法，我们实际上是在（未来将要）新创建的SubType实例的环境（this指向的是SubType实例的环境 ）下调用SuperType构造函数（不一定有new才能调用构造函数）。这样一来，就会在新SubType对象上执行SuperType（）函数中定义的所有对象初始化代码。结果SubType的每个实例都会有自己的colors属性的副本了。但是这种方式并没有使用到SubType.prototype哦。1.传递参数传递参数的例子被我写在上面一起讲了。代码中SuperType接收一个参数name，并在函数内直接给name属性赋值。在SubType构造函数内部调用SuperType构造函数时，实际上是为SubType的实例设置了name的默认属性，虽然这个默认属性不在prototype上。为了确保SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。2.借用构造函数的问题如果只使用借用构造函数，那么也将出现构造函数模式出现的问题——方法都在构造函数中，每实例一个对象就重新复制了一份函数中的方法，影响性能。因此函数的复用就无从谈起。而且，在超类型中定义的方法，对子类型而言是不可见的，结果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数技术也很少使用。6.3.3组合继承组合继承（combination inheritance）有时候也叫伪经典继承。指的是将原型链和借用构造函数的技术组合到一块。背后的思路是：是哦那个原型链实现对原型属性和方法的继承、而通过借用构造函数来实现对实例的继承。例子：function SuperType(name){ this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; //属性写进构造函数里 this.name = name;}SuperType.prototype.sayName = function(){ console.log(this.name);};function SubType(name){ //继承属性 SuperType.call(this,name); ] this.age = age;}//继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType; //如果没有这一步，SubType的原型里concerned属性就是指向SuperTypeSubType.prototype.sayAge = function(){ //方法写进原型里 console.log(this.age);}var instance1 = new SubType(&quot;Nicholas&quot;,29); instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]instance1.sayName(){}; //&quot;Nicholas&quot;instance1.sayAge(){}; //29var instance2 = new SubType(&quot;Greg&quot;,27);console.log(instance2.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]instance2.sayName(); //&quot;Greg&quot;instance2.sayAge(); //27在例子中，SuperType构造函数定义了两个属性：name和colors。SuperType的原型定义了一个方法sayName（）。SubType构造函数在调用SuperType构造函数时传入了name参数，紧接着又定义了自己的属性age。然后，将SuperType的实例赋值给SubType的原型，然后又在该新原型上定义了方法sayAge（）。这样一来，就可以让两个不同的SubType实例既分别拥有自己的属性——包括colors属性，又可以使用相同的方法了。组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中 n继承模式。而且instanceOf和isPrototypeOf（）也能够用于识别基于组合继承创建的对象。6.3.4原型式继承一个有缺陷的继承方式，但是ECMAScript5为这个方式创建了一个create（）方法，跟原型式继承原理相似。这种方法没有使用严格意义上的构造函数。道格拉斯·克罗克福德（提出者）的想法是：借助原型可以基于已有的对象创建新对象。同时还不必因此创建自定义类型（意思就是那个子构造函数（比如那个SubType构造函数）都不用创建了，下面那个方法的返回值直接赋给一个变量，那个变量就是实例了）。下面就是那个函数：function object(o){ function F(){} F.prototype = o; //这个构造函数的原型等于传进来的那个对象，所以不用创建自定义类型，这个F就相当于那个自定义类型了 return new F(); //返回一个构造函数的实例，赋给一个变量就相当于实现了继承}在Object（）函数内部，先创建了一个临时性的构造函数（F），然后将闯入的对象作为这个构造函数的原型（ F.prototype = o ），最后返回这个临时类型的新实例。从本质上讲，object（）对传入其中的对象执行了一次浅复制。看下面例子：var person = { name:&quot;Nicholas&quot;, friends:[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]};var anotherPerson = object(person); //调用object()，传进去的person相当于超类型anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;); //注意这里给friends数组引用类型值推入一个数据的只是anotherPersonvar yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;); //注意这里第二个子实例yetAnotherPerson也给数组推入一个Barbieconsole.log(person.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;, &quot;Rob&quot;, &quot;Barbie&quot;] //超类型里的数组里也多了Rob和Barbie✎：反正直接在对象字面量里定义值为引用类型值的属性被改写就会GG（一开始打这句话的时候是写“直接在原型里定义值为引用类型值的属性就GG”，想想不对，上面的person是在自己那里定义的引用类型值属性不是在原型里啊。object（）方法返回的是F（）的实例，是F的原型（F.prototype）复制了person的属性哦，所以anotherPerson和yetAnotherPerson对象改的应该是F.prototype里的数组吧，为什么person也会受影响呢？想想，可能是：person对象作为函数参数传入了函数object（），虽然JavaScript是按值传递的，但person是对象，F.prototype = o 相当于F.prototype成了对象person的指针（相当于复制了对象的指针），所以看起来改的是F.prototype，但其实F.prototype里没有这个属性，本质上改的应该是person对象里的属性，况且F在object（）函数执行完后已经被销毁，但anotherPerson和yetAnotherPerson 保存了F的实例，也就保存了F的prototype原型对象）。如果有一个超类型的对象在的话，我们就可以使用object( )函数，把超类型作为参数传入，然后函数就会返回一个新对象。在这个例子中，作为超类型的对象是person对象（注意对象首字母是小写，它的作用不是作为构造函数），把person放入object（）传入函数，返回一个新对象，这个新对象将person作为原型（其实应该说 F 将person作为原型），所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。这意味着person.friend不仅属于person所有，而且也会被anotherPerson和yetAnotherPerson共享。实际上，这就相当于又创建了person对象的两个副本（说副本还是有门道的，是副本不是指针，如果是指针的话，anotherPerson和yetAnotherPerson 修改name属性的话，person也会被改，但亲测并不会，虽然F.prototype是person的指针，但new F（），F的实例不是指针，算了解释不下去了，以前是SubType.portotype = new SuperType（）好歹是别人的实例就一定不是指针，但 F.prototype = o 是指针无疑啊，为什么anotherPerson和yetAnotherPerson 会有自己的name属性呢？）。ECMAScript5通过新Object.create（）方法规范了原型式继承。这个方法接收两个参数：一个用作新对象的父对象和一个为新对象定义额外的属性的对象（可选，意思就是用对象字面量的方法定义新对象的额外属性）。在传入一个参数的情况下，Object.create（）与object（）方法的行为相同。var person = { name:&quot;Nicholas&quot;, friends:[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]};var anotherPerson = Object.create(person);anotherPerson.name = &quot;Greg&quot;; //后面的代码会教不用这样写anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);console.log(person.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;, &quot;Rob&quot;, &quot;Barbie&quot;] 仍然存在的问题Object.create（）的第二个参数与Object.defineProperties（）方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性：var anotherPerson = Object.create(person,{ name:{ value:&quot;Greg&quot; //好麻烦啊这样写 }})console.log(anotherPerson.name) //&quot;Greg&quot;果然用上面的参数格式，其他三个特性不写，全部会由默认true变成默认false:console.log(Object.getOwnPropertyDescriptor(anotherPerson,&quot;name&quot;))//Object {value: &quot;Greg&quot;, writable: false, enumerable: false, configurable: false}console.log(Object.getOwnPropertyDescriptor(yetAnotherPerson,&quot;name&quot;))//Object {value: &quot;Linda&quot;, writable: true, enumerable: true, configurable: true}默认的自定义对象的三个特性都是true，如果用Object.defineProperties（）的格式修改描述符的定义，没有列出来，则默认会被后台修改为false。6.3.5寄生式继承寄生式（parasitic）继承也是克罗克福德提出来的，与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工程模式类似，既创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。Conflicting modification on 2017年2月15日 下午11:36:25:目录6.1理解对象6.1.1属性类型（对象有两种属性：数据属性和访问器属性） 1.数据属性（[ [Configurable] ]、[ [Enumerable] ]、[ [Writable] ]、[ [Value] ] ；修改默认特性的方法） 2.访问器属性（[ [Configurable] ] 、[ [Enumerable] ] 、[ [Get] ] 、[ [Set] ] ）6.1.2定义多个属性（Object.defineProperties( ）用对象字面量的方式传入第二个参数)6.1.3读取属性的特性（Object.getOwnPropertyDsecriptor（）方法）6.2创建对象6.2.1工厂模式（没有解决对象识别问题）6.2.2构造函数模式（每多一个实例就添加很多重复的方法；实例对象的constructor属性；自定义函数是定义在Global对象中的）1.将构造函数当作函数2.构造函数的问题（每个实例上都重新创建了一次方法）6.2.3原型模式1.理解原型对象（prototype属性，prototype里的constructor属性，实例的[[prototype]]属性；isprototypeOf（）；getPrototypeOf（）；hasOwnProperty（）判断是原型属性的值还是有重写）2.原型与in操作符（）首先要知道的：ECMAScript中没有类这个概念。ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值，对象或者函数。”每个对象都是基于一个引用类型创建的，这个引用类型可以是第五章讨论的原生类型（Array，Object，Function等），也可以是开发人员定义的类型。6.1理解对象这节就是告诉我们定义对象的时候不要用Object的构造函数那种方法，直接用对象字面量创建对象更好。例子：var person = { name:&quot;Nicholas&quot;, age:29, job:&quot;Software Engineer&quot;, sayName:function(){ console.log(this.name); }};6.1.1属性类型ECMAScript的对象中有两种不同的属性：数据属性和访问器属性。ECMA-262第5版在定义只有内部才有的特性（attribute）时，描述了属性（property）的各种特征。ECMA-262定义特性是为了实现JavaScript引擎用的，所以在JavaScript中无法直接访问特性。为了表示特性是内部值，该规范把他们放在了两对方括号中。例如[[Enumerable]]（[[特性]]）1.数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值（这两句还不懂）。数据属性有4个描述其行为的特性：·[ [Configurable] ]：表示能否通过delete删除属性，能否修改属性的特性，能否把属性从数据属性修改为访问器属性。直接在对象上定义的属性，[ [Configurable] ]的默认值一般为true。·[ [Enumerable] ]：表示能否通过for - in循环返回属性。直接在对象上定义的属性，[ [Enumerable] ] 的默认值一般为true。·[ [Writable] ]：表示该属性是否可写（属性值能不能修改）。直接在对象上定义的属性，[ [Writable ] ] 的默认值一般为true。·[ [Value] ]：包含这个属性的数据值，读取属性值的时候，就是在这个位置读。写入属性值的时候，新值就保存在这个位置。这个特性的默认值为undefined。例子：var person = { name:&quot;Nicholas&quot;,};这里创建了一个名为name的属性，为它指定的值是“Nicholas”。也就是说，[[value]]特性将被设定为“Nicholas”，而对这个值的任何修改都将反映在这个位置。name属性的[Configurable] ]，[ [Writable] ]，[ [Enumerable] ]都默认为true。要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty（）方法。这个方法接收三个参数：属性所在的对象、属性的名字、一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable、value中的其中一个或多个。例子：var person = {};Object.defineProperty(person,&quot;name&quot;,{ writable:false, value:&quot;Nicholas&quot; //利用Object.defineProperty给属性name赋值，顺便设置了这个本来没有的属性});console.log(person.name); //&quot;Nicholas&quot;person.name = &quot;Greg&quot;;console.log(person.name); //&quot;Nicholas&quot;这里例子创建了一个名为name的属性，设置name属性的[ [Writable] ]为不可写。如果尝试为它指定新值，在非严格模式下，赋值操作被忽略，在严格模式下，赋值操作将会导致抛出错误。类似的“非忽严错”的规则也适用于把[ [Configurable] ]设置为false的属性：var person = {};Object.defineProperty(person,&quot;name&quot;,{ configurable:false, value:&quot;Nicholas&quot;});console.log(person.name); //&quot;Nicholas&quot;delete person.nameconsole.log(person.name); //&quot;Nicholas&quot;configurable被设置为false，则无法从对象中删除属性，若进行删除操作，则会“非忽严错”。注意：一旦把属性定义为不可配置的，就不能把它变回可配置的了（有意思）。此时，再调用Object.defineProperty（）方法修改特性，就会抛出错误。注意：在调用Object.defineProperty（）修改属性的特性时，如果不指定，则configurable、enumerable、writable的默认值就会变成false！属性就会自动变成不可配置，不能通过for - in循环返回属性。所以设置的时候最好四个都写上去。不过作者说，在多数情况下，没有必要利用到Object.defineProperty（）。不过，理解这些概念对理解JavaScript对象非常有用。✎IE8是第一个实现Object.defineProperty（）的浏览器版本，但是仍然存在限制，实现不完全。建议不要在IE8上使用这个方法。2.访问器属性需要使用getter和setter函数才能读写的属性。（但是这两个函数都不是必需的）。在读取访问器属性时，会调用getter函数，在写入访问器属性时，会调用setter函数并传入新值。访问器属性有4个特性：·[ [Configurable] ]：表示能否通过delete删除属性，能否修改属性的特性，能否把属性从数据属性修改为访问器属性。直接在对象上定义的属性，[ [Configurable] ]的默认值一般为true。·[ [Enumerable] ]：表示能否通过for - in循环返回属性。直接在对象上定义的属性，[ [Enumerable] ] 的默认值一般为true。·[ [Get] ]：在读取属性时调用的函数。默认值为undefined。·[ [Set] ]：在写入属性时调用的函数。默认值为undefined。访问器属性不能直接定义，必须使用Object.defineProperty（）定义。例子：var book = { _year:2004, edition:1};Object.defineProperty(book,&quot;year&quot;,{ get:function(){ return this._year; }, set:function(newValue){ if(newValue&gt;2004){ this._year = newValue; this.edition += newValue-2004; } }});book.year = 2005;console.log(book.edition); // 2以上代码创建了一个book对象，并给它定义两个默认的属性：_year和edition。_year前面的下划线是一种常用的人为规定的记号（没有程序上的作用），用于表示只能通过对象方法访问的属性（亲测console.log(book._year)可以访问到，大概是因为有用到对象方法访问）。注意这个_year属性并不是访问器属性。访问器属性是year。year包含一个getter函数和setter函数。getter函数返回_year的值，setter函数通过计算来确定正确的版本。因此，把year属性修改为2005会导致_year变成2005（setter属性set的属性不仅是自己的，还可以是同一对象下的其他属性）。而edition变为2。这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。支持ECMAScript5的这两个方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。在这个方法之前，要创建访问器，一般都使用两个非标准的方法：defineGetter（）和defineSetter（）。这两个方法最初都是由Firefox引入的，后来Safari 3、Chrome 1和Opera 9.5也给出了相同的实现。使用这两个遗留的方法，可以像下面这样重写前面的例子：var book = { _year:2004, edition:1};book.defineGetter(&quot;year&quot;,function(){ return this._year;});book.defineSetter(&quot;year&quot;,function(newValue){ if(newValue&gt;2004){ this._year = newValue; this.edition += newValue-2004; }});book.year = 2005;console.log(book.edition);console.log(book.year); // 2在不支持Object.defineProperty（）方法的浏览器中不能修改[ [Configurable] ]和[ [Enumerable] ]特性。6.1.2定义多个属性由于为对象定义多个属性的可能性很大，ECMAScript5又定义了一个Object.defineProperties（）方法。利用这个方法可以一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加或修改属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。例子：var book1 = {};object.defineProperties(book,{ _year:{ writable:true, value:2004 }, edition:{ writable:true, value:1 }, year:{ get:function(){ return this._year; }, set:function(){ if(newValue &gt; 2004){ if(newValue &gt; 2004){ this._year = newValue; this.edition += newValue -2004; } } } }});支持Object.defineProperties（） 方法的浏览器有：IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。 6.1.3读取属性的特性使用ECMAScript5的Object.getOwnPropertyDescriptor（）方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象。是访问器属性就有访问器属性的四个特性，是数据属性就有数据属性的四个特性。例如上面的book对象为例子：console.log(Object.getOwnPropertyDescriptor(book,&quot;_year&quot;));//返回：Object {value: 2004, writable: true, enumerable: true, configurable: true}console.log(Object.getOwnPropertyDescriptor(book,&quot;year&quot;));//返回：Object {enumerable: false, configurable: false} 很奇怪set和get特性要通过Object.getOwnPropertyDescriptor(book,&quot;year&quot;).get和~.set去得到里面set和get里面的函数。在JavaScript中，可以针对任何对象——包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor（）方法。支持这个方法的浏览器有：IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。6.2创建对象为了不写重复代码讨论了很多创建对象的方法。6.2.1工厂模式工厂模式是软件工程领域广为人知的设计模式，这种模式抽象了创建具体对象的过程（把创建对象的过程抽象简化）。因为在ECMAScript中没有类，开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节。例子：function createPerson(name,age,job){ var o = new Object(); //显式地创建对象 o.name = name; o.age = age; o.job = job; o.sayName = function(){ console.log(this.name) }; return 0; //有return语句，不知道有什么不好}var person = createPerson(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);工厂模式解决了创建多个相似对象要写重复代码的问题，但没有解决对象识别的问题（即怎样知道一个对象的类型，后面的由Person对象实例化的对象的类型就是Person类型而不是Object类型，解决了对象识别问题）。随着JavaScript的发展，又一个模式出现了。6.2.2构造函数模式前面几章说过，ECMAScript中的构造函数可以用来创建特定类型的对象（？说过？还不知道原来特定类型的对象可以自己定义，比如后面的Person对象）。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如，可以使用构造函数模式将前面的例子重写如下：function Person(name,age,job){ //构造函数首字母大写，普通函数首字母小写 this.name = name; this.age = age; this.job = job; this.sayName = function(){ console.log(this.name); };}var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);console.log(person1.name);在这个例子中，Person（）与createPerson（）的不同之处在于：没有显式地调用对象，直接将属性和方法赋给了this对象，没有return语句。✎注意：遵照其他OO语言的惯例，构造函数始终都以大写字母开头，非构造函数用小写字母开头。目的是为了区别于ECMAScript中的其他函数。要创建Person对象的实例，必须使用new操作符。以这种方式调用构造函数会经历以下4个步骤：（1）创建一个新对象；（2）将构造函数的作用域赋给新对象（环境变量对象就变成了这个对象，因此this就指向了这个对象）；（3）执行构造函数中的代码（为这个新对象添加属性）；（4）返回新对象。（对象实例诞生！）在前面例子的最后，person1和person2分别保存着Perso的一个不同的实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person（亲测console.log(person1.constructor)打印出了整个构造函数Person的源代码）。例子：console.log(person1.constructor == Person); //trueconsole.log(person1.constructor) //打印出上面构造函数Person的源代码对象的constructor属性最初是用来标识对象类型的。但是想要检测对象类型，还是instanceOf操作符更可靠一些。例子中创建的所有对象既是Object的实例，也是Person的实例，这一点可以通过instanceOf（）操作符验证：console.log(person1 instanceof Object); //trueconsole.log(person1 instanceof Person); //true创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式完胜工厂模式的地方。在这个例子中person1和person2之所以同时是Object的实例，是因为所有对象均继承自Object（详细内容稍后讨论）。✎：以这种方式定义的构造函数是定义在Global对象（在浏览器中是window对象）中的。（？？？又说所有对象继承自Object？？？）第八章会详细讨论浏览器对象模型（BOM）1将构造函数当作函数构造函数与其他函数的唯一区别，就在于调用他们的方式不同。但是归根到底构造函数还是函数。任何函数，只要通过new操作符调用，它就可以作为构造函数。而构造函数如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中的Person（）函数，可以用下面的任一方式调用，例子的重点是，体会用构造函数的方式调用和用普通方式调用两种方法，他们的作用域有什么不同：//当作构造函数调用var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);person1.sayName();//作为普通函数调用Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);window.sayName();//作为普通函数在另一个对象的作用域中调用var o = new Object();Person.call(o,&quot;Kristen&quot;,25,&quot;Nurse&quot;);o.sayName();第一种用法是构造函数的经典用法。第二种用普通的函数调用法：属性和方法都添加给了window对象（window.sayName（）正确的过程是，方法内的this总是指向Global对象，在浏览器中就变成了window对象）。第三种是重点：使用call（）在对象o的作用域中调用Person函数，类似在window对象中调用Person，调用后o也拥有 了所有属性和sayName（）方法。2构造函数的问题还是有人挑出了构造函数的问题。构造函数的问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName（）的方法，但那两个方法不是同一个Function的实例，因为他们在不同的对象环境中创建。从逻辑上讲，此时的构造函数可以这样定义：function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.sayName = new Function(&quot;console.log(this.name)&quot;); //与声明函数在逻辑上是等价的}从这个角度来看构造函数，就更容易明白每个Person实例都包含一个不同的Function实例（但他们的用途完全一样，就是显示name属性）（感觉学到了JavaScript不可言传的东西，这两个方法看起来一模一样，但是他们是两个不同的实例，要纠结他们是不同的实例的原因是，这样会产生不同的作用域链和标识符解析）。但创建Function新实例的机制仍然是相同的。因此，不同对象实例上的同名函数是不相等的，即person1的sayName（）不等于person2的sayName（）。以下代码可以证明这点：console.log(person1.sayName == person2.sayName); // false然而，创建两个完成同样任务的Function实例的确没有必要（导致产生不同的作用域链和标识符解析 ）；况且有this对象在，根本不用在执行代码前把函数绑定到每一个要实例的对象上，因此，可以像下面这种“等一下就要被作者推翻的方法”一样，把函数定义转移到构造函数外面来解决这个问题：function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.sayName sayName; //与声明函数在逻辑上是等价的}function sayName(){ console.log(this.name);}不知道这样会不会产生不同的作用域链，但是这样的好处是Function不用实例两次吧，可能是Function的作用域链不会产生两个，但是实例对象的作用域链还是会产生的。亲测console.log(person1.sayName == person2.sayName)返回的是true。证明他们用到的是一样的在全局环境下的sayName（）函数。但是这样又有一个问题，你在全局作用域定义的函数实际上只被某一个对象调用，如果对象需要很多个这样的方法，那不就要定义很多的全局函数吗。如此一来，我们这个自定义的引用类型就没有丝毫封装性可言了（太多函数暴漏在全局作用域中）。好在，我们可以用原型模式解决这个问题。6.2.3原型模式我们创建的每个函数都有一个prototype（原型）属性。这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的对象的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象（刚又说prototype是函数属性，现在又说是那个又构造函数实例出来的对象的原型对象？）使用原型对象的好处是可以让所有对象实例共享他们所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中（相当于对属性和方法设置一个默认值，在没有明确赋值的情况下，属性和方法的值就等于这个默认值）。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var person1 = new Person();person1.sayName();在此，我们将所有属性和sayName（）直接添加到Person的prototype属性中，构造函数变成了空函数。即便如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法，而且这些属性和方法是所有对象实例共享的。换句话说，person1和person2访问的都是同一组属性和同一个sayName（）函数。console.log(person1.sayName == person2.sayName)//true.要理解原型模式的工作原理，必须先理解ECMAcript中原型对象的性质。1.理解原型对象无论什么情况，只要创建了一个新函数，就会根据一组特定的规则（没有详讲）为该函数创建一个prototype属性（所有函数自带prototype属性）。这个属性指向函数的原型对象（前面又说prototype是原型对象现在又说是指向原型对象，大概因为prototype是个指针指向了原型对象，所有也可以说prototype属性是原型对象吧，有点函数名是函数的指针，所以也可以说这个函数是XX函数名，XX函数名是这个函数的意思）。在默认情况下，所有原型对象（暂且说是prototype，因为prototype指向原型对象）都会自动获得一个constructor（构造函数）属性（每个原型对象自带constructor属性），这个属性是一个指向prototype属性所在函数的指针。就拿前面的例子来说，Person.prototype.constructor指向Person这个函数，这个构造函数（也就是说一个函数里的prototype属性里的constructor属性是个指针，指向这个函数自己）。创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性，至于其他方法和属性，则都是从Object继承而来。当调用构造函数创建一个实例后（注意，这里开始讲的是实例，不是原来那个构造函数了），该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262管这个指针叫[[Prototype]]。虽然在JavaScript中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性protp；而在其他浏览器中，[[Prototype]]则是完全不可见的。要明确的一点是，这个连接是在实例与构造函数的原型对象之间，而不是在实例与构造函数之间（即[[Prototype]]指向构造函数的prototype而不是指向构造函数）。以前面的Person构造函数和Person.prototype创建实例的代码为例，图6-1展示了各个对象之间的关系：上图展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。在此Person.prototype指向了原型对象，而原型对象中的constructor属性又指向了Person.prototype。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例——person1和peron2都包含一个内部属性[[Prototype]]，该属性又指向了原型对象（书里这里写的指向Person.prototype，但应该是指向原型对象才对）；换句话说，他们与构造函数没有直接关系（实例与构造函数没有直接关系！？）。此外，要格外注意的是，虽然这两个实例都不包括属性和方法，但我们却可以调用person1.sayName（）。这是通过查找对象属性的过程来实现的。虽然没有标准的方式访问[[Prototype]]（书里说所有实现（即浏览器）都无法访问到[[Prototype]]，但前面已经说了有三个浏览器可以用proto访问，亲测也确实可以），但可以通过isPrototypeOf（）方法来确定对象之间知否存在这种关系。从本质上讲，如果[[Prototype]]指向调用isPrototypeOf（）方法的这个对象（Person.prototype），那么这个方法就返回true。例子：console.log(Person.prototype.isPrototypeOf(person1)); //trueconsole.log(Person.prototype.isPrototypeOf(person2)); //trueperson1，2的原型对象是Person.prototype，所以返回true，也说明person1，2的[[Prototype]]指向Person.prototype。记住[[Prototype]]是实例对象的内部属性，是一个指针。ECMAScript5还增加了一个新方法，叫Object.getPrototypeOf（），在所有支持的实现（浏览器）中，这个方法返回[[Prototype]]的值。例子：console.log(Object.getPrototypeOf(person1)==Person.prototype); //true，相等，可以证明person1的[[Prototype]]是指向Person.prototype的console.log(Object.getPrototypeOf(person1).name); //&quot;Nicholas&quot; Object.getPrototypeOf（）可以用来获取对象原型的属性第一行代码确定了Object.getPrototypeOf（）返回的对象实际就是这个对象的原型（又跟我自己在注释里写的见解不一样）。第二行代码取得对象原型中name属性的值，即“Nicholas”。使用Object.getPrototypeOf（）可以方便地取得一个对象的原型（prototype）。而这在利用原型实现继承的情况下是非常重要的。支持这个方法的浏览器有： IE9+、Firefox 3.5+、Safari 5+、Opera 12+和Chrome。知道了构造函数有prototype属性之后，我们可以知道，当代码读取某个对象的某个属性时，都会执行一次搜索，目的是找到具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性值；如果没有找到，就继续搜索指针（[[Prototype]]）指向的原型对象（prototype），在原型对象中查找具有给定名字的属性，如果在原型对象中找到这个属性，就返回这个属性的值。所以我们在调用实例对象的属性和方法时会执行两次搜索。这正是多个对象实例共享原型对象所保存的属性和方法的基本原理。✎：前面提到过，原型对象最初只包含一个constructor属性，这个属性也是共享的，可以通过对象实例访问。（亲测访问这个属性会返回构造函数的源代码，之前亲测过了？）虽然我们可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加一个与原型对象中存在的同名属性，则我们就在实例中创建该属性。该属性会屏蔽掉原型中那个属性。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var person1 = new Person();var person2 = new Person();person1.name=&quot;Mike&quot;person1.sayName(); //“Mike” ←来自实例person1.sayName(); //&quot;Niicholas&quot; ←来自原型当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性（书中对“屏蔽”两个字黑体加粗，但是我觉得屏蔽的原理估计又有一大篇文章要讲）。如果把实例中的属性设置为null，也只会在实例中设置这个属性，无法恢复其指向原型的连接。要恢复其指向原型的连接，方法就是使用delete操作符完全删除实例属性，从而我们就可以重新访问原型中的属性。例子：person1.name = &quot;Mike&quot;;person1.name = null;person1.sayName(); //nulldelete person1.name person1.sayName(); //&quot;Nicholas&quot;使用hasOwnProperty（）（注意是Property不是prototype了，property是属性的意思）方法可以检测一个属性是存在实例中，还是原型中。这个方法（不要忘了这个方法继承自Object）在检测的属性是存在实例中的时候，返回true。例子：var person1 = new Person();person1.name=&quot;Mike&quot;delete person1.name;console.log(person1.hasOwnProperty(&quot;name&quot;)); //false，把第三行注释掉就变成true通过hasOwnProperty（）方法，我们访问属性的时候到底访问的是原型对象中的属性还是实例重新定义的属性就一清二楚了。（做了有趣的实验，把实例中的属性保存为跟原型对象属性一样的值，用hasOwnProperty（）方法返回的是true。可不可以说明他们存放的空间不一样？）person1.name=&quot;Nicholas&quot; 与原型对象中的属性值相同console.log(person1.hasOwnProperty(&quot;name&quot;)); //true✎：ECMAScript5的Object.getOwnPropertyDescriptor（）方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用Object.getOwnPropertyDescroptor（）方法。原来前面已经讲过这个方法竟然忘了。不知道什么是属性的描述符，测试了一次发现返回的是对象的属性的四个特性：console.log(Object.getOwnPropertyDescriptor(person1,&quot;name&quot;));//Object {value: &quot;Nicholas&quot;, writable: true, enumerable: true, configurable: true}注意上面的那句话啊！！！每个词都是关键啊！上面说要在原型对象上调用，不是直接用构造函数名调用啊，用构造函数名调用很奇怪，console.log(Object.getOwnPropertyDescriptor(person1,&quot;name&quot;));返回的描述符中的value是“Person”，第二个参数改成“job”或“age”返回的却是undefined。用console.log(Object.getOwnPropertyDescriptor(Person.prototype,&quot;name&quot;));就能返回value是“Nicholas”的描述符。例子：console.log(Object.getOwnPropertyDescriptor(Person,&quot;job&quot;)); //undefinedconsole.log(Object.getOwnPropertyDescriptor(Person,&quot;name&quot;)); //Object {value: &quot;Person&quot;, writable: false, enumerable: false, configurable: true}console.log(Object.getOwnPropertyDescriptor(Person.prototype,&quot;name&quot;));//Object {value: &quot;Nicholas&quot;, writable: true, enumerable: true, configurable: true}后来又继续测试console.log(Person.name);返回的也是“Person”，难道name是每个函数都有的属性返回函数的函数名？2.原型与 in 操作符in操作符的使用有两种方式，一种是单独使用和在for - in循环中使用。在单独使用时，in操作符用于判断某一属性是否在对象中，无论是在实例中还是原型中，只要有就返回true。例子：console.log(&quot;name&quot; in person1) //true 无论name是在实例中还是原型中console.log(&quot;name&quot; in Person) //顺便做了个实验，name属性确实在Person构造函数中console.log(&quot;name&quot; in Person) //false这让我想到一个问题，Person已经有一个name属性的值是“Person”，我们又通过原型对象给原型对象中添加了name属性的值是Nicholas，那值为“Person”的name属性又是来自哪里？？做了个实验，创建一个叫zoo的空函数：function zoo(){}console.log(&quot;name&quot; in zoo); //truein操作符判断后也是返回true，这个name不在原型对象中，也不在实例中，仍然返回true，这个name到底是放在哪？有意思。又做了好多实验，发现用函数声明，函数表达式创建出来的函数都有name属性，但是把这个自定义的函数当构造函数用，实例出来的对象就没有这个name属性。所以还是只有函数有咯。用Obect（）构造函数实例的对象也没有name属性。利用 in操作符，结合hasOwnProperty（）方法，我们可以创建一个函数来判断一个属性值到底是来自实例还是原型：function hasPrototypeProperty(object,name){ return !object.hasOwnProperty(name)&amp;&amp;(name in object);}这个是书里定义的函数，我觉得有点绕。这个是检测属性是原型属性返回true。是实例中的属性就返回假，跟我想的相反。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var person = new Person();console.log(hasPrototypePerty(person,&quot;name&quot;)) //trueperson.name = &quot;Greg&quot;;console.log(hasPrototypePerty(person,&quot;name&quot;)) //falsefor - in循环的作用，返回的是所有能通过对象访问的，可枚举的（enumerated）属性，其中既包括实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（[[Enumerable]]：false）的实例属性也会在for - in属性中返回（意思是：比如toString（）方法是Object的原生方法，一般这类方法都是不可枚举的，如果你在实例对象中重写了toString（），那toString（）就变成了可枚举的，会在for - in循环中被列出来）。因为根据规定，所有开发人员定义的属性都是可枚举的。但是IE8及更早版本会有BUG，即屏蔽不可枚举属性的实例属性也不会出现在for - in循环中。例如：var o = { toString : function(){ //重写toString（）方法 return &quot;My Object&quot;; }};for(var prop in o){ if(prop == &quot;toString&quot;){ console.log(&quot;Found String&quot;); //IE8中不会显示 }}上面的例子，本来我已经改写了toString（）了，应该是可以被for - in循环枚举出来的，但是在IE8及更早版本并不会被枚举出来。这个BUG会影响默认不可枚举的所有属性和方法，包括：hasOwnProperty（）、propertyIsEnumerable（）、toLocalString（）、toString（）和valueOf（）。ECMAScript5把constructor和property属性的[[Enumerable]]特性设置为false，但并不是所有浏览器都乖乖听ECMAScript的。要想获取对象上所有可枚举的实例属性（实例属性！原型对象中的属性不会被列举出来），可以使用ECMAScript5的Object.keys（）方法，这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var keys = Object.keys(Person.prototype);console.log(keys) //[&quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]var peron1 = new Person();person1.name = &quot;Mike&quot;;console.log(Object.keys(person1)) //[&quot;name&quot;]有什么实例，数组里才有什么属性，property里定义的属性是Person.prototype对象的实例属性，不是person1的实例属性，person1的实例属性只有一个。如果想要得到所有实例属性，无论是否可枚举，可以使用Object.getOwnPropertyNames（）方法。例子：console.log(Object.getOwnPropertyNames(Person.prototype)); //[&quot;constructor&quot;, &quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]person1.age=28;Object.defineProperty(person1,&quot;name&quot;,{ writable:false, value:&quot;Mike&quot;, enumerable:false}); console.log(Object.keys(person1)); // [&quot;age&quot;]console.log(Object.getOwnPropertyNames(person1)); // [&quot;name&quot;, &quot;age&quot;]还记得前面说的ECMAScript5把constructor（构造函数）属性也设置为不可枚举吗？看来这个浏览器遵循ECMAScript5的规定。Object.keys（）和Object.getOwnPropertyNames（）都可以用来替代for - in循环。支持这两个方法的浏览器有：IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。记住他们返回的都是实例属性，不包括原型对象中的属性。3.更简单的原型语法作者介绍给我们，前面的每添加一个原型属性就要敲一遍Person.prototype的方法太傻了，为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。例子：function Person(){}Person.prototype = { constructor : Person, name : &quot;Nicholas&quot;, age :29, job : &quot;Software Engineer&quot;, sayName : function(){ console.log(this.name); }}理清除，Person.property是指针指向原型对象，所以用对象字面量法给原型对象添加属性和方法是没毛病的。但是这种写法本质上重写了Person.prototype对象，而每个prototype属性都自带有constructor属性，如果在重写中没有加入constructor属性，为constructor重新赋值，则constructor属性将从原型对象中消失。说消失是不准确的，这时候原型对象的constructor属性不再指向Person构造函数，而是指向Object构造函数。但是Person对象的实例仍然是Person的实例。下面的例子假设重写时没有加入constructor属性：console.log(friend instanceof Object); //trueconsole.log(friend instanceof Person); //trueconsole.log(friend.constructor == Person); //falseconsole.log(friend.constructor == Object); //true还有一点要注意的是，重写之后的constructor属性，它的[[Enumerable]]特性会被设置为true（当然是在ECMAScript5已经规定了constructor属性的[[Enumerable]]特性 默认为false且浏览器听它的的情况下）。如果想让它重新变为false，可以人工用Object.defineProperty（）方法设置。4.原型的动态性由于在原型中查找值是一次搜索，所以即使先创建实例后修改原型也是可以的。例子：var friend = new Person();Person.prototype.sayHi = function(){ console.log(&quot;Hi&quot;);};friend.sayHi(); //&quot;Hi&quot; （正常运行）可以看到我们先实例化了Person对象为friend，再修改Person的原型对象。firend仍然能访问到sayHi（）方法。其原因可以归结为实例与原型之间的松散连接关系。因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的sayHi属性并返回保存在那里的函数。尽管可以随时为原型添加属性和方法，但如果是重写整个原型对象，情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototyoe]]指针，而把原型重写为另外一个对象就等于切断了构造函数与最初原型之间的联系（从书中关系图来看，最初原型（旧原型对象）仍指向构造函数，但是构造函数指向了新的原型对象，所以也不是完全切断吧）。作者写到这里突然要我们记住：实例中的指针仅指向原型，不指向构造函数（实例与构造函数之间没有联系）例子：function Person(){}var friend = new Person();Person.prototype = { constructor : Person, name : &quot;Nicholas&quot;, age :29, job : &quot;Software Engineer&quot;, sayName : function(){ console.log(this.name); }};friend.sayName(); //报错： friend.sayName is not a function在这个例子中，我们先创建了一个Person对象，先实例化出一个friend，再重写了原型对象。然后在调用friend.sayName（）的时候就出现了错误。因为friend指向的原型是旧原型，不包含以该名字命名的属性。图6-3展示了这个过程。可以看到重写原型对象会切断现有原型与任何之前已经存在的对象实例之间的关系；之前已经存在的对象实例 仍然引用的是最初的原型。也就是说用重写原型的方式给原型对象添加属性的方法要在重写的那段代码之后再实例化对象，如果是用Person.prototype.属性 = XX这种方法则不存在这种问题。5.原生对象的原型这节讲的是原生对象的原型，什么是原生对象？就是原生的引用类型（Array，Object，String and so on）所有原生引用类型都在其构造函数的原型上（注意原型是谁的属性（prototype是个属性，这个属性是个指针），是构造函数的属性）定义了方法。例如Array类型的sort（）方法就是定义在Array.prototype中的。String类型的substring（）方法就是定义在String.prototype中的。证明例子：console.log(typeof Array.prototype.sort); //functionconsole.log(typeof String.prototype.substring); //functionconsole.log(typeof Array.sort); //undefinedtypeof Array.sort竟然是undefined是令我惊讶的，我以为后台会自动规定sort是Array的方法（所以以前的每次array.sort( )的调用都是在调用Array对象的原型对象中的方法，向Array.prototype致敬！）通过原生对象的原型，不仅可以取得所有默认方法的引用，而且可以定义新方法，可以像修改自定义对象的原型一样修改原生对象的原型，在里面添加新的方法。亲测可以改写原本已经定义的方法，比如toString（）这些。但是不要这样做。书中给出了在原生对象的原型中添加方法的例子，但是他建议不哟这样做，避免命名冲突。就不举例了。6.原型对象的问题原型对象也是有问题的（不能说BUG，合情合理）。原型对象的好处是可以共享属性，但最大的问题也处在了共享的问题上，属性的值是基本类型值还好，如果是包含引用类型的属性，就会出问题了：function Car(){}Car.prototype={ constructor:Car, friends:[&quot;Shelby&quot;,&quot;Court&quot;]}var car1 = new Car();var car2 = new Car();car1.friends.push(&quot;Van&quot;);console.log(car1.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]console.log(car2.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]本来只是像给实例对象car1的friends属性中的数组加入“Van”而已，但是最后car2也有了。因为car1并没有自己重写friends属性，而是直接在默认有的属性值中添加数据，而这个数组是保存在Person.prototype中的，所以刚刚提到的修改也会通过person2.friends反映出来。所以很少有人单独使用原型模式。6.2.4组合使用构造函数模式和原型模式创建自定义类型的最常见方式，是组合使用构造函数模式和原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。这样，每个实例都有自己的一份实例属性的副本（不懂这个实例属性的副本是什么意思），但同时共享对方法的引用，最大限度地节省了内存。重写前面的代码的例子：function Person(name,age,job){ //通过对构造函数传参给独特的属性赋值 this.name = name; this.age = age; this.job = job; this.friends = [&quot;Shelby&quot;,&quot;Court&quot;]; //引用类型写在构造函数中}Person.prototype = { constructor:Person, //别忘了重写constructor属性 sayName:function(){ //一样的方法可以共用 console.log(this.name); }}var person3 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);var person4 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);person3.friends.push(&quot;Van&quot;);console.log(person3.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]console.log(person4.friends); //[&quot;Shelby&quot;, &quot;Court&quot;]console.log(person3.friends == person4.friends); //falseconsole.log(person3.sayName == person4.sayName); //true这种构造函数与原型混成的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。后面几节讲的都是定义引用类型的几种方法，既然说上面的是最好用的，后面的就不写了。6.2.5动态原型模式为看不惯上面的写法的有其他OO语言开发人员使用的方法。6.2.6寄生构造函数模式作者不推荐这种方法，因为这个方法返回的对象与构造函数或者与构造函数的原型属性之间没有关系。也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。也就是说假设用创建了一个Person构造函数，用这个构造函数实例出来的对象并不属于Person，而是属于Object。6.2.7稳妥构造函数模式这个方法也是创建的对象与构造函数之间没有什么关系。6.3继承许多OO语言都支持两个继承方式：接口继承和实现继承。接口继承只继承方法签名。而实现继承则继承实际的方法。如前面章节讲过的，由于函数没有签名（函数没有“函数名”只是一个指针，所以叫没有签名？），在ECMAScript中无法实现接口继承。实现继承主要是依靠原型链实现的。6.3.1原型链ECMAScript中描述了原型链的概念。并将原型链作为实现继承的主要方法。其基本思想是：利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型链实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针（constructor），而实例都包含一个指向原型对象的内部指针（[[Prototype]]）。那么，如果我们让原型对象等于另一个类型的实例，会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针。相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条，这就是所谓原型链的基本概念。实现原型链的基本模式如下：function SuperType(){ this.property = true; //定义的变量名有点复杂，看得有点晕，其实就是一个值为true的变量}SuperType.prototype.getSuperValue = function(){ return this.property;};function SubType(){ this.subproperty = false; //另一个false的变量}//继承了SuperTypeSubType.prototype = new SuperType(); //让一个构造函数A的原型等于另一个构造函数B的实例，这个实例又有一个指向B的原型的指针SubType.prototype.getSubValue = function(){ //这里看得有点懵，其实就是给子对象的原型定义了一个方法，跟上面的代码无关，也没用上 return this.subproperty;}var instance = new SubType(); //创建子对象的实例console.log(instance.getSuperValue()); //true 发现子对象的实例可以调用父对象的方法，返回保存在父对象的变量以上代码定义了两个类型：SuperType和SubType。每个类型各有一个属性一个方法。他们的区别是SubType继承了SuperType。继承的步骤是：通过创建SuperType的实例（new SupperType），并将该实例赋给了SubType.prototype实现。实现的本质是重写原型对象，给原型对象赋值为一个新类型的实例（所以SubType.prototype里的constructor属性也改变了，不是没有了，变成了新类型实例里指向父构造函数的constructor属性，此时constructor为SuperType）。换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了。在确定了继承关系后，我们又不知道有什么卵用地给SubType.prototype添加了一个方法。这样就在继承了SuperType的实例的属性和方法后，又有了自己的方法。这个例子中的实例以及构造函数和原型之间的关系如图：在代码中，我们没有使用SubType默认提供的原型，而是把它重写成了一个新原型，这个新原型就是SuperType的实例。于是，新原型不仅具有作为一个SuperType的实例所拥有的全部属性和方法，而且内部还有一个指针（[[Prototype]]，通了，一开始觉得叫[[Prototype]] 不恰当，想明白了根本不会！因为这个[[Prototype]]属性本来就是SuperType实例中有的），指向SuperType的原型。结果就是这样：instance的[[Prototype]]指向SubType的原型，SubType的原型里的[[Prototype]]又指向SuperType的原型。注意：getSuperValue（）方法仍然还在SuperType.prototype里，SubType.prototype里没有，但property则在SubType.prototype中。书中的解释是：因为property是一个实例属性，而getSuperValue（）是一个原型方法（实例属性会跟着继承在子对象中，原型方法仍然留在父对象的原型中）。解释：既然SubType.prototype现在是SuperType的实例，那么property当然位于实例中了，而getSuperValue（）是在原型中，不在实例中。此外，要注意instance.constructor现在指向的是SuperType，这是因为原来Subtype的原型指向了另一个对象SuperType 的实例，这个实例指向了对象SuperType的原型，SuperType的原型里的constructor属性就是指向SuperType。（书里这样写，可是为什么instance会有constructor属性？constructor不是原型对象才有吗？亲测每个实例都有这个属性，返回这个实例的构造函数。字符串类型的constructor返回到是String（）构造函数）通过原型链的介绍，原型搜索机制又要重新扩展：当以读取模式访问一个实例属性时，首先会在实例中搜索该属性，如果没有找到该属性，就继续搜索实例的原型，在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用instance.getSuperValue（）会经历三个搜索步骤：1）搜索实例；2）搜索SubType.prototype；3）搜索SuperType.prototype，最后一步找到这个方法。搜索过程总是这样一环一环地走到原型链末端才停下来。1.别忘记默认的原型事实上，前面例子中展示的原型链少了一环。我们知道，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是Object的实例（new Object( )），因此默认原型都会包含一个内部指针，指向Object.prototype（又不说这个指针的名字）。这也正是所有自定义类型都会继承toString（）等默认方法的原因（上面讲原型对象的时候说过，原生引用类型的方法都是定义在prototype上的）。所以所有函数的toString（）等默认方法不是在他们自己的prototype属性中，而是通过指针，一层层地找到那些放在Object.prototype里的原型方法的，这样就减少了还能多内存占用吧。所以上面例子展示的原型链中还应包括另外一个继承层次，如图才是真正完整的原型链：2.确定原型和实例的关系可以通过两种方式来确定原型和实例之间的管理，第一种方式使用instanceOf操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。例子：console.log(instance instanceof Object) //trueconsole.log(instance instanceof SubType) //trueconsole.log(instance instanceof SuperType) //true由于原型链的关系，我们可以说instance是Object、SuperType、SubType中任何一个类型的实例。因此三个构造函数的结果都返回true。第二种方式是使用isPrototypeOf（）方法，同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf（）也会返回true:console.log(Object.prototype.isPrototypeOf(instance)); //trueconsole.log(SubType.prototype.isPrototypeOf(instance)); //trueconsole.log(SuperType.prototype.isPrototypeOf(instance)); //true3.谨慎地定义方法子类型有时候会需要覆盖超类型中的某个方法，或者添加超类型中不存在的某个方法。但无论如何，给原型添加方法的代码一定要放在替换原型的语句之后。例子：function SuperType(){ this.property = true;}SuperType.prototype.getSuperValue = function(){ return this.property;};function SubType(){ this.subproperty = false;}//继承了SuperTypeSubType.prototype = new SuperType(); //无论是覆盖还是添加，都要放在替换原型的语句之后//添加新方法SubType.prototype.getSubValue = function(){ return this.subproperty;}//重写超类型中的方法SubType.prototype.getSuperValue = function(){ return false;}var instance = new SubType();console.log(instance.getSuperValue()); //false在上面代码中，加粗部分是两个方法的定义。第一个方法getSubValue（）被添加到了SubType中，第二个方法getSuperValue（）是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的那个方法。换句花说，当通过SubType的实例（instance）调用getSuperValue（）时，调用的是这个重新定义的方法；但通过SuperType的实例调用getSuperValue（）时，还会继续调用原来的那个方法。这里要格外注意的是，必须在用SuperType的实例替换原型之后，再定义这两个方法。从前面的原型链关系图我们知道SuperType的实例调用的是SuperType的原型里的getSuperValue（），SubType的实例一开始是用指针调用SuperType的原型里的getSuperValue（），后来就通过重写在自己的SubType里添加了自己的getSuperValue（）。还有一点要注意到是，在通过原型链实现了继承之后，不能使用对象字面量法重写原型方法，因为这样就重写了原型链，继承就断了。例子：function SuperType(){ this.property = true;}SuperType.prototype.getSuperValue = function(){ return this.property;};function SubType(){ this.subproperty = false;}//继承了SuperTypeSubType.prototype = new SuperType();//使用字面量添加新方法，会导致上一行代码失效SubType.prototype = { getSubValue : function(){ return this.subproperty; }. someOtherMethod : function(){ return this.false; }}var instance = new SubType();console.log(instance.getSuperValue()); //error! 继承关系已断以上代码展示了刚把SuperType的实例赋给Subtype的原型，下面的代码马上就把SubType的原型给重写了，相当于上面的那行赋值被替换了，无效了。相当于现在的原型里包含的是Object的实例（所有函数的默认原型都是Object的实例），而不是SuperType的实例。原型链被切断，SubType和SuperType之间已经没有关系了。4.原型链的问题通过原型链的继承还是存在问题的，就是包含引用类型的那个问题。包含引用类型值的原型属性会被所有实例共享；当其中一个实例修改了原型属性中的引用类型值，整个引用类型值就被修改了。例子：function SuperType(){ this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];}function SubType(){}SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var instance2 = new SubType();console.log(instance2.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]还是引用类型值共享会导致修改类型值会直接修改原型属性里的值的问题。原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数，实际上，应该说是没有办法在不影响所有对象的情况下，给超类型的构造函数传递参数（意思是说不能在SubType.prototype = new SuperType() 给构造函数赋值吗？）。由于前面的两个问题，很少会单独使用原型链。6.3.2借用构造函数为了解决前面的问题，开始人员开始使用一种叫借用构造函数（constructor stealing）的技术（有时候也叫做伪造对象或经典继承）。这种技术的思想相当简单：在子类型构造函数的内部调用超类型的构造函数。别忘了，函数只不过是在特定环境中执行代码的对象。因此，通过使用apply（）和call（）方法也可以在（将来）新创建的对象上执行构造函数。例子：function SuperType(name){ //另一个好处是可以给构造函数赋值 this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; this.name = name;}function SubType(){ //继承了SuperType ，同时传递了参数 SuperType.call(this,&quot;Nicholas&quot;); //不知道这个this有什么用，this不是指向window吗，可能“将来”实例化变成对象之后就指向SubType对象了 this.age = 29}var instance1 = new SubType(); //前面说的将来就是指这个时候，调用了内部的SuperType构造函数instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var instance2 = new SubType();console.log(instance2.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]console.log(instance1.name) //&quot;Nicholas&quot;console.log(instance1.age) //29代码中加粗那行代码“借调”了超类型的构造函数。通过使用call()方法，我们实际上是在（未来将要）新创建的SubType实例的环境（this指向的是SubType实例的环境 ）下调用SuperType构造函数（不一定有new才能调用构造函数）。这样一来，就会在新SubType对象上执行SuperType（）函数中定义的所有对象初始化代码。结果SubType的每个实例都会有自己的colors属性的副本了。但是这种方式并没有使用到SubType.prototype哦。1.传递参数传递参数的例子被我写在上面一起讲了。代码中SuperType接收一个参数name，并在函数内直接给name属性赋值。在SubType构造函数内部调用SuperType构造函数时，实际上是为SubType的实例设置了name的默认属性，虽然这个默认属性不在prototype上。为了确保SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。2.借用构造函数的问题如果只使用借用构造函数，那么也将出现构造函数模式出现的问题——方法都在构造函数中，每实例一个对象就重新复制了一份函数中的方法，影响性能。因此函数的复用就无从谈起。而且，在超类型中定义的方法，对子类型而言是不可见的，结果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数技术也很少使用。6.3.3组合继承组合继承（combination inheritance）有时候也叫伪经典继承。指的是将原型链和借用构造函数的技术组合到一块。背后的思路是：是哦那个原型链实现对原型属性和方法的继承、而通过借用构造函数来实现对实例的继承。例子：function SuperType(name){ this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; //属性写进构造函数里 this.name = name;}SuperType.prototype.sayName = function(){ console.log(this.name);};function SubType(name){ //继承属性 SuperType.call(this,name); ] this.age = age;}//继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType; //如果没有这一步，SubType的原型里concerned属性就是指向SuperTypeSubType.prototype.sayAge = function(){ //方法写进原型里 console.log(this.age);}var instance1 = new SubType(&quot;Nicholas&quot;,29); instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]instance1.sayName(){}; //&quot;Nicholas&quot;instance1.sayAge(){}; //29var instance2 = new SubType(&quot;Greg&quot;,27);console.log(instance2.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]instance2.sayName(); //&quot;Greg&quot;instance2.sayAge(); //27在例子中，SuperType构造函数定义了两个属性：name和colors。SuperType的原型定义了一个方法sayName（）。SubType构造函数在调用SuperType构造函数时传入了name参数，紧接着又定义了自己的属性age。然后，将SuperType的实例赋值给SubType的原型，然后又在该新原型上定义了方法sayAge（）。这样一来，就可以让两个不同的SubType实例既分别拥有自己的属性——包括colors属性，又可以使用相同的方法了。组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中 n继承模式。而且instanceOf和isPrototypeOf（）也能够用于识别基于组合继承创建的对象。6.3.4原型式继承一个有缺陷的继承方式，但是ECMAScript5为这个方式创建了一个create（）方法，跟原型式继承原理相似。这种方法没有使用严格意义上的构造函数。道格拉斯·克罗克福德（提出者）的想法是：借助原型可以基于已有的对象创建新对象。同时还不必因此创建自定义类型（意思就是那个子构造函数（比如那个SubType构造函数）都不用创建了，下面那个方法的返回值直接赋给一个变量，那个变量就是实例了）。下面就是那个函数：function object(o){ function F(){} F.prototype = o; //这个构造函数的原型等于传进来的那个对象，所以不用创建自定义类型，这个F就相当于那个自定义类型了 return new F(); //返回一个构造函数的实例，赋给一个变量就相当于实现了继承}在Object（）函数内部，先创建了一个临时性的构造函数（F），然后将闯入的对象作为这个构造函数的原型（ F.prototype = o ），最后返回这个临时类型的新实例。从本质上讲，object（）对传入其中的对象执行了一次浅复制。看下面例子：var person = { name:&quot;Nicholas&quot;, friends:[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]};var anotherPerson = object(person); //调用object()，传进去的person相当于超类型anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;); //注意这里给friends数组引用类型值推入一个数据的只是anotherPersonvar yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;); //注意这里第二个子实例yetAnotherPerson也给数组推入一个Barbieconsole.log(person.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;, &quot;Rob&quot;, &quot;Barbie&quot;] //超类型里的数组里也多了Rob和Barbie✎：反正直接在对象字面量里定义值为引用类型值的属性被改写就会GG（一开始打这句话的时候是写“直接在原型里定义值为引用类型值的属性就GG”，想想不对，上面的person是在自己那里定义的引用类型值属性不是在原型里啊。object（）方法返回的是F（）的实例，是F的原型（F.prototype）复制了person的属性哦，所以anotherPerson和yetAnotherPerson对象改的应该是F.prototype里的数组吧，为什么person也会受影响呢？想想，可能是：person对象作为函数参数传入了函数object（），虽然JavaScript是按值传递的，但person是对象，F.prototype = o 相当于F.prototype成了对象person的指针（相当于复制了对象的指针），所以看起来改的是F.prototype，但其实F.prototype里没有这个属性，本质上改的应该是person对象里的属性，况且F在object（）函数执行完后已经被销毁，但anotherPerson和yetAnotherPerson 保存了F的实例，也就保存了F的prototype原型对象）。如果有一个超类型的对象在的话，我们就可以使用object( )函数，把超类型作为参数传入，然后函数就会返回一个新对象。在这个例子中，作为超类型的对象是person对象（注意对象首字母是小写，它的作用不是作为构造函数），把person放入object（）传入函数，返回一个新对象，这个新对象将person作为原型（其实应该说 F 将person作为原型），所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。这意味着person.friend不仅属于person所有，而且也会被anotherPerson和yetAnotherPerson共享。实际上，这就相当于又创建了person对象的两个副本（说副本还是有门道的，是副本不是指针，如果是指针的话，anotherPerson和yetAnotherPerson 修改name属性的话，person也会被改，但亲测并不会，虽然F.prototype是person的指针，但new F（），F的实例不是指针，算了解释不下去了，以前是SubType.portotype = new SuperType（）好歹是别人的实例就一定不是指针，但 F.prototype = o 是指针无疑啊，为什么anotherPerson和yetAnotherPerson 会有自己的name属性呢？）。ECMAScript5通过新Object.create（）方法规范了原型式继承。这个方法接收两个参数：一个用作新对象的父对象和一个为新对象定义额外的属性的对象（可选，意思就是用对象字面量的方法定义新对象的额外属性）。在传入一个参数的情况下，Object.create（）与object（）方法的行为相同。var person = { name:&quot;Nicholas&quot;, friends:[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]};var anotherPerson = Object.create(person);anotherPerson.name = &quot;Greg&quot;; //后面的代码会教不用这样写anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);console.log(person.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;, &quot;Rob&quot;, &quot;Barbie&quot;] 仍然存在的问题Object.create（）的第二个参数与Object.defineProperties（）方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性：var anotherPerson = Object.create(person,{ name:{ value:&quot;Greg&quot; //好麻烦啊这样写 }})console.log(anotherPerson.name) //&quot;Greg&quot;果然用上面的参数格式，其他三个特性不写，全部会由默认true变成默认false:console.log(Object.getOwnPropertyDescriptor(anotherPerson,&quot;name&quot;))//Object {value: &quot;Greg&quot;, writable: false, enumerable: false, configurable: false}console.log(Object.getOwnPropertyDescriptor(yetAnotherPerson,&quot;name&quot;))//Object {value: &quot;Linda&quot;, writable: true, enumerable: true, configurable: true}默认的自定义对象的三个特性都是true，如果用Object.defineProperties（）的格式修改描述符的定义，没有列出来，则默认会被后台修改为false。6.3.5寄生式继承寄生式（parasitic）继承也是克罗克福德提出来的，与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工程模式类似，既创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"高程","slug":"高程","permalink":"https://millionqw.github.io/tags/高程/"}]},{"title":"《Javascript》高级程序设计 第五章 详细解释引用类型（下）","date":"2017-07-10T14:02:24.000Z","path":"2017/07/10/《Javascript高级程序设计》-第五章-详细解释引用类型（下）/","text":"我的文章会在我的Blog同步更新，Blog刚搭了几天，用于记录我的学习过程：Million 5.5Function类型作者说ECMAScript中最有意思的是函数，有意思的根源在于，函数实际上是对象。每个函数都是Function类型的实例。与其他引用类型一样，函数类型也有属性和方法。由于函数是对象，因此函数名实际上只是一个指向函数对象的指针，不会与某个函数绑定。 函数通常是使用函数声明语法定义的，如下面的例子所示：123function sum(num1,num2)&#123; return num1+num2;&#125; 这与下面使用函数表达式定义函数的方法几乎相差无几:123var sum = function(num1,num2)&#123; return num1+num2;&#125;; // ← 注意最后的分号，声明完变量必加的分号 第二段代码定义了变量sum并将其初始化为一个函数（注意这句话的顺序，把一个定义好的变量初始化为一个函数）。我们可以发现用函数表达式创建的函数，function关键字后面没有函数名。因为没有必要。通过变量sum即可以引用到函数（注意，你不能说变量sum是函数名）。另外，注意函数末尾有一个分号，因为说到底sum还是个变量，只是变量的值是一个函数！最后一种定义函数的方式，因为函数是对象，所以可以使用Function构造函数。Function可以接收任意个数量的参数，最后一个参数始终被当作函数体，前面的都是函数的参数。例子：1var sum = new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;num3&quot;,&quot;return num1+num2&quot;); //不推荐 从技术的角度讲，这是一个函数表达式，但是不推荐使用。因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript，第二次是解析传入构造函数中的字符串），从而影响性能。不过这种语法有利于理解“函数是对象，函数名是指针”这个概念。由于函数名仅仅是指针（好唏嘘，函数名以为用它的名字创建的函数就是它的，结果，它只是一个指针。）一个对象可以有很多指针，所以一个函数也可以有多个名字。例子：123456789function sum(num1,num2)&#123; return num1+num2;&#125;var anotherSum = sum;alert(anotherSum(10,10)); //20sum = null;alert(anotherSum(10,10)); //20 即使把sum给设置为null，但因为这个指针已经复制了一份给anotherSum，所以这个函数对象还是可以被引用到，不会因为sum不见了，函数就跟着没了。（亲测PHP似乎就不能用这种方法“转换函数名”）注意，使用不带圆括号的函数名是访问函数指针，使用带括号的函数名就表示要调用这个函数。 5.5.1没有重载把函数名想象为指针，就能理解为什么ECMAScript没有重载。例子：12345678function sum(num1,num2)&#123; return num1+100;&#125;function sum(num1)&#123; return num1+200;&#125;console.log(sum(100,100)); // 300 显然，例子中声明了两个同名函数，而结果是后面的函数覆盖了前面的函数。因为在创建第二个函数时，实际上覆盖了引用第一个函数的变量addSomeNumber。 5.5.2函数声明与函数表达式实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明并使其在执行任何代码之前可用（可以访问）；至于函数表达式，就必须等到解析器执行到它所在的代码行，才会真正被解释执行。（所以函数声明有函数声明提升（function declaration hoisting），函数表达式没有）函数表达式不能写在要调用这个函数的代码之后。函数声明提升：Javascript引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以即使声明函数的代码在调用它的代码后面。JavaScript也能把函数声明提升到顶部。除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。再无其他差别。 ✎ 有人觉得不妨在使用函数表达式的同时给函数命名，like this : var sum = function sum(){ }但这种语法在 Safari 中会出错。 5.5.3作为值的函数因为ECMAScript中的函数名本身就是变量，所以函数也可以作为一个值来使用。也就是说，不仅可以像传递参数一样把一个函数当作参数传递给一个函数，而且可以将一个函数作为另一个函数的结果返回。例子：123function callSomeFunction(someFunc,someArgument)&#123; return someFunc(someArgument)&#125; 这个函数接收两个参数，一个是函数，一个是普通参数，这个普通参数给传进来的函数使用。然后，就可以像下面这样传递函数了：123456789101112function add10(num)&#123; return num+10;&#125;var result1 = callSomeFunction(add10,10); //注意函数作为参数传递是不带括号的，带括号的函数会执行，参数就变成这个函数执行完成返回的那个值了alert(result1); //20 function getGreeting(name)&#123; return &quot;Hello &quot; + name;&#125;var result2 = callSomeFunction(getGreeting,&quot;Nicholas&quot;);alert(result2); // Hello Nicholas 注意，要访问函数的指针而不执行函数的话，必须去掉函数名后面的括号。因此上面例子给callSomeFunction（）传递的是add10 和 getGreeting。而不是执行它们之后的结果。可以从一个函数中返回一个函数，是一项极为有用的技术。例如，假设有一个对象数组（由对象组成的数组），我们想要根据对象中的某一个属性对数组进行排序，而传递给sort（）方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来告诉sort（）按照哪个对象属性排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据属性名来创建一个匿名比较函数。下面就是这个函数的定义：1234567891011121314function creatComparisonFunction(propertyName)&#123; return function(obj1,obj2)&#123; var val1 = obj1[propertyName]; //细节，用方括号访问保存在变量propertyName中的属性，终于知道用处了 var val2 = obj2[propertyName]; if(val1&lt;val2)&#123; return -1; &#125;else if(val1&gt;val2)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;;&#125; 看起来很复杂，其实就是嵌套了一个函数，而且内部函数前面加了一个return操作符。在内部函数接收到propertyName参数后，它会用方括号表示法来取得给定属性的值。取得这个对象属性后，就用这个属性进行比较。完成对象数组的排序。用法：123456var data = [&#123;name:&quot;Zachary&quot;,age:28&#125;,&#123;name:&quot;Nicholas&quot;,age:29&#125;];data.sort(creatComparisonFunction(&quot;name&quot;));console.log(data[0].name); //Nicholasdata.sort(creatComparisonFunction(&quot;age&quot;));console.log(data[0].name); //Zachary 5.5.4函数内部的属性在函数内部，有两个特殊的对象（函数对象中的对象）：arguments和this。arguments在第三章介绍过，是一个类数组对象，包含这个传入函数的所有参数。虽然arguments的主要用途是保存所有函数参数，但arguments对象还有一个名叫callee的属性，该属性是一个指针。arguments.callee( )可以指代这个函数本身。用处是可以消除函数的执行与函数名之间的耦合。还是那个阶乘的例子：1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*factorial(num-1); &#125;&#125; 如果我把factorial这个函数名改为另一个函数的函数名：12345var trueFactorial = factorial;function factorial()&#123; return 0;&#125;console.log(trueFactorial(5)) // 0 这个时候trueFactorial（）函数就出错了，要降低这种耦合，使用arguments.callee( )是最好方法。1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*arguments.callee(num-1); //即使factorial被改写，arguments.callee()仍代表当前函数。 &#125;&#125; 函数内部的另一个特殊对象是this，其行为与Java和C#中的this大致类似。换句话说，this引用的是函数据以执行的环境对象。当在网页的全局作用域中调用函数时，this对象引用的就是window。例子：123456789indow.color = &quot;red&quot;;var o = &#123;color:&quot;blue&quot;&#125;;function sayColor()&#123; console.log(this.color);&#125;sayColor(); //redo.sayColor=sayColor;o.sayColor(); //blue 函数sayColor( )首先是在全局作用域中定义的，它引用了this对象。但在调用它之前，并不确定是在哪个作用域中调用。当在全局作用域中调用sayColor( )，this引用的是全局对象，所以this.color = window.color。结果返回red。当把这个函数赋给对象o，并调用o.sayColor( )时，this引用的是对象o，因此this.color = o.color。结果返回blue。（亲测把sayColor（）函数放在另一个函数中去调用，最后得到的结果还是window，再嵌多一层函数也还是window，说明this引用的不是作用域，而是函数据以执行的环境对象，还有一个原因是当你把函数嵌套进另一个函数的时候，返回是window的原因是你此时调用的实际上已经不是一个方法，而是一个函数。） ECMAScript5还规范化了另一个函数对象的属性caller。除了Opera早期版本不支持，其他浏览器IE，Firefox，Chrome，和Safari的所有版本及Opear9.6都支持caller属性。这个属性保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。例如：1234567function outer()&#123; inner();&#125;function inner()&#123; console.log(inner.caller); //会打印出outer()的源代码&#125;outer(); 以上代码会打印出outer( )的源代码，因为outer（）调用了inner（），所以inner.caller就指向outer（）。当然不能试图用inner.caller( )来调用outer。否则会陷入无限回调使代码出错。为了更松散的耦合，也可以通过arguments.callee.caller(）来访问相同的信息。1234567function outer()&#123; inner();&#125;function inner()&#123; console.log(arguments.callee.caller); //会打印出outer()的源代码&#125;outer(); arguments在严格模式下无法使用，arguments对象也有一个caller属性，但这个值永远是undefined。定义这个属性是为了分清arguments.caller和函数的caller属性，这个变化是出于增强这门语言的安全性。严格模式还有一个限制：不能为函数的caller属性赋值，否则会导致错误。 5.5.5函数属性和方法前面提过ECMAScript中函数是对象，所以函数就有属性和方法，上面介绍了一个caller。还有两个是length和prototype。length属性表示函数希望接收的命名参数的个数。命名参数有1个，length的值就是1，参数有两个，length的值就是2。不解释。 作者说，在ECMAScript核心所定义的全部属性中，最耐人寻味的就要数prototype属性了（不止函数的prototype，其他对象的prototype属性也耐人寻味！）对与ECMAScript中的引用类型而言，prototype是保存他们所有实例方法的真正所在。换句话说，诸如valueOf（）,toString（）等方法实际上都是保存在了prototype属性名下。只不过是通过各自对象的实例访问到了。在创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的（第6章会详细介绍）。在ECMAScript中，prototype属性是不可枚举的，因此无法用for-in无法发现prototype这个属性。（对property属性的讲解到此为止） 每个函数都包含两个非继承而来的方法：apply（）和call（）。这两个方法的用途都是在特定的作用域中调用函数。实际上等于设置函数体内this对象的值。两个方法的区别只是在传入参数的方法上有区别而已。首先，apply（）方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例（就是普通数组），也可以是arguments对象。例子：12345678910111213function sum(num1,num2)&#123; return num1+num2;&#125;function callSum1(num1,num2)&#123; return sum.apply(this,arguments);&#125;function callSum2(num1,num2)&#123; return sum.apply(this,[num1,num2]);&#125;console.log(callSum1(10,10)); //20console.log(callSum2(10,10)); //20 在上面这个例子中，callSum1( )在执行sum（）函数时传入了 this 作为 this 值（？？？）（因为是在全局作用域中调用的，所以传入的就是window对象）和arguments对象，而callSum2传入的第二个参数则是数组型。这两个函数都会正常执行并返回正确结果。（这个例子只是为了说明两种传入参数的方式都可以，还没体现出apply（）和call（）的作用） ✎在严格模式下，未指定环境对象而用函数，则this值不会转型为window（严格模式下的this不会默认转型为window）除非明确把函数添加到某个对象或者调用apply（）或call（），否则this值将是undefined。 call（）方法与apply（）方法的作用相同，区别仅在于接收参数的方式不同。对于call（）方法，第一个参数仍是this不变，变化的是其余参数都是直接传递给函数。换句话说，在使用call（）方法时，参数都是逐个列举出来的。例子：12345678function sum(num1,num2)&#123; return num1+num2;&#125;function callSum1(num1,num2)&#123; return sum.call(this,num1,num2);&#125;console.log(callSum1(10,10)); // 20 在使用call（）方法的情况下，callSum( )必须明确地传入每一个参数。结果与apply（）没有什么不同。使用哪一种完全是看你觉得哪个更方便（MD以前还觉得这两个方法多深奥ZZ）。apply（）和call（）的真正强大之处，是能够扩充函数赖以运行的作用域。例子：12345678910window.color = &quot;red&quot;;var o = &#123;color:&quot;blue&quot;&#125;;function sayColor()&#123; console.log(this.color)&#125;sayColor(); //redsayColor.call(window); //redsayColor.call(o); //blue 第一次调用sayColor()时在全局作用域中调用它，会显示“red”——因为对this.color的求值会转换成对window.color的求值。当运行sayColor。call(o)时，函数的执行环境对象就不一样了，因此此时函数体内的this对象指向了O,于是结果显示“blue”。使用call（）和apply（）的最大好处，就是对象不需要与方法有任何耦合关系（不用为了在这个对象内调用方法而把函数写进对象中）。在书中前面的第一个例子中（笔记没有），为了在对象o中调用sayColor( )，要把这个函数写进对象o中，再通过o调用，而在这里的例子中，就不需要那么多步骤了。ECMAScript5又定义了一个方法：bind（）（所以函数对象的方法有三个）。这个方法会创建一个函数的实例（会创建一个函数），其this值会被绑定到传给bind（）函数的值。例子：12345678window.color = &quot;red&quot;;var o = &#123;color:&quot;blue&quot;&#125;;function sayColor()&#123; console.log(this.color)&#125;var objSayColor = sayColor.bind(o);objSayColor(); 在这里，sayColor（）调用bind（）并传入对象o，创建了objSayColor（）函数。objSayColor（）的this值等于o。因此无论在哪个环境对象中调用这个函数，都会看到“blue”。这种技巧的优点参考第22章。因为是ECMAScrip5才有的方法，所以可以使用bind（） 的浏览器有： IE9+，Firefox4+，Safari 5.1+，Opera 12+和Chrome。（兼容性挺低的） 最后说每个引用类型值都有继承的，都会被重写的toLocaleString（）和toString（），valueOf（），这三个方法都始终返回函数的代码。返回代码的格式根据浏览器的不同会有差异。因为有返回值差异，所以返回的结果无法被用来实现任何功能，不过这些信息在调试代码时很有用。 5.6基本包装类型读到这里又刷新了三观。这里说Boolean、Number、String是3个ECMAScript提供的特殊引用类型。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。实际上，每创建一个基本类型的时候，后台就会创建一个对应的基本包装类型对象（WTF？？？），从而让我们能够调用一些方法来操作这些数据（这解释了为什么三种基本类型值也有自带的属性和方法）。例子，我们可以这样使用基本类型值的方法：12var s1 = &quot;some text&quot;;var s2 = s1.subString(2); 可以看到我们可以调用String类型自带的方法，但如下面的例子，我们不能在运行时为基本类型值添加属性和方法：123var s1 = &quot;some text&quot;;s1.color = &quot;red&quot;;console.log(s1.color); //undefined 我们知道，基本类型不是对象，因而从逻辑上它不应该有方法（尽管如我们所愿，它有方法）。其实，为了让我们能用方法操作基本类型值，后台已经自动完成了一系列的处理（注意后面是原理）：当第一段代码的第二行（var s2 = s1.subString(2); ）访问s1时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理：（1）创建String类型的一个实例；（2）在实例上调用指定的方法；（3）销毁这个实例。以上三个步骤用代码表示就是：123var s1 = new String(&quot;some txt&quot;);var s2 = s1.subString(2); //把结果放回给另一个变量s1 = null; //销毁这个对象 上面的步骤也适用于Boolean，Number类型。这也就解释了为什么不能给基本类型值添加属性和方法，因为基本类型值对象在调用完方法后就会被后台自动销毁。 引用类型和基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中（离开了作用域后可能就会被标记，然后被垃圾收集机制回收）。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁（亲测手动用new操作符创建的基本类型对象，可以添加属性和方法。）所以我们无法为基本类型值添加属性和方法。当然如果没有必要的话，就不要显示地调用Boolean和Number、String来创建基本包装类型对象（不要var s1 = new String(“some txt”)这样写）。因为这样容易让人分不清自己是在处理基本类型还是引用类型的值。 Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：123var obj = new Object(&quot;some text&quot;);console.log(obj instanceof String); //trueconsole.log(obj instanceof Object); //true 就是把字符串传给Object构造函数，就会创建String的实例，传入数值参数就会得到Number实例，传入布尔值参数就会得到Boolean实例，但是你检测它是以上基本类型值会返回true，检测是不是Object也会返回true。下面会讲每个基本包装类型提供的操作相应值的便捷方法。 5.6.1Boolean类型这节的重点是理解基本类型的布尔值与Boolean对象之间的区别。当然，作者的建议是永远不要使用Boolean对象，这节就当冷知识吧。 创建Boolean对象可以像下面这样调用Boolean构造函数并传入true或false值。1var booleanObject = new Boolean(false) Boolean类型的实例重写了的valueOf( )方法会返回基本类型的true和false，重写了的toString( )会返回字符串型的“true”和“false”。书中前面提到过，但是当时不懂有什么用就没记的一段话：布尔表达式中的所有对象都会被转换为true。例子：123var falseObject = new Boolean(false);var result = falseObject &amp;&amp; true;console.log(result); //true 在这个例子中我们用false值创建了Boolean对象的实例falseObject，并对这个对象与true进行&amp;&amp;运算，却发现返回到结果是true。因为，示例中的代码是对falseObject而不是对它的值（false）求值。而布尔表达式中的所有对象都会被转换为true，结果true&amp;&amp;true当然就等于true了。 5.6.2Number类型Number类型也重写了valueOf（）、toLocaleString（）、toString（）。valueOf（）返回这个对象表示的基本类型的数值（亲测就是一个数）。toLocaleString（）、toString（）返回字符串类型的数值。Number的toString（）方法可以传递一个表示基数的参数，参数是几，就按几进制的数字的字符串形式返回。12var num = 10;console.log(num.toString(2)) //&quot;1010&quot; 注意返回的是字符串形式的。 上面的几个是继承的方法，Number类型提供了一些可以将数值格式化的方法。 toFixed（）：按照指定的小数位返回数字的字符串表示，且支持四舍五入。比如25.005用toFixed(2)，会变成“25.01”。 toExponential(（）：返回以指数表示法表示的数值的字符串形式。接收的参数也是指定输出结果中的小数位数。 12345var num = 10.005;console.log(num.toFixed(2)) //&quot;10.01&quot;var num = 10;console.log(num.toExponential(1))//&quot;1.0e+1&quot; 5.6.3String类型String对象继承的valueOf（）、toLocaleString（）、toString（）返回的都是这个对象表示的基本字符串值。String类型的每个实例都有一个length属性，表示字符串中有多少个字符（亲测中文也是有多少个字长度就是几）。书中说了，即使字符串中包含双字节字符（不是占一个字节的ASCII字符，每个字符也仍然算一个字符）。 String类型提供的方法很多，看到都怕。 1.字符方法两个用于访问字符串中特定位置字符的方法：charAt( )和charCodeAt( )。两个方法都接收一个参数，即基于0的字符位置。两个方法的区别是charAt( )返回的是给定位置的那个字符。charCodeAt( )返回的是那个字符的字符编码。例子：123var stringValue = &quot;hello World&quot;;console.log(stringValue.charAt(1)); // &quot;e&quot;console.log(stringValue.charCodeAt(1)); // &quot;101&quot; 是小写字母e的字符编码 ECMAScript5定义了另一个访问个别字符的方法，可以用方括号加数字索引来访问字符串中的特定字符。例子：12var stringValue = &quot;hello World&quot;;console.log(stringValue[1]); //&quot;e&quot; 类似于把字符串当成一个“数组”，按位置取出所在位置的字符。亲测可以直接在字符串后面加方括号，例子：1console.log(&quot;sdsdsdsd&quot;[2]); //&quot;s&quot; 66666 支持这个语法的浏览器有IE8，Firefox，Safari，Opera 和Chrome所有版本的支持。冷知识：在IE7及更早版本使用这种语法会返回undefined值，尽管不是特殊的undefined值（不是很懂最后一句的意思，我以为返回的那个undefined是字符串型的，但是不是） 2.字符串操作方法操作字符串的方法有几个，第一个是concat( )，可以将一或多个字符串拼接起来，参数就是要添加进去的字符串，参数数量不限。返回得到的新字符串。数组类型也有这个方法，不解释。不过在实践中使用最多的是加号操作符（+）（MDZZ）。ECMAScript还提供了三个基于子字符串创建新字符串的方法：slice（）、substr（）、substring（）。三个方法都返回被操作字符串的一个子字符串。三个方法的第一个参数都是指定子字符串的开始位置。slice（）和substring（）的第二个参数指定的是子字符最后一个字符后面的位置（忽略结尾那个位置）。而substr（） 的第二个参数指定的则是返回字符的个数。如果没有第二个参数，则默认将字符串的长度作为结束的位置。（太乱实际用再百度）。与concat（）方法一样，这三个方法也不会修改本身的那个字符串。对原始字符串无任何影响。例子：1234567var stringValue = &quot;Hello World&quot;;console.log(stringValue.slice(3)); //&quot;lo world&quot;console.log(stringValue.substring(3)); //&quot;lo World&quot;console.log(stringValue.substr(3)); //&quot;lo World&quot;console.log(stringValue.slice(3,7)); //&quot;lo W&quot;console.log(stringValue.substring(3,7)); //&quot;lo W&quot;console.log(stringValue.substr(3,7)); //&quot;lo Worl&quot; substr()第二个参数表示要截取的字符个数 看起来三个方法作用很容易理解，但是传递给这些方法的参数是负数的情况下，他们的行为就不尽相同了。其中，slice（）会将传入的负值与字符串的长度相加，substr（）将负的第一个参数加上字符串的长度，而将第二个负的参数转换为0.最后，substring（）方法会将所有负值参数都转换为0.很恐怖，不想举例子了，实践中没事不要用负数就行。需要再看书。 3.字符串位置方法有两个可以从字符串中查找子字符串的方法：indexOf( )和lastIndexOf( )。这两个方法都是从一个字符串中搜索给定的子字符串，然后返回子字符串的位置。查找不到就返回-1.两个方法的区别是一个从头向后查询，一个从后向前查询。例子：123var stringValue = &quot;hello world&quot;;console.log(stringValue.indexOf(&quot;o&quot;)); //4console.log(stringValue.lastIndexOf(&quot;o&quot;)) //7 这两个方法都接收第二个参数，表示从字符串哪个位置开始搜索。换句话说，indexOf（）从该参数指定的位置向后搜索，忽略之前的所有字符；而lastIndexOf（）则会从指定的位置向前搜索，忽略该位置之后的所有字符（为什么在讲第二次的时候才讲这么清楚）。例子：123var stringValue = &quot;hello world&quot;;console.log(stringValue.indexOf(&quot;o&quot;,6)); //7console.log(stringValue.lastIndexOf(&quot;o&quot;,6))//4 indexOf( )从位置6（字母“w”）开始向后搜索，在位置7找到“o”。lastIndexOf( )从位置6开始向前搜索，找到的是“hello”中的“o”，所以返回4。 我们可以在使用第二个参数的情况下，通过循环把所有匹配的子字符串找出来，例子：123456789var stringValue = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;;var positions = new Array();var pos = stringValue.indexOf(&quot;e&quot;);while(pos&gt;-1)&#123; positions.push(pos); pos = stringValue.indexOf(&quot;e&quot;,pos+1);&#125;console.log(positions); //[3, 24, 32, 35, 52] 4.trim（）方法ECMAScript5定义了trim（）方法，该方法会创建一个字符串副本，删除前置和后置的所有空格，然后返回结果。支持这个方法的浏览器有：IE9+，Firefox 3.5+，Safari 5+，Opera 10.5+和Chrome。此外，Firefox 3.5+，Safari 5+和Chrome 8+还支持非标准的trimLeft( )和trimRight( ) ，分别用于删除字符串开头和末尾的空格。 5.字符串大小写转换方法toLowerCase（）、toLocaleLowerCase（）、toUpperCase（）和toLocaleUpperCase（）。为什么会有toLocaleLowerCase（）、toLocaleUpperCase（）这两个方法是因为有些地区比如土耳其语回味iUnicode大小写转换应用特殊的规则也是醉了，所以用这两个针对地区的方法来保证正确的转换。 6.字符串的模式匹配方法正则看得头大 7.localCompare方法tolocalCompare（）方法就是用字符串跟方法的字符串参数比较，如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1），如果字符串等于字符串参数，则返回0；如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1）。而且localCompare（）方法有个与众不同的地方，大小写是否区分要视使用方法的地区不同而定。比如美国以英语作为ECMAScript实现的标准语言，因此localCompare（）就是区分大小写的，则大写字母在字母表中会排在小写字母前面。所以是否区分大小写要根据地区而定。（亲测中国地区区分大小写且大写字母在小写字母之前） 8.fromCharCode（）方法String构造函数（是构造函数的方法不是普通字符串的方法）本身还有一个静态方法：fromCharCode( )。这个方法可以接收一或多个字符编码，将他们转换为字符串。例子： 9.HTML方法作者建议尽量不用这些方法，因为他们创建的标记通常无法表达语义（不懂）。方法有12个，需要再查书吧。 5.7单体内置对象ECMA-262对内置对象的定义是：“由ECMAScript实现提供的，不依赖宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了，所以开发人员不用显示地实例化内置对象，因为他们已经实例化了。”前面介绍的Object、Array和String等都是内置对象。ECMA-262还定义了两个单体内置对象：Global和Math。 5.7.1Global对象Global（全局）对象是ECMAScript中最特别的一个对象，因为你不管从什么角度上看，这个对象都是不存在的（？？？）。ECMAScript中的Global对象在某种意义上是作为一个“兜底儿对象”。换句话说，不属于任何对象的属性和方法，都是global对象的属性和方法。事实上，没有全局变量和全局函数，因为所有在全局作用域中定义的属性和函数，都是Global对象的属性（只是属性，函数也是Global对象的属性）。本书前面介绍过的那些函数，比如isNan（），isFinite（）、parseInt（）以及parseFloat（），都是Global对象的方法（array,object等类型对象的方法当然不是Global对象的，是array、object等这些对象的，不要混淆）。除此之外，Global还有其他一些方法。下面介绍这几个方法： 1.URI编码方法Global对象的encodeURI（）和encodeURIComponent（）方法可以对URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的URI不能包含某些字符，例如空格，而这两个URI编码方法就会对URI进行编码，用特殊的UTF-8字符替换所有无效的字符，让浏览器能够接受和理解。encodeURI（）和encodeURIComponent（）的第一个区别是，encodeURI（）只会把URI中无效的字符替换掉，encodeURIComponent（）会把正确的特殊符号例如冒号、正斜杠、问号和井号也给替换掉。第二个区别是，encodeURI（）用于整个URI，而encodeURIComponent（）用于对URI中的某一段进行编码。例子：12345var uri = &quot;http://www.wrow.com/illegal value.html#start&quot;;console.log(encodeURI(uri)); //http://www.wrow.com/illegal%20%20value.html#startconsole.log(encodeURIComponent(uri)); //http%3A%2F%2Fwww.wrow.com%2Fillegal%20%20value.html%23start 第二个方法中连12345有编码的函数，就有解码的函数，与这两个函数对应的函数是**decodeURI（）和decodeURIComponent（）**。其中，decodeURI（）**只能对非法字符进行解码**，decodeURIComponent（）可以对**所有被编译的符号**进行解码。例如，decodeURI（）可以将%20替换成空格，但不能对%23做任何处理，因为%23表示井字号（#），而井字号是合法符号。但是decodeURIComponent（）就%20和%23都可以解码。&lt;h4&gt;2.eval（）方法&lt;/h4&gt;最后一个Global对象的方法，大概是**整个ECMAScript语言中最强大的一个方法：eval（）**（见仁见智，有些人觉得这个方法弊端多多）。eval（）就像一个**完整的ECMAScript解析器**，它只接收一个参数，即**要执行的ECMAScript（或JavaScript）字符串**。例子： eval(“alert(‘hi’)”);1以上代码等价于下面这行（so what??）： alert(‘hi’)；1当解析器发现代码中调用eval（）方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原来位置。**通过eval（）方法执行的代码被认为是包含该次调用的执行环境的一部分**，因此被执行的代码具有与该执行环境相同的**作用域链**。这意味着通过eval（）执行的代码**可以引用在包含环境中定义的变量**。例子： var msg = “hello world”;eval(“alert(msg)”);1可见，变量msg是在eval（）调用的环境之外定义的，但其中调用的alert（）仍然能够显示“hello world”。这是因为上面第二行代码最终被替换成了一行真正的代码（so？那干嘛要加个eval（），直接写进执行环境不就好了吗）。同样地，我们也可以在eval（）调用中定义一个函数，然后在外部代码中引用这个函数： eval(“function sayHi(){ alert(‘Hi’); }”);sayHi();12345显然，函数sayHi（）是在eval（）内部定义的。但由于对eval（）的调用最终会被替换成定义函数的实际代码，因此可以在下一行的外部代码中调用sayHi( )。在eval（）中创建的仍和变量或函数**都不会被提升**，原理：因为在解析代码的时候，他们被包含在一个字符串中，它们只在eval（）执行的时候创建。严格模式下，在外部访问不到eval（）中创建的任何变量或函数，因此前面的那个例子就会导致错误。在严格模式下，为eval赋值也会导致错误： “use strict”;eval = “hi”; //causes error123456&lt;h4&gt;3.Global对象的属性&lt;/h4&gt;前面说过了，没有明确对象的属性，最后都是Global的属性，例如，特殊的值undefined、NaN以及Infinity等。此外，所有原生引用类型的**构造函数**，像Object，Function也都是Global对象的属性。书中列出了所有Global对象的所有属性。在P133.ECMAScript 5明确禁止给undefined、NaN和Infinity赋值，这样做即使在非严格模式下也会导致错误。&lt;h4&gt;4.window对象&lt;/h4&gt;ECMAScript没有明确告诉我们如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的（在浏览器中，Global对象是**window对象的一部分**，注意范围：浏览器中，window对象的一部分。）例子： var color = “red”; function sayColor(){ alert(window.color);}window.sayColor(); //“red”12345在这里我们定义了一个名为color的全局变量和一个sayColor（）全局函数。在sayColor（）内部，我们用window.color来访问变量，前面我们说过，全局环境中定义的变量和函数，实际上都是Global的属性，所以**window.color等价于Global.color**。以此说明，全局变量是window对象的属性。然后，又使用window.color来直接通过window.sayColor( )直接通过window对象调用这个函数。&gt;✎JavaScript中的window对象除了扮演ECMAScript规定的Global对象的角色外，还承担了很多任务，所以说Global对象这是window对象的一部分。第8章在讨论浏览器对象模型时将详细介绍window对象。另一种取得Global对象的方法是使用以下代码： var global = function(){ return this; // 亲测return出来的是 window}();```这是个立即调用的函数表达式，返回this的值。如前所述，在没有给函数明确指定this值的情况下，this值等于Global对象。而像这样通过简单地返回this来取得Global对象，在任何执行环境下都是可行的。（因为是立即执行函数的原因？） 5.7.2Math对象不想写了这个，就是Math下的各种方法。可以直接在书中查阅。","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"高程","slug":"高程","permalink":"https://millionqw.github.io/tags/高程/"}]},{"title":"Postcss使用体验：在未来写CSS","date":"2017-07-07T12:24:46.000Z","path":"2017/07/07/Postcss使用体验：在未来写CSSSS/","text":"&nbsp;&nbsp;接触Postcss的起因是在用Npm安装模块的时候看到的提示语句，一番接触后发现：我以后可能不需要写Sass了。&nbsp;&nbsp;今天用Npm安装模块的时候出现了一段提示语句：&nbsp;&nbsp;大致了解了一下Postcss是一个平台，上面有各种插件用来处理CSS，不过里面讲的东西，我觉得没必要用得这么麻烦。 &nbsp;&nbsp;重点是他推荐的大漠老师POSTCSS深入学习,进了这个指引，你对Postcss的理解，最重要使用就能非常清晰了。 &nbsp;&nbsp;说说我对Postcss的误解，一开始我以为它是像Sass、Less一样的预处理器，心想又要去学一种预处理器吗？后来又发现它竟然还有autoprefixer（自动添加浏览器前缀），压缩代码等功能，后来又觉得，这些功能能做的，gulp也能做，那我还要Postcss干嘛？ &nbsp;&nbsp;通过学习后发现，它就是gulp+Sass的结合版，最重要的是一下几点： 一、清晰、简短的配置&nbsp;&nbsp;只要你引入了Npm中各种“postcss-”前缀的插件，只要你不是很想特别定制，只要在处理css的‘gulp’的’task’中给一个数组，写进你要添加的处理模块，gulp就能编译出CSS代码，相比gulp的插件，要写一个个方法，一些方法的配置还要去查文档，Postcss的配置简直简单到“引入即用”的感觉。 &nbsp;&nbsp;这个就是我gulpfile.js中Postcss部分的配置： 123456789101112131415161718192021222324var gulp = require(&apos;gulp&apos;);var postcss = require(&apos;gulp-postcss&apos;);var autoprefixer = require(&apos;autoprefixer&apos;); //自动添加前缀var opacity = require(&apos;postcss-opacity&apos;); //opacity属性的降级处理var pseudoelements = require(&apos;postcss-pseudoelements&apos;); //让IE8支持::的伪元素var vmin = require(&apos;postcss-vmin&apos;); //为IE9支持viewport相对单位vminvar pixrem = require(&apos;pixrem&apos;); //给rem添加px作为降级处理为IE8var will_change = require(&apos;postcss-will-change&apos;); //为will-change属性添加回退var cssnext = require(&apos;cssnext&apos;); //写未来的CSSvar precss = require(&apos;precss&apos;); //用函数的方法写CSSvar color_rgba_fallback = require(&apos;postcss-color-rgba-fallback&apos;); //给rgba()提供降级方案为IE8var atImport = require(&apos;postcss-import&apos;); //可以使用@import引入其他CSS文件，减少Http请求var mqpacker = require(&apos;css-mqpacker&apos;); //合并媒体查询var size = require(&apos;postcss-size&apos;); //CSS中一个size属性同时写height和widthgulp.task(&apos;css&apos;, function () &#123; //will_change必须在autoprefixer之前 var processors = [ will_change, autoprefixer, cssnext,color_rgba_fallback, opacity, pseudoelements, vmin, pixrem,precss,atImport,mqpacker,size ]; return gulp.src(&apos;./src/*.css&apos;) .pipe(postcss(processors)) .pipe(gulp.dest(&apos;./dest&apos;));&#125;); &nbsp;&nbsp;可以看到除了长长的引用模块外，想要使用Postcss中的插件，只需要在processors数组中添加你要使用的模块，用pipe()处理即可。 二、极大减少CSS书写量&nbsp;&nbsp;如果你已经厌倦了一次次地写重复的垂直居中、水平居中，Postcss中，有postcss-center帮你搞定，只要你引入了postcss-center，top:center用于实现垂直居中，left:center用于实现水平居中：1234.centered &#123; top:center; left:center;&#125; 编译出来的CSS：1234567.centered&#123; position: absolute; top: 50％; right: 50%; margin-right: -50%; transform: translate(-50%, -50%);&#125; 两段代码来自大漠老师教程 &nbsp;&nbsp;诸如此类，清除浮动，设置定位，设置水平，垂直间距，输出颜色代码等等等，都分别有postcss-clearfix，postcss-position，postcss-verthorz，postcss-color-short等插件可以实现，极大提升写代码效率。因为我还在学习中，这些东西我觉得还是先自己写明白了比较适合，所以只使用了postcss-size这个插件，就是使用后height和width可以同时写在同一行，我早就想这么做啦23333：123.img &#123; size: 200px 200px;&#125; 编译后的CSS：1234img &#123; height: 200px; width: 200px;&#125; 三、类似Sass的语法&nbsp;&nbsp;并不是说postcss有类似Sass的语法，而是因为postcss有cssnext插件，可以用未来使用的css语法，再转化为css现在浏览器支持的语法，而类似Sass中的mixin，extend，定义变量，函数等功能，未来的CSS语法也都有，只是与Sass有少许差异，而且如果你想用Sass，Less编写也可以，只要调整一下编译顺序，让编译Sass的命令在postcss命令之前即可。 &nbsp;&nbsp;总而言之，postcss上这么多插件，合理搭配使用可以极大地提高开发效率，我觉得既然未来的CSS语法已经摆在了你面前，就像ES6语法有了babel的支持一样，可以借助postcss而提前使用，那么为什么不早点使用迟早会成为标准的语法呢，我已经打算开始尝试结合gulp上的其他配置，开始学习“未来的CSS”，尝试postcss的使用，在未来写CSS，一起试试吧！","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"https://millionqw.github.io/tags/CSS/"}]},{"title":"《Javascript》高级程序设计 第五章 详细解释引用类型（上）","date":"2017-07-06T13:45:07.000Z","path":"2017/07/06/《Javascript》高级程序设计 第五章 详细解释引用类型（上）/","text":"第五章 引用类型引用类型的值（对象）是引用类型的一个实例。如前所述，对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身也是一个函数，只不过该函数是出于创建新对象的目的而定义的。例子：1var person = new Object(); 这行代码创建了一个Object这个引用类型的新实例，然后把该实例保存在了变量person中。（这句话特别有意思，如果我用自己的话说，会说“创建了一个叫person的Object的新实例，而不会说先创建了实例再把实例保存在person中”）使用的构造函数就是Object( )。它为新对象（person定义了默认的属性和方法）。ECMAScript提供了很多原生引用类型（例如Object( ),Date( ),RegExp( )）。以便开发人员完成常见的计算任务。 5.1Object类型创建Object类型的方法有两种。第一种，使用new操作符后跟Object构造函数。例子：123var person = new Object();person.name = &quot;Nicholas&quot;;person.age = 29; 第二种，用对象字面量表示法。这种方法更被开发人员所接受，最推荐使用。代码量少，且给人封装数据的感觉。实际上，对象字面量也是向函数传递大量可选参数的首选方式。例子：1234var person = &#123; name : &quot;Nicholas&quot;, //属性名也可以用字符串如：&quot;name&quot; : &quot;Nicholas&quot; age : 29 // &quot;age&quot; : 29&#125; 在对象字面量中使用逗号来分隔不同的属性，因此“Nicholas”后面记得加逗号，最后一个属性后面不能加逗号。否则IE7及更早版本和opera会出现错误。✎注意：使用对象字面量定义对象时，并没有调用到Object函数（即内在原理不是Object函数，Firefox 2以及更早版本的Firefox会调用Object函数，但Firefox3之后就不会了。） ✎关于表达式上下文（expression context）和语句上下文（statement context）在用对象字面量定义新对象的例子中，左边的花括号“｛”表示对象字面量的开始，因为它出现在了表达式上下文（expression context）中（”person=”，等号的后面）。ECMAScript中的表达式上下文指的是该上下文期待一个值（表达式）。赋值操作符（“=”）表示后面是一个值（这里的值是一个对象，不要直觉觉得值就是一个数字），所以左花括号在这里表示一个表达式的开始。同样的花括号如果出现在一个语句上下文（statement context）中，例如跟在 if 语句条件的后面，则表示一个语句块的开始。 对象字面量除了可以用来定义新对象，当函数需要大量可选参数时，使用对象字面量也是不错的选择。例子：12345678910111213141516171819202122function displayInfo(args)&#123; var output = &quot;&quot;; if(typeof args.name == &quot;string&quot;)&#123; output += &quot;Name:&quot; + args.name + &quot;\\n&quot;; console.log(output); &#125; if(typeof args.age == &quot;number&quot;)&#123; output=&quot;&quot;; output += &quot;Age&quot; +args.age + &quot;\\n&quot;; console.log(output); &#125;&#125;//用对象字面量传递参数，这时候args就是对象，name,age就是args的属性displayInfo(&#123; name:&quot;Nicholas&quot;, age:29&#125;)displayInfo(&#123; name:&quot;Greg&quot;&#125;) 这个例子中，函数displayInfo（）接受一个名为args的参数，这个参数可能带有一个名为name或age的属性，有可能同时有也可能都没有。在函数内部用typeof操作符检测每个属性是否存在，再根据相应属性来构建显示信息。对象字面量传递参数法特别适合在需要向函数传递大量可选参数的情形。最好的做法是：对那些必需值使用命名参数（直接写在括号内），用对象字面量来封装多个可选参数。 ✎访问对象属性时用点表示法或者是方括号“[ ]”的取舍仍然以上面的person对象为例子。使用方括号访问对象属性的时候，千万千万记得要给对象属性加双引号（亲测单引号也可以）才能真正访问到那个对象属性，这是个很容易出现错误但找不到原因的地方。例子：12alert(person[&quot;name&quot;]); // Nicholasalert(person[name]); // undefined 使用方括号的优点一是，可以使用变量间接地访问对象属性。例子：123var propertyName = &quot;name&quot;; // 必须加双引号，否则是undefinedalert(person[propertyName]); // Nicholasalert(person.name); // undefined 方括号的优点二：如果对象属性名中包含会导致语法错误的字符（比如空格），或者属性名使用的是关键字或保留字，也可以使用方括号表示法。例子：123person[&quot;first name&quot;] = &quot;Nicholas&quot;;person[&quot;last-name&quot;] = &quot;Tom&quot;;alert(person[&quot;first name&quot;]); 有空格，“ - ”等会导致错误的属性名，只能通过方括号语法赋值（对象字面量也不行）和访问。（亲测）当然，除非是使用变量来访问属性，或者属性中带有特殊字符，否则还是建议用点表示法访问。 5.2Array类型avaScript的数组类型与其他语言的数组类型的最大不同，就是JavaScript数组的每一项可以保存任何类型的数据，比如第一项保存数字，第二项保存字符串，第三项保存对象。而且可以随着数据的添加自动增长以容纳新增数据。创建数组的两种方法。方法一是使用Array构造函数，例子：1var colors = new Array(); 如果预先知道了数组是多少位，也可以给Array构造函数直接传递数量，该数字就会成为该数组的length属性的值1var colors = new Array(20); // colors.length = 20 也可以直接向Array构造函数直接传递数组包含的值1var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;orange&quot;); 在使用Array构造函数的时候，可以省略“new”操作符。省略“new”操作符的效果与添加“new”的效果相同。第二种创建数组的方法：数组字面量表示法。（与对象一样，使用数组字面量表示法时也不会调用Array( )构造函数（Firefox3及更早的版本除外））1234var colors = [ &quot;red&quot;, &quot;blue&quot;, &quot;orange&quot; ];var names = [];var values = [1,2,] //不要这样做，IE8及之前的版本会出BUGvar options = [, , , , ,] //不要这样做，IE8及之前的版本会出BUG 第三种情况在IE8及之前的版本中，数组values会有1，2，undefined三个值，其他浏览器则只有1和2.第四种的情况与第三种类似，IE会创建6个值，其他浏览器会创建5个，因为有浏览器差异，所以强烈建议不这么做。不过正常人谁这么做。把玩Array引用类型的属性length数据的length属性有一个特点——可写可读。如果设置这个属性的值比现有数组长度短，则设置的长度后面的数组的值就会被删除。如果设置length的值比现有的length大（比如设置array.length=100），则数组的长度变为100，空位置为undefined。利用length也可以很方便地在数组末尾添加新的值。例子：12var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;orange&quot;]; // colors.length = 3;colors[colors.length] = &quot;black&quot; // clolors[3] = &quot;black&quot;; 当把一个值放在超出当前数组大小的位置，数组就会重新计算长度，长度值变成最后一项的索引(索引就是从0开始的)加一。例子：123var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;orange&quot;];var colors[99] = &quot;black&quot;;alert(colors.length) //100 中间colors[3]到colors[99]的值都是undefined。 数组的最大长度可以到4294967295（算冷知识吧）如果超过这个数就会出现异常。如果一个数组的大小接近这个上限值，会导致运行时间超长的脚本错误。 5.2.1检测数组对于一个网页或一个全局作用域而言，使用instanceof操作符就能得到满意的结果。而instanceof操作符的问题在于，它假定只有一个全局执行环境。如果网页红包含多个框架，那实际上就会出现两个及以上的执行环境，从而存在两个以上不同版本的Array构造函数，如果从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。为了解决这个问题，ECMAScript5新增了 Array.isArray( ) 方法，这个方法的目的是最终确定这个值到底是不是数组，而不管它是在哪个全局执行环境中创建的（我也不知道为什么多个执行环境下有多个不同的构造函数就使instanceof操作符无法检测数组。）该方法用法如下：123if(Array.isArray(value))&#123; //对数组执行操作&#125; 5.2.2转换方法前面章节提过，所有对象都自带 toLocalString( )、toString( ) 和 valueOf( )方法。其中，调用数组的toString( )方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用valueOf( )返回的还是数组。实际上，toString( )方法为了创建这个字符串会调用数组每一项的toString（）方法（原理）。例子：1234var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;orange&quot;];alert(colors.toString()); //red,blue,orangealert(colors.valueOf()); //red,blue,orangealert(colors); //red,blue,orange 第一个alert显式地调用了toString方法（相对第三个alert）,每个值的字符串表示拼接成了一个字符串，中间用逗号分隔。第二个alert调用valueOf方法，最后一行代码直接将数组传递给alert。由于alert( ) 要接收字符串参数，所以它会在后台自动调用toString方法（相对第一个alert的显示调用），由此得到与第一个alert相同的结果。（用typeof 和 valueOf亲测 colors.valueOf( )的类型是Array,colors.toString( ）的类型是String） ✎toString（）和toLocalString（）的不同toLocaleString 方法返回一个 String 对象，这个对象中包含了用当前区域设置的默认格式表示的日期。 toLocaleString 只是用来显示结果给用户；最好不要在脚本中用来做基本计算，因为返回的结果是随机器不同而不同的。示 例:下面这个例子说明了 toLocaleString 方法的用法。12345var d, s; // 声明变量。d = new Date(); // 创建 Date 对象。s = &quot;Current setting is &quot;;s += d.toLocaleString(); // 转换为当前区域。根据所在地区（中国，欧洲）的不同，返回的日期格式不同return(s); // 返回转换的日期。 数组继承的前面三个方法，在默认情况一都会以逗号分隔的字符串的形式返回数组项（有点争议，valueOf( )返回的类型应该是Array类型，或对象型）而如果使用join( ) 方法，则可以使用不同的分隔符来构建这个字符串。join（）方法只接受一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。例子：123var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;orange&quot;];alert(colors.join(&quot;-&quot;)); //red-blue-orangealert(colors.join(&quot;||&quot;)); //red||blue||orange 5.2.3栈方法就是数据结构中的栈。栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构（碟子模型）。栈中项的推入和弹出都发生在一个位置——栈的顶部（数组的尾部）。ECMAScript为数组提供了push( )和pop（）方法，以便实现类似栈的行为。push( )（push: v. 推入）方法可以接收任意数量的参数（！），把他们逐个添加到数组的末尾，并返回修改后数组的长度。pop（）（pop: n. 啪的一声，数据弹出的声音），把数组末尾的最后一项移除，减少length的值，然后返回那个被移出的项。 5.2.4队列方法队列数据结构的访问规则是FIFO（Firest-In-First-Out，先进先出，派对模型），队列在列表的末端添加项，从列表的前端移除项。实现这两个操作的数组方法是shift（），它能移出数组的第一项，并返回该项。同时将数组长度减1。结合使用shift（）和 push（）方法，可以像使用队列一样使用数组。 5.2.5重排序方法数组中已经存在两个可以直接用来重排序的方法：reverse（）和sort（）。 reverse（）故名思义会翻转数组项的顺序。数组是被直接覆盖，不是翻转它的副本。在默认情况下，sort（）方法按升序排列数组项——即最小的值位于前面，最大的值排在最后面。但sort（）的大小即使数组是数字也不是按照数字大小排序的，而是都会先在内部通过toString( )转换为字符串，通过比较字符串按大到小排序。例子：123var values = [0,1,5,10,15];values.sort( );alert(values); //0,1,10,15,5 可见，即使例子中值的顺序没有问题，但sort( ) 方法也会根据测试字符串的结果改变原来的顺序。(其实JS中的sort()方法是按比较值的Unicode顺序进行排序的)这种排序方式很明显不是最佳方案，因此sort（）方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值前面。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等，则返回0，如果第一个参数应该位于第二个参数之后，则返回一个正数。以下就是一个简单的比较函数：123456789function compare(value1,value2)&#123; if(value1&lt;value2)&#123; return -1; &#125;else if(value1&gt;value2)&#123; return 1; &#125;else&#123; return 0; &#125;&#125; 只要将其作为参数传递给sort（）方法即可。例子：123var values = [0,1,5,10,15];varlues.sort(compare);alert(values); //0,1,5,10,15 如果想要产生降序的结果，只要交换比较函数返回的值即可。（把return 1 和return -1交换位置） ✎注意：reverse（）和sort（）方法的返回值是经过排序之后的数组（不会变成字符串）。对于数值类型或者其valueOf( ) 方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。对于这个函数只要用第二个值减第一个值即可。1234//用两行代码实现数值类型数组的升降排序function compare(value1,value2)&#123; return value2-value1; //return value1-value2就是降序&#125; 由于比较函数通过返回一个小于零，等于零，或大于零的值来影响排序结果，因此减法操作就可以适当地处理所有这些情况。 5.2.6操作方法操作方法就是讲操作数组的各种方法。第一个方法是concat（）。可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。如果没有给concat（）传递参数，它就只会复制当前数组并返回副本。如果传递给concat（）方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中，如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。例子：12345var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);alert(colors); //red,green,bluealert(colors2); //red,green,blue,yellow,black,brown 下一个方法是slice（）。它能够基于当前数组中的一或多个项创建一个新数组。slice（）方法可以接受一或两个参数。即要返回项的起始位置和结束位置（位置从0开始算）。只有一个参数：slice（）返回从该参数指定位置开始到当前数组末尾的所有项。两个参数：返回起始和结束位置之间的项——但不包括结束位置的项。且slice（）方法不会影响原始数组。例子：123456var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);alert(colors2); //green，blue,yellow,purplealert(colors3); //green,blue,yellow ✎注意：如果slice方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含5项的数组上调用slice（-2，-1）与调用slice（3，4）得到的结果相同。如果结束位置小于起始位置，则返回空数组。 第三个是splice（）方法。最强大的数组方法，其有很多种用法。splice（）的主要用途是向数组的中部插入项，但使用这种方法的方式有如下3种。 删除：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。例如：splice（0，2）会从位置0开始，删除数组中的前两项。 插入：可以向指定位置插入任意数量的项。只需3个参数：起始位置，0（要删除的项数，不删就是0）和要插入的项，如果要插入多个项，可以再传入第四，第五等任意多个项。例如，splice(2,0,”red”,”green”)会从当前数组的位置2开始插入字符串“red”和“green”（“red”会成为在位置2的值，“green”在位置3） 替换：可以向指定位置插入任意数量的项，同时删除一定数量的项，插入的项数不必与删除的项数相等。例如：splice（2，1，“red”,”green”）会删除当前数组位置2的项，然后从位置2开始插入字符串“red”和“green”。“red”在位置2。splice（）方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项就返回一个空数组）。下面是三种用法的例子：1234var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var removed = colors.splice(0,1);alert(colors); //green，bluealert(colors); //red，返回被删除的那一项 5.2.7位置方法ECMAScript5为数组添加的两个位置方法：indexOf( ) 和lastIndexOf( ) 都接收两个参数：要查找到项，表示查找起点的索引（可选，起点也可以被搜索到）。indexOf（）是从前向后查找，lastIndexOf（）是从后向前查找。两个方法返回的都是查找的项在数组中的位置。查找不到则返回-1。lastIndexOf（）返回的位置也是从头开始计的，虽然是从最后开始找。在用第一个参数与数组中的项比较时，使用的是全等操作符（“===”），非常严格。例子：123456789101112131415var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)) // 3alert(numbers.lastIndexOf(4)) // 5alert(number.indexOf(4,4)); //5alert(number.lastIndexOf(4,4)) //3 第二个参数是4，则相当于数组只有前面五项[1,2,3,4,5]以5为最后一项开始找。var person = &#123;name : &quot;Nicholas&quot;&#125;;var people = &#123;name : &quot;Nicholas&quot;&#125;;var morePlople = [person];alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person))//0 比较难懂的是lastIndexOf（）加第二个参数，测试了一下终于自己测出来。lastIndexOf（）的第二个参数查找起点的索引也是从头开始计算的，比如第二个参数是2，则相当于整个数组只剩前面的0，1，2.后面的项相当于“不见了”，然后以第2为最后一个位置开始查找数组。支持indexOf( ) 和lastIndexOf( )的浏览器有 IE9+(IE9+的意思用IE9也能成功)，Safari 3，Opera 5和Chrome. 5.2.8迭代方法ECMAScript5为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和运行该函数的作用域对象（可选）——影响this的值。传入这些方法中的函数（函数由我们自己编写）会接收三个参数（要写在函数的参数栏里）：数组的项的值（不能说“数组的项”，因为数组的项包括数组的项的值和位置），项的位置，数组对象（迭代方法是数组对象的方法，对象才有方法，是数组，对象）本身。 以下是这5个迭代方法： every（）：让数组中的每一项都过一遍every（）里的那个函数，全部返回true了，every（）方法才返回true。 some（）：让数组中的每一项都过一遍some（）里的那个函数，只要有一个返回true，some（）方法就返回true。 filter（）：筛选器。数组的每一项都过一遍filter（）里的函数，只返回一个通过了“考验”的数组。 forEach（）：对数组运行给定的函数，这个方法没有返回值。 map（）：对数组每一项过一遍map（）里的函数，返回经过这个函数“加工”过的结果组成的数组。 下面是every（）和some（） 的例子，返回true,false123456789var numbers = [1,2,3,4,5,6];var result = numbers.every(function(item,index,array)&#123; return item&gt;2;&#125;)console.log(result); //falsevar result = numbers.some(function(item,index,array)&#123; return item&gt;2;&#125;)console.log(result); //true 两个例子的ES6写法：12345let result = numbers.every((item,index,array) =&gt; item&gt;2);console.log(result); //falselet result = numbers.some((item,index,array) =&gt; item&gt;2);console.log(result); 使用的是ES6的箭头函数，适合简短的函数，不需要命名，箭头后面默认是return，具体看阮一峰的文档。 下面是filter（）的例子，返回一个由通过函数筛选条件的数组12345var numbers = [1,2,3,4,5,6];var result = numbers.filter(function(item,index,array)&#123; return item&gt;2;&#125;)console.log(result); // [3,4,5,6] 下面是运行map（）的例子，返回一个经过map（）内函数加工的数组12345var numbers = [1,2,3,4,5,6];var result = numbers.map(function(item,index,array)&#123; return item*2;&#125;)console.log(result); // [2,4,6,8,10,12] 下面是forEach（）的例子，这个方法（请严谨地说——方法，不是函数，它是数组对象的，方法）没有返回值。本质上相当于对封装了一个for循环给数组。1234var numbers = [1,2,3,4,5,6];numbers.forEach(function(item,index,array)&#123; console.log(item); //会像使用了for循环打印7次&#125;) 亲测在forEach（）里对数组的项进行赋值、计算得到的结果不会影响本来的那个数组，甚至在函数内打印出对每项经过计算后的数组，得到的数组也是没有改变的原来的数组。因为函数的参数是按值传递的。例子：1234567var numbers = [1,2,3,4,5,6];numbers.forEach(function(i,u,a)&#123; i=i+1; console.log(i); //每一项都打印出来，都被+1 console.log(a); //打印七次数组，每次都是原来那个数组[1,2,3,4,5,6]&#125;)console.log(numbers); //外面的数组没有改变，仍是[1,2,3,4,5,6] 以上every（），filter（） ，some（） ，map（） ，forEach（）只在IE9+，Firefox2+，Safari 3+，Opera 9.5+和Chrome有效。 打完上面那句因为函数的参数是按值传递的后发现一个有意思的事情，函数参数是按值传递没错，但数组是对象，函数的参数也是原来那个函数的指针，在函数里改变数组内的值，原来的那个数组也会被改变才对。经过亲自测试，当把数组当作参数传入函数，在函数内对数组内的值+1，在外部打印的数组也是经过+1的了！所以上面好像也不是因为函数的参数是按值传递的这个原因。大概forEach（）方法不会返回任何值所以也不会改变任何值吧，而console.log(a)打印出来的就是参数里的那个a，所以是原来那个参数。例子：123456789101112131415161718var numbers = [1,2,3,4,5,6];function add(array)&#123; for (var i = array.length - 1; i &gt;= 0; i--) &#123; array[i]+=1; &#125; console.log(array);&#125;add(numbers); //把数组作为参数传入函数，对每个值+1console.log(numbers); //外部的numbers也被改变[2,3,4,5,6,7]//于此同时用基本类型值number做同样的实验，全局的num在函数内经过计算后在全局打印出来的num还是等于6var num=6;function addOne(num)&#123; num+=1; console.log(num);&#125;addOne(num);console.log(num); //6 5.2.9归并方法ECMAScript5还新增了两个归并数组的方法：reduce（）和reduceRight（）这两个数组会迭代所有项，然后构建一个最终返回的值。两个方法只有一个区别：一个从头开始归并，一个从后向前归并。两个方法都接收两个参数：一个在每项上调用的函数和作为归并基础的初始值。传进这两个方法的函数接收4个参数：前一个值，当前值，项的索引和数组的对象。这个函数返回的任何值都会作为第一个参数（“前一个值”）自动传给下一项。第一次迭代发生在数组的第二项上（在这句话体会“迭代这个词的意思”），前一个值在第一次迭代时是数组的第一项，第二个参数是数组的第二项。第二次迭代的第一个参数就是第一项和第二项迭代（迭代有可能是加减乘除或其他计算方式）后的值。下面是用reduce（）方法求数组uoyou值之和的操作：12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev,cur,index,array)&#123; return prev+cur;&#125;);alert(sum); //15 第一次执行回调函数，prev是1，cur是2.第二次，prev是3（1加2的结果），cur是3（数组第三项）。这个过程持续到把数组最后一项访问到。最后返回结果。reduceRight( )方法不讲了区别只是开始的顺序是从后面开始罢了。 支持这两个归并函数的浏览器有： IE9+，Firefox3+，Safari 4+，Opera 10.5+和Chrome。（可以看出这两个方法比上面5个迭代方法要更难兼容。所有浏览器的版本都上了一个数，IE仍是9+才可以访问）。 5.3Date类型要创建一个日期对象，同样使用new操作符和Date构造函数即可。1var now = new Date(); 不向Date构造函数传递函数的情况下，新创建的对象默认自动获得当前日期和时间。如果想根据特定的日期和时间（日期：年月日；时间：时分秒），理论上应该传入表示该日期的毫秒数（即从UTC时间1970年1月1日午夜起至该日期经过的毫秒数）。当然JavaScript不可能这么不人道，ECMAScript提供了两个方法：Date.parse( ) 和Date.UTC( )这两种方法可以让你直接写入正常人类的日期即可使日期对象具备特定的日期和时间。两种方法表示日期的格式不同。而且也不用傻傻地写123//不用这么做！var someDate = new Date(Date.parse(&quot;May 25,2004&quot;));var allFives = new Date(Date.UTC(2005,4,5,17,55,55)); Date构造函数已经自带了这两个方法，如果直接写入“May 25,2004”，函数会自动调用Date.parse( )。如果写入的是2005，4，5，17，55，55，构造函数也会自动调用Date.UTC( )。所以不用像上面那样写。正确的写法：12var someDate = new Date(&quot;May 25,2004&quot;);var allFives = new Date(2005,4,5,17,55,55); ✎注意：第二个日期表示的是2005年5月5日，因为月份是从0开始计算的，0-11。 ECMAScript5添加了Date.now( )方法，返回程序运行到这个方法时的日期和时间的毫秒数，可以用来当计时器用，简化了使用Date对象分析代码的工作（不用专门构建Date对象就可以调用的方法）。例子：12345var start = Date.now( );doSomething();var stop = Date.now();result = stop - start; //通过start-stop可以得出运行doSomething()具体用了多少时间 又是ECMAScript5才发布的方法，所以能用的浏览器包括： IE9+，Firefox3+，Safari 3+，Opera 10.5+和Chrome。不支持这个方法的浏览器中，可以使用+操作符获取Date对象的时间戳，也可以达到同样的目的。12345var start = +new Date();doSomething();var stop = +new Date();result = stop - start; 5.3.1继承的方法与其他引用类型一样，Date类型也重写了toLocaleString（）、toString（）和valueOf（）方法。总而言之这一段就是告诉我们用toLocaleString（）和toString（）写出来的日期格式在同一个浏览器中是不一样的。恐怖的是根据浏览器的不同，每个浏览器用toString（）输出的结果也是不一样的。toLocalString（）同理。书里还有一句话：事实上，toLocaleString（）和toString（）在浏览器上显示格式的差别仅在调试代码时比较有用，在显示日期和时间上没有什么价值。 至于Date类型中的valueOf（）方法则根本不会返回字符串，而是返回日期的毫秒表示（ZZ）。 还有一点是：日期是可以比较大小的，下面例子：12345var date = new Date(2007,0,1);var date = new Date(2007,1,1);alert(date1&lt;date2); //truealert(date1&gt;date2); //false 比较早的日期小于比较晚的日期。 5.3.2日期格式化方法介绍了toDateString（）,toTimeString（） ,toLocalDateString（） ,toLocaleDateString（） ,toLocaleTimeString（） ,toUTCString（） ,这几个根据特定实现的格式或特定地区的格式显示的日期格式。与toLocaleString（）和toString（）相同，以上几个方法的显示格式也会因浏览器的不同有差异。没有哪一个方法能够用来在用户界面中显示一致的日期信息。 5.3.3日期/时间组件方法介绍了一大堆getFullYear（）、getMonth（）等方法，有用到自然会去百度，不写。 5.4RegExp类型正则网上有很多现成的正则案例，本人真的看到正则头大，所以这部分是跳过的，有兴趣的可以先看看JavaScript正则表达式视频教程-慕课网学习。","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"高程","slug":"高程","permalink":"https://millionqw.github.io/tags/高程/"}]},{"title":"《JS高级程序设计》第四章 作用域和内存问题","date":"2017-07-03T04:38:37.000Z","path":"2017/07/03/《JS高级程序设计》第四章-变量、作用域和内存问题/","text":"&ensp;&ensp;把2016年寒假写的对《JavaScript高级程序设计》的笔记写在博客上，同时回看加修改，同时也更新到简书上。尽量一天一篇一章。 第四章 变量、作用域和内存问题4.1基本类型和引用类型的值ECMAScript变量可能包含两个不同类型数据的值：基本类型值和引用类型值。基本类型值指的是简单的数据段（Boolean类型、Number类型、String类型、Undefined、Null） 引用类型值指那些可能由多个值构成的对象（Object类型、Array类型、Date类型、RegExp类型、Function类型）&gt;ES6中新增了Symbol,是JavaScript的第七种数据类型。4.1.1动态的属性基本类型值和引用类型值的区别一：对于引用类型值，我们可以为其添加或删除属性和方法，但是基本类型值没有属性和方法。例子:var person = new Object(); var name = “Nicholas”person.name = “Nicholas”; name.age = 27;alert(person.name); //“Nicholas” alert(name.age) //undefined以上代码一创建了一个对象并给他一个name属性，又通过alert访问成功。代码二给字符串name定义了一个age属性，但当我们访问的时候会发现这个属性不存在。这说明只能给引用类型值动态地添加属性，以便将来使用。4.1.2复制变量值基本类型值和引用类型值的区别二：在复制变量的时候，复制基本类型值和引用类型值也是有区别的。如果只是复制基本类型值，那就是简单复制到为新变量分配的位置上没毛病。当复制的是引用类型的值时，同样会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个新的副本实际上是一个指针，复制结束后，两个变量实际上将引用同一个对象。因此，如果复制的是引用类型值，当改变其中一个变量，就会影响另一个变量。例子：var obj1 = new Object();var obj2 = obj1;obj1.name=”Nicholas”;alert(obj2.name); //“Nicholas”变量对象中的变量保存在堆中的对象之间的关系如图：图片来自《JavaScript高级程序设计》可以看到当变量复制后，指针仍然指向一开始的Object，而不是复制出多一个Object。.4.1.3传递参数ECMAScript中所有函数的参数都是按值传递的。（无论参数是引用类型值和基本类型值）。也就是说，把函数外部的值复制给函数内部的参数，就和4.1.2复制变量值的原理一样，把一个变量复制到另一个变量（函数的参数）一样。有不少开发人员在这点会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。————————–讨论参数传递的是引用类型值的情况————————–function setName(obj){ obj.name = “Nicholas”;}var person = new Object();setName(person);alert(person.name); //“Nicholas”以上代码创建了一个对象person，这个变量被传递到setName（）函数中后被复制给了obj，在这个函数内部，obj和person引用的是同一个对象。换句话说，即使这个变量是按值传递的，obj也会按引用来访问同一个对象（遵循4.1.2的复制变量值原理）。于是当为函数内部为obj添加name属性后，函数外部的person也会有所反映。因为person指向的对象在堆内存中只有一个，而且是全局对象。有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的（大错特错）。为了证明对象是按值传递的。看下面的例子:function setName（obj）{ obj.name = “Nicholas”; obj = new Object(); obj.name = “Greg”;}var person = new Object();setName(person);alert(person.name); //“Nicholas”这段代码增加了两行，为obj重新定义了一个对象，第二行为该对象定义了一个带有不同值的name属性。如果person是按引用传递的，那么person最后会被自动修改为指向其name属性值为“Greg”的新对象。但是在函数外访问person.name时，显示的值仍然是”Nicholas”。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了(这个函数范围的局部对象)。而这个局部对象会在函数执行完毕后立即被销毁。4.1.4检测类型检测变量类型的方法有两种，一种是检测基本类型值的，用typeof，另一种是检测引用类型值的，用instanceof。typeof操作符是确定一个变量是string,boolean,number，undefined的最佳工具，如果变量是对象（根据规定，所有引用类型的值都是Object的实例）或null，则typeof操作符返回的值会是“object”。例子：var s = “Nicholas”, b = true, i = 22, u , n = null, o = new Object(), d = new Date();alert(typeof s); //stringalert(typeof i); //numberalert(typeof b); //booleanalert(typeof u); //undefinedalert(typeof n); //objectalert(typeof i); //objectalert(typeof d); //object因为typeof只能检测基本类型值，检测引用类型值时只会返回object，所以ECMAScript又提供了一个insanceof操作符，用法跟typeof不同，且只返回true 或 false。✎另类的情况使用typeof操作符检测函数时，该操作符会返回”function”。在Safari 5 及之前版本和Chrome 7及之前的版本中使用typeof检测正则表达式时，由于规范的原因，这个操作符也返回“function”。ECMA-262规定任何在内部实现 [ [ call ] ] 方法的对象都应该在应用typeof操作符时返回“function“。由于上述浏览器(Safari 5,Chrome 7)中的正则表达式也实现了这个方法，因此对正则表达式应用typeof会返回“function”。在IE和Firefox中，对正则表达式应用typeof会返回“object”. 如果变量是给定引用类型（根据它的原型链来识别，第6章将介绍原型链。#原书句）的实例那么instanceof操作符就会返回true。例子： alert(person instanceof Object); //变量person是Object吗？ alert(colors instanceof Array); //变量colors是Array吗？ alert(pattern instanceof RegExp); //变量pattern是RegExp吗？ //亲测左右两边位置不可互换，互换不会出现提示框 因为根据规定，所有引用类型的值都是Object的实例，因此把Date，Array，RegExp等引用类型值用instanceof 与Object验证时，始终都会返回true。用instanceof操作符检测基本类型值时，该操作符时钟返回false，因为基本类型不是对象。 4.2执行环境及作用域 作用域链重要的一点就是内部执行环境可以使用其外部环境的变量和函数，并且可以改变那个变量的值，只要那个变量不是被当作参数传进去的而是直接使用的。（当作参数传入的是按值传递，改变的是复制出来的变量，不会改变原来的变量） 执行环境（execution context）和作用域其实超级简单。每个执行环境都有一个与之关联的变量对象（variable object），环境变量中定义的所有变量和函数都保存在这个对象中。但是我们无法用代码访问到这个变量对象。但解析器在处理数据时会在后台使用它。 全局执行环境是最外围的执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是window对象（第七章将详细讨论），因此，所有全局变量和函数都是作为window对象的属性和方法创建的（window对象是个变量对象，全局变量和函数是它的属性和方法）。某个执行环境（例如一个函数）中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出（网页关闭或浏览器关闭时才被销毁）） > &ensp;&ensp;在Node.js中的全局执行环境是global 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权交给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制在控制。 当代码在其中一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的最前端，始终都是当前执行代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中不存在）。作用域链中的下一个变量对象来自包含它的外部环境，而再下一个变量对象则来自下一个包含环境。这样，一直延伸到全局执行环境； 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程从作用域链最前端开始，然后逐级向后回溯，直到找到标识符为止（如果找不到，就会发生错误） 例子：var color = \"blue\"； function changeColor(){ if(color == \"blue\"){ color = \"red\"; } } changeColor(); alert(color); // \"red\" 在这个例子中，函数changeColor( )的作用域链包含两个对象：它自己的变量对象（其中定义着arguments对象）和全局环境的变量对象。可以在函数内部访问变量color，就是因为可以在这个作用域链中找到它。 此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面这个例子所示： var color = \"blue\"; function changeColor(){ var anotherColor = \"red\"; function swapColors(){ var tempColor = anotherColor; anotherColor = color; color = tempColor; //这里可以访问color，anotherColor 和 tempColor } //这里可以访问color和anotherColor，但不能访问tempColor swapColors(); } //这里只能访问color changeColor();以上代码涉及三个执行环境：全局环境、changeColor（）的局部环境和swapColor（） 的局部环境。swapColor的局部变量中有一个变量tempColor，该变量只有在swapColor环境中能访问到，但是swapColor（）内部可以访问其他两个环境中的所有变量。 越在内部的局部环境，作用域链越长。对于这个例子中的swapColor（）而言，其作用域链中包含3个对象：swapColor( )的变量对象、changeColor（）的变量对象和全局对象。swapColor（）的局部环境开始时会现在自己的变量对象中搜索变量和函数名，如果搜索不到则再搜搜上一级作用域链。changeColor()的作用域链中只包含两个对象：它自己的变量对象和全局对象。也就是说，它不能访问swapColor（）的环境。 4.2.1延长作用域 有些语句可以在作用域链前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象，具体来说，就是当执行流执行到下列任何一个语句时，作用域链会得到增长 * try-catch语句的catch块 * with语句 这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中，对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。例子： function buildUrl(){ var qs = \"?debug=true\"; with(location){ var url = href + qs; } return url; } ✎添加一个with语句块的知识点当在with语句块中使用方法或者变量时，程序会检查该方法是否是本地函数，变量是否是已定义变量，如果不是，它将检查伪对象（with的参数），看它是否为该对象的方法，属性。如上面例子with语句块中的href，本地无定义，则with语句块会自动加上location.href，所以href实际上为href。这个就是with的功能。with 语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多数情况下，如果可能，最好避免使用它。在此，with语句接收的是Location对象，因此其变量对象中就包含了location对象的所有属性和方法，而这个变量对象被添加到了作用域链的最前端，buildUrl（）函数中定义了一个变量qs。当在with语句中引用变量href时(实际引用的是location.href)。可以在当前执行环境的变量对象中找到。当引用变量qs时，引用的则是在buildUrl( )中定义的那个变量，而该变量位于函数环境的变量对象中。至于with语句的内部，则定义了一个名为url的变量，因而url就成了函数执行环境的一部分，所以可以作为函数的值被返回。 4.2.2没有块级作用域 ✎添块级作用域任何一对花括号中的语句都属于一个块，在这之中定义的所有变量在代码块之外都是不可见的，我们称之为块级作用域。作用域有两种，块级作用域和函数作用域讲到这就好理解。JS没块级作用域就是说在for循环和if语句块中定义的变量是可见的，可以被外部使用的，但像其他的语言Java,C,C#语言中，在for，if语句中定义的变量在语句执行完毕之后就会被销毁。但在JavaScript中，if语句中的变量声明会将变量添加到当前执行环境中。注意只是当前执行环境，如果for循环是在一个函数里，则定义的i在函数里是确定的数，在全局环境中仍然是not defined。例子： if(true){ var color = \"blue\"; } alert(color) //\"blue\" for(var i=0; i","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"高程","slug":"高程","permalink":"https://millionqw.github.io/tags/高程/"}]},{"title":"第一个hexo博客终于建成","date":"2017-07-02T13:20:13.000Z","path":"2017/07/02/第一个hexo博客终于建成/","text":"折腾了半个下午加半个晚上，终于建成了自己的第一个hexo博客，也是自己的第一个博客ヽ(^･ω･^)丿 从开始接触技术以来，就一直知道技术人员都要有一个自己的博客，接触了两年技术，学习过程中也有把知识记录下来的习惯，但是都是记录在印象笔记里，也在博客园开过一个博客，但一直都没在那里动过笔，大概就是等一个用Hexo博客的机会吧，如果我早在博客园写日记，估计就懒得搬过来了。 虽然hexo的SEO并不好（看到别人的博客都是在简书上转过来的），但是有了博客就有了一个精神角落，放自己的技术，也督促自己记录下学到的东西吧。 第一篇博文，就记录一下自己是怎么搭建这个博客的吧！ 真的想动手搭博客是6月以来看到github上一些大神的博客，看到他们的博客都好漂亮，后来才知道是用hexo搭起来的（之前一直觉得“自己的博客”应该是从html到css都是自己写的），后来也看了一些搭hexo博客的文章，终于在6月底考完试后开始在今天做自己的博客。 首先，是阅读了 @代码咖啡 在简述上发的这篇 20分钟教你使用hexo搭建github博客 文章非常浅显易懂，这里在这篇文章的基础上补上一些我遇到的问题和我是怎么解决的： 文章中的一个步骤： 这里的终端（terminal）指的是git这个版本控制系统，需要下载在电脑中，具体的使用教程看廖雪峰大大的教程，但是在搭博客过程中我们知道怎么安装就好，然后把git bash当命令行用。文章中的命令行都是在git bash输入的。 后面的node.js和hexo的安装因为自己有学一点点node的知识所以够用，不懂的可以留言，我可以帮助你解决问题！ 还有一个是初始化博客后博客文件夹的数量会与作者的不一样，貌似会少一两个，不过不要紧接着进行。 后面的 最后的timezone不要因为你不是上海的就改成你当地的地名，根据标准，中国区只能写Asia/Shanghai、Asia/Hongkong、Asia/Taipei、Asia/Harbin. 之后@代码咖啡 又发了一篇博文 【干货】2个小时教你hexo博客添加评论、打赏、RSS等功能 是对hexo博客扩展功能的补充，他使用的博客主题是NexT，所以就这个主题做了介绍。 我使用的是yilia这个主题，似乎很多人用的都是这个类似的主题，非常受欢迎，github上有3.6k+个star。使用的时候要对配置进行一些修改。 注意在README里说到的配置_config.yml是配置themes/yilia下的_config.yml，不是根目录下的_config.yml。可以在主题里的_config.yml加上你的微博，github，知乎等链接，如果没有的，可以使用#井号注释掉。 另外当你使用这个主题的时候，点开左侧边栏的”所有文章/关于我”，打开的侧边栏会提示缺少模块，按提示下载模块后在主目录下的_config.yml配置给出的那一段配置即可，注意缩进，_config.yml的配置如果缩进错误是不生效的。 使用博客中出现的问题及解决办法 刚开始用这个主题的时候是没有头像的，一开始把图片放在source的img下用相对路径引入发现没有效果，后来用的是微博的图床，一些人似乎用了图床后也显示不出来，解决方法参考:解决头像的问题 当你更新了themes下的_config.yml且git pull后用了hexo clean hexo g //产生静态内容 hexo d //发布到github 仍然没有反应的时候，不要急，确认自己的配置无误的话，只要多刷新几遍即可，应该是网络原因造成的更新延迟。几秒后更改就会生效 我出现的问题是头像可以显示，但是样式不好看： 用F12修改了一下样式，参考了上一个问题的解决方法，在themes\\yilia\\layout_partial下找到left-col.ejs文件，在第6行中的 &lt;a href=&quot;/&quot; class=&quot;profilepic&quot;&gt; &lt;img src=&quot;&lt;%=theme.avatar%&gt;&quot; class=&quot;js-avatar&quot;&gt; &lt;/a&gt; 在img标签里添加一行行内样式： style=”position:absolute; left:-30%; top:-5%; max-width:150%; left和top的值根据你自己的图片位置调整。 如果在移动端上头像的显示仍然不理想，可以在themes\\yilia\\layout_partial下找到mobile-nav.ejs文件，在第十行&lt;img src=&quot;&lt;%=theme.avatar%&gt;&quot; class=&quot;js-avatar&quot;&gt;中添加一句style=”min-width:130%;”即可，具体数值仍然根据自己的情况调整。 几个常用的hexo命令 防止忘了又要百度，把几个命令记下来。 新建文章 hexo new \"文章标题\" 清除缓存、生成静态文件、发布 hexo clean hexo g hexo d 修改主题配置后更新 cd themes/yilia git pull 要总结的似乎就这些，接下来计划把上个寒假花了10几天写的《Javascript高级程序设计》笔记搬到上面来，可以的话，一天整理一篇。同时回顾学过的东西，再添加修改原有的笔记。最后，晚安~","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"生活","slug":"生活","permalink":"https://millionqw.github.io/tags/生活/"}]},{"title":"文章标题","date":"2017-07-02T08:20:23.000Z","path":"2017/07/02/文章标题/","text":"你好，欢迎来到我的个人技术博客。","tags":[]}]