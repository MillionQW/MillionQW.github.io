[{"title":"《JavaScript高级程序设计》第六章 面向对象的程序设计","date":"2017-11-11T05:06:25.000Z","path":"2017/11/11/《JavaScript高级程序设计》第六章-面向对象的程序设计/","text":"目录6.1理解对象6.1.1属性类型（对象有两种属性：数据属性和访问器属性） 1.数据属性（[ [Configurable] ]、[ [Enumerable] ]、[ [Writable] ]、[ [Value] ] ；修改默认特性的方法） 2.访问器属性（[ [Configurable] ] 、[ [Enumerable] ] 、[ [Get] ] 、[ [Set] ]；Object.defineProperty（）修改属性特性 ）6.1.2定义多个属性（Object.defineProperties（）方法修改多个属性特性）6.1.3读取属性的特性（Object.getOwnPropertyDescriptor（））6.2创建对象6.2.1工厂模式（缺点是没解决对象识别问题）6.2.2构造函数模式（缺点是每实例化一个对象就要重写一次方法；实例的constructor属性）1将构造函数当作函数（把构造函数当构造函数用和当普通函数用，函数里的方法的作用环境对象不同）2构造函数的问题6.2.3原型模式（prototype属性、原型对象的constructor属性；实例的[[Prototype]]属性；isPrototypeOf（）、getPrototypeOf（）、hasOwnProperty（）） 1.理解原型对象2.原型与in操作符（in操作符、for-in循环、getOwnPropertyNames（）、keys（））3.更简单的原型语法（用对象字面量法重写原型属性）4原型的动态性（对象字面量修改法要放在使用实例的前面，否则修改在旧实例下无效）5.原生对象的原型（原生对象的方法都是写在原生对象的原型里的）6.原型对象的问题（属性是引用类型值的时候，修改结果也会被共享）6.2.4组合使用构造函数模式和原型模式（属性写在构造函数，方法写在原型）6.2.5动态原型模式6.2.6寄生构造函数模式（存在无法对象识别的问题）6.2.7稳妥构造函数模式（问题同上）6.3继承（JavaScript只有实现继承）6.3.1原型链（利用实例内部指向超类型原型对象的指针[[Prototype]]实现继承）1.别忘记默认的原型（Object是所有函数的默认原型）2.确定原型和实例的关系（使用instanceof操作符和isPrototypeOf（）方法确定原型和实例的关系）3.谨慎地定义方法（子类添加或改写超类型方法的代码一定要写在替换原型的语句之后；对象字面量法重写原型链会导致继承关系断裂）4原型链的问题（还是引用类型值放在原型属性中的问题）6.3.2借用构造函数（有缺陷的方法）1.传递参数2.借用构造函数的问题（还是方法无法复用的问题）6.3.3组合继承6.3.4原型式继承（create（）就是实现原型式继承的方法）6.3.5寄生式继承 首先要知道的：ECMAScript中没有类这个概念。ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值，对象或者函数。”每个对象都是基于一个引用类型创建的，这个引用类型可以是第五章讨论的原生类型（Array，Object，Function等），也可以是开发人员定义的类型。6.1理解对象这节就是告诉我们定义对象的时候不要用Object的构造函数那种方法，直接用对象字面量创建对象更好。例子：var person = { name:&quot;Nicholas&quot;, age:29, job:&quot;Software Engineer&quot;, sayName:function(){ console.log(this.name); }};6.1.1属性类型ECMAScript的对象中有两种不同的属性：数据属性和访问器属性。ECMA-262第5版在定义只有内部才有的特性（attribute）时，描述了属性（property）的各种特征。ECMA-262定义特性是为了实现JavaScript引擎用的，所以在JavaScript中无法直接访问特性。为了表示特性是内部值，该规范把他们放在了两对方括号中。例如[[Enumerable]]（[[特性]]）1.数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值（这两句还不懂）。数据属性有4个描述其行为的特性：·[ [Configurable] ]：表示能否通过delete删除属性，能否修改属性的特性，能否把属性从数据属性修改为访问器属性。直接在对象上定义的属性，[ [Configurable] ]的默认值一般为true。·[ [Enumerable] ]：表示能否通过for - in循环返回属性。直接在对象上定义的属性，[ [Enumerable] ] 的默认值一般为true。·[ [Writable] ]：表示该属性是否可写（属性值能不能修改）。直接在对象上定义的属性，[ [Writable ] ] 的默认值一般为true。·[ [Value] ]：包含这个属性的数据值，读取属性值的时候，就是在这个位置读。写入属性值的时候，新值就保存在这个位置。这个特性的默认值为undefined。例子：var person = { name:&quot;Nicholas&quot;,};这里创建了一个名为name的属性，为它指定的值是“Nicholas”。也就是说，[[value]]特性将被设定为“Nicholas”，而对这个值的任何修改都将反映在这个位置。name属性的[Configurable] ]，[ [Writable] ]，[ [Enumerable] ]都默认为true。要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty（）方法。这个方法接收三个参数：属性所在的对象、属性的名字、一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable、value中的其中一个或多个。例子：var person = {};Object.defineProperty(person,&quot;name&quot;,{ writable:false, value:&quot;Nicholas&quot; //利用Object.defineProperty给属性name赋值，顺便设置了这个本来没有的属性});console.log(person.name); //&quot;Nicholas&quot;person.name = &quot;Greg&quot;;console.log(person.name); //&quot;Nicholas&quot;这里例子创建了一个名为name的属性，设置name属性的[ [Writable] ]为不可写。如果尝试为它指定新值，在非严格模式下，赋值操作被忽略，在严格模式下，赋值操作将会导致抛出错误。类似的“非忽严错”的规则也适用于把[ [Configurable] ]设置为false的属性：var person = {};Object.defineProperty(person,&quot;name&quot;,{ configurable:false, value:&quot;Nicholas&quot;});console.log(person.name); //&quot;Nicholas&quot;delete person.nameconsole.log(person.name); //&quot;Nicholas&quot;configurable被设置为false，则无法从对象中删除属性，若进行删除操作，则会“非忽严错”。注意：一旦把属性定义为不可配置的，就不能把它变回可配置的了（有意思）。此时，再调用Object.defineProperty（）方法修改特性，就会抛出错误。注意：在调用Object.defineProperty（）修改属性的特性时，如果不指定，则configurable、enumerable、writable的默认值就会变成false！属性就会自动变成不可配置，不能通过for - in循环返回属性。所以设置的时候最好四个都写上去。不过作者说，在多数情况下，没有必要利用到Object.defineProperty（）。不过，理解这些概念对理解JavaScript对象非常有用。✎IE8是第一个实现Object.defineProperty（）的浏览器版本，但是仍然存在限制，实现不完全。建议不要在IE8上使用这个方法。2.访问器属性需要使用getter和setter函数才能读写的属性。（但是这两个函数都不是必需的）。在读取访问器属性时，会调用getter函数，在写入访问器属性时，会调用setter函数并传入新值。访问器属性有4个特性：·[ [Configurable] ]：表示能否通过delete删除属性，能否修改属性的特性，能否把属性从数据属性修改为访问器属性。直接在对象上定义的属性，[ [Configurable] ]的默认值一般为true。·[ [Enumerable] ]：表示能否通过for - in循环返回属性。直接在对象上定义的属性，[ [Enumerable] ] 的默认值一般为true。·[ [Get] ]：在读取属性时调用的函数。默认值为undefined。·[ [Set] ]：在写入属性时调用的函数。默认值为undefined。访问器属性不能直接定义，必须使用Object.defineProperty（）定义。例子：var book = { _year:2004, edition:1};Object.defineProperty(book,&quot;year&quot;,{ get:function(){ return this._year; }, set:function(newValue){ if(newValue&gt;2004){ this._year = newValue; this.edition += newValue-2004; } }});book.year = 2005;console.log(book.edition); // 2以上代码创建了一个book对象，并给它定义两个默认的属性：_year和edition。_year前面的下划线是一种常用的人为规定的记号（没有程序上的作用），用于表示只能通过对象方法访问的属性（亲测console.log(book._year)可以访问到，大概是因为有用到对象方法访问）。注意这个_year属性并不是访问器属性。访问器属性是year。year包含一个getter函数和setter函数。getter函数返回_year的值，setter函数通过计算来确定正确的版本。因此，把year属性修改为2005会导致_year变成2005（setter属性set的属性不仅是自己的，还可以是同一对象下的其他属性）。而edition变为2。这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。支持ECMAScript5的这两个方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。在这个方法之前，要创建访问器，一般都使用两个非标准的方法：defineGetter（）和defineSetter（）。这两个方法最初都是由Firefox引入的，后来Safari 3、Chrome 1和Opera 9.5也给出了相同的实现。使用这两个遗留的方法，可以像下面这样重写前面的例子：var book = { _year:2004, edition:1};book.defineGetter(&quot;year&quot;,function(){ return this._year;});book.defineSetter(&quot;year&quot;,function(newValue){ if(newValue&gt;2004){ this._year = newValue; this.edition += newValue-2004; }});book.year = 2005;console.log(book.edition);console.log(book.year); // 2在不支持Object.defineProperty（）方法的浏览器中不能修改[ [Configurable] ]和[ [Enumerable] ]特性。6.1.2定义多个属性由于为对象定义多个属性的可能性很大，ECMAScript5又定义了一个Object.defineProperties（）方法。利用这个方法可以一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加或修改属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。例子：var book1 = {};object.defineProperties(book,{ _year:{ writable:true, value:2004 }, edition:{ writable:true, value:1 }, year:{ get:function(){ return this._year; }, set:function(){ if(newValue &gt; 2004){ if(newValue &gt; 2004){ this._year = newValue; this.edition += newValue -2004; } } } }});支持Object.defineProperties（） 方法的浏览器有：IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。 6.1.3读取属性的特性使用ECMAScript5的Object.getOwnPropertyDescriptor（）方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象。是访问器属性就有访问器属性的四个特性，是数据属性就有数据属性的四个特性。例如上面的book对象为例子：console.log(Object.getOwnPropertyDescriptor(book,&quot;_year&quot;));//返回：Object {value: 2004, writable: true, enumerable: true, configurable: true}console.log(Object.getOwnPropertyDescriptor(book,&quot;year&quot;));//返回：Object {enumerable: false, configurable: false} 很奇怪set和get特性要通过Object.getOwnPropertyDescriptor(book,&quot;year&quot;).get和~.set去得到里面set和get里面的函数。在JavaScript中，可以针对任何对象——包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor（）方法。支持这个方法的浏览器有：IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。6.2创建对象为了不写重复代码讨论了很多创建对象的方法。6.2.1工厂模式工厂模式是软件工程领域广为人知的设计模式，这种模式抽象了创建具体对象的过程（把创建对象的过程抽象简化）。因为在ECMAScript中没有类，开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节。例子：function createPerson(name,age,job){ var o = new Object(); //显式地创建对象 o.name = name; o.age = age; o.job = job; o.sayName = function(){ console.log(this.name) }; return 0; //有return语句，不知道有什么不好}var person = createPerson(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);工厂模式解决了创建多个相似对象要写重复代码的问题，但没有解决对象识别的问题（即怎样知道一个对象的类型，后面的由Person对象实例化的对象的类型就是Person类型而不是Object类型，解决了对象识别问题）。随着JavaScript的发展，又一个模式出现了。6.2.2构造函数模式前面几章说过，ECMAScript中的构造函数可以用来创建特定类型的对象（？说过？还不知道原来特定类型的对象可以自己定义，比如后面的Person对象）。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如，可以使用构造函数模式将前面的例子重写如下：function Person(name,age,job){ //构造函数首字母大写，普通函数首字母小写 this.name = name; this.age = age; this.job = job; this.sayName = function(){ console.log(this.name); };}var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);console.log(person1.name);在这个例子中，Person（）与createPerson（）的不同之处在于：没有显式地调用对象，直接将属性和方法赋给了this对象，没有return语句。✎注意：遵照其他OO语言的惯例，构造函数始终都以大写字母开头，非构造函数用小写字母开头。目的是为了区别于ECMAScript中的其他函数。要创建Person对象的实例，必须使用new操作符。以这种方式调用构造函数会经历以下4个步骤：（1）创建一个新对象；（2）将构造函数的作用域赋给新对象（环境变量对象就变成了这个对象，因此this就指向了这个对象）；（3）执行构造函数中的代码（为这个新对象添加属性）；（4）返回新对象。（对象实例诞生！）在前面例子的最后，person1和person2分别保存着Perso的一个不同的实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person（亲测console.log(person1.constructor)打印出了整个构造函数Person的源代码）。例子：console.log(person1.constructor == Person); //trueconsole.log(person1.constructor) //打印出上面构造函数Person的源代码对象的constructor属性最初是用来标识对象类型的。但是想要检测对象类型，还是instanceOf操作符更可靠一些。例子中创建的所有对象既是Object的实例，也是Person的实例，这一点可以通过instanceOf（）操作符验证：console.log(person1 instanceof Object); //trueconsole.log(person1 instanceof Person); //true创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式完胜工厂模式的地方。在这个例子中person1和person2之所以同时是Object的实例，是因为所有对象均继承自Object（详细内容稍后讨论）。✎：以这种方式定义的构造函数是定义在Global对象（在浏览器中是window对象）中的。（？？？又说所有对象继承自Object？？？）第八章会详细讨论浏览器对象模型（BOM）1将构造函数当作函数构造函数与其他函数的唯一区别，就在于调用他们的方式不同。但是归根到底构造函数还是函数。任何函数，只要通过new操作符调用，它就可以作为构造函数。而构造函数如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中的Person（）函数，可以用下面的任一方式调用，例子的重点是，体会用构造函数的方式调用和用普通方式调用两种方法，他们的作用域有什么不同：//当作构造函数调用var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);person1.sayName();//作为普通函数调用Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);window.sayName();//作为普通函数在另一个对象的作用域中调用var o = new Object();Person.call(o,&quot;Kristen&quot;,25,&quot;Nurse&quot;);o.sayName();第一种用法是构造函数的经典用法。第二种用普通的函数调用法：属性和方法都添加给了window对象（window.sayName（）正确的过程是，方法内的this总是指向Global对象，在浏览器中就变成了window对象）。第三种是重点：使用call（）在对象o的作用域中调用Person函数，类似在window对象中调用Person，调用后o也拥有 了所有属性和sayName（）方法。2构造函数的问题还是有人挑出了构造函数的问题。构造函数的问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName（）的方法，但那两个方法不是同一个Function的实例，因为他们在不同的对象环境中创建。从逻辑上讲，此时的构造函数可以这样定义：function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.sayName = new Function(&quot;console.log(this.name)&quot;); //与声明函数在逻辑上是等价的}从这个角度来看构造函数，就更容易明白每个Person实例都包含一个不同的Function实例（但他们的用途完全一样，就是显示name属性）（感觉学到了JavaScript不可言传的东西，这两个方法看起来一模一样，但是他们是两个不同的实例，要纠结他们是不同的实例的原因是，这样会产生不同的作用域链和标识符解析）。但创建Function新实例的机制仍然是相同的。因此，不同对象实例上的同名函数是不相等的，即person1的sayName（）不等于person2的sayName（）。以下代码可以证明这点：console.log(person1.sayName == person2.sayName); // false然而，创建两个完成同样任务的Function实例的确没有必要（导致产生不同的作用域链和标识符解析 ）；况且有this对象在，根本不用在执行代码前把函数绑定到每一个要实例的对象上，因此，可以像下面这种“等一下就要被作者推翻的方法”一样，把函数定义转移到构造函数外面来解决这个问题：function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.sayName sayName; //与声明函数在逻辑上是等价的}function sayName(){ console.log(this.name);}不知道这样会不会产生不同的作用域链，但是这样的好处是Function不用实例两次吧，可能是Function的作用域链不会产生两个，但是实例对象的作用域链还是会产生的。亲测console.log(person1.sayName == person2.sayName)返回的是true。证明他们用到的是一样的在全局环境下的sayName（）函数。但是这样又有一个问题，你在全局作用域定义的函数实际上只被某一个对象调用，如果对象需要很多个这样的方法，那不就要定义很多的全局函数吗。如此一来，我们这个自定义的引用类型就没有丝毫封装性可言了（太多函数暴漏在全局作用域中）。好在，我们可以用原型模式解决这个问题。6.2.3原型模式我们创建的每个函数都有一个prototype（原型）属性。这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的对象的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象（刚又说prototype是函数属性，现在又说是那个又构造函数实例出来的对象的原型对象？）使用原型对象的好处是可以让所有对象实例共享他们所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中（相当于对属性和方法设置一个默认值，在没有明确赋值的情况下，属性和方法的值就等于这个默认值）。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var person1 = new Person();person1.sayName();在此，我们将所有属性和sayName（）直接添加到Person的prototype属性中，构造函数变成了空函数。即便如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法，而且这些属性和方法是所有对象实例共享的。换句话说，person1和person2访问的都是同一组属性和同一个sayName（）函数。console.log(person1.sayName == person2.sayName)//true.要理解原型模式的工作原理，必须先理解ECMAcript中原型对象的性质。1.理解原型对象无论什么情况，只要创建了一个新函数，就会根据一组特定的规则（没有详讲）为该函数创建一个prototype属性（所有函数自带prototype属性）。这个属性指向函数的原型对象（前面又说prototype是原型对象现在又说是指向原型对象，大概因为prototype是个指针指向了原型对象，所以也可以说prototype属性是原型对象吧，有点函数名是函数的指针，所以也可以说这个函数是XX函数名，XX函数名是这个函数的意思）。在默认情况下，所有原型对象（暂且说是prototype，因为prototype指向原型对象）都会自动获得一个constructor（构造函数）属性（每个原型对象自带constructor属性），这个属性是一个指向prototype属性所在函数的指针。就拿前面的例子来说，Person.prototype.constructor指向Person这个函数，这个构造函数（也就是说一个函数里的prototype属性里的constructor属性是个指针，指向这个函数自己）。创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性，至于其他方法和属性，则都是从Object继承而来。当调用构造函数创建一个实例后（注意，这里开始讲的是实例，不是原来那个构造函数了），该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262管这个指针叫[[Prototype]]。虽然在JavaScript中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性protp；而在其他浏览器中，[[Prototype]]则是完全不可见的。要明确的一点是，这个连接是在实例与构造函数的原型对象之间，而不是在实例与构造函数之间（即[[Prototype]]指向构造函数的prototype而不是指向构造函数）。以前面的Person构造函数和Person.prototype创建实例的代码为例，图6-1展示了各个对象之间的关系：上图展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。在此Person.prototype指向了原型对象，而原型对象中的constructor属性又指向了Person.prototype。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例——person1和peron2都包含一个内部属性[[Prototype]]，该属性又指向了原型对象（书里这里写的指向Person.prototype，但应该是指向原型对象才对）；换句话说，他们与构造函数没有直接关系（实例与构造函数没有直接关系！？）。此外，要格外注意的是，虽然这两个实例都不包括属性和方法，但我们却可以调用person1.sayName（）。这是通过查找对象属性的过程来实现的。虽然没有标准的方式访问[[Prototype]]（书里说所有实现（即浏览器）都无法访问到[[Prototype]]，但前面已经说了有三个浏览器可以用proto访问，亲测也确实可以），但可以通过isPrototypeOf（）方法来确定对象之间知否存在这种关系。从本质上讲，如果[[Prototype]]指向调用isPrototypeOf（）方法的这个对象（Person.prototype），那么这个方法就返回true。例子：console.log(Person.prototype.isPrototypeOf(person1)); //trueconsole.log(Person.prototype.isPrototypeOf(person2)); //trueperson1，2的原型对象是Person.prototype，所以返回true，也说明person1，2的[[Prototype]]指向Person.prototype。记住[[Prototype]]是实例对象的内部属性，是一个指针。ECMAScript5还增加了一个新方法，叫Object.getPrototypeOf（），在所有支持的实现（浏览器）中，这个方法返回[[Prototype]]的值。例子：console.log(Object.getPrototypeOf(person1)==Person.prototype); //true，相等，可以证明person1的[[Prototype]]是指向Person.prototype的console.log(Object.getPrototypeOf(person1).name); //&quot;Nicholas&quot; Object.getPrototypeOf（）可以用来获取对象原型的属性第一行代码确定了Object.getPrototypeOf（）返回的对象实际就是这个对象的原型（又跟我自己在注释里写的见解不一样）。第二行代码取得对象原型中name属性的值，即“Nicholas”。使用Object.getPrototypeOf（）可以方便地取得一个对象的原型（prototype）。而这在利用原型实现继承的情况下是非常重要的。支持这个方法的浏览器有： IE9+、Firefox 3.5+、Safari 5+、Opera 12+和Chrome。知道了构造函数有prototype属性之后，我们可以知道，当代码读取某个对象的某个属性时，都会执行一次搜索，目的是找到具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性值；如果没有找到，就继续搜索指针（[[Prototype]]）指向的原型对象（prototype），在原型对象中查找具有给定名字的属性，如果在原型对象中找到这个属性，就返回这个属性的值。所以我们在调用实例对象的属性和方法时会执行两次搜索。这正是多个对象实例共享原型对象所保存的属性和方法的基本原理。✎：前面提到过，原型对象最初只包含一个constructor属性，这个属性也是共享的，可以通过对象实例访问。（亲测访问这个属性会返回构造函数的源代码，之前亲测过了？）虽然我们可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加一个与原型对象中存在的同名属性，则我们就在实例中创建该属性。该属性会屏蔽掉原型中那个属性。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var person1 = new Person();var person2 = new Person();person1.name=&quot;Mike&quot;person1.sayName(); //“Mike” ←来自实例person1.sayName(); //&quot;Niicholas&quot; ←来自原型当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性（书中对“屏蔽”两个字黑体加粗，但是我觉得屏蔽的原理估计又有一大篇文章要讲）。如果把实例中的属性设置为null，也只会在实例中设置这个属性，无法恢复其指向原型的连接。要恢复其指向原型的连接，方法就是使用delete操作符完全删除实例属性，从而我们就可以重新访问原型中的属性。例子：person1.name = &quot;Mike&quot;;person1.name = null;person1.sayName(); //nulldelete person1.name person1.sayName(); //&quot;Nicholas&quot;使用hasOwnProperty（）（注意是Property不是prototype了，property是属性的意思）方法可以检测一个属性是存在实例中，还是原型中。这个方法（不要忘了这个方法继承自Object）在检测的属性是存在实例中的时候，返回true。例子：var person1 = new Person();person1.name=&quot;Mike&quot;delete person1.name;console.log(person1.hasOwnProperty(&quot;name&quot;)); //false，把第三行注释掉就变成true通过hasOwnProperty（）方法，我们访问属性的时候到底访问的是原型对象中的属性还是实例重新定义的属性就一清二楚了。（做了有趣的实验，把实例中的属性保存为跟原型对象属性一样的值，用hasOwnProperty（）方法返回的是true。可不可以说明他们存放的空间不一样？）person1.name=&quot;Nicholas&quot; 与原型对象中的属性值相同console.log(person1.hasOwnProperty(&quot;name&quot;)); //true✎：ECMAScript5的Object.getOwnPropertyDescriptor（）方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用Object.getOwnPropertyDescroptor（）方法。原来前面已经讲过这个方法竟然忘了。不知道什么是属性的描述符，测试了一次发现返回的是对象的属性的四个特性：console.log(Object.getOwnPropertyDescriptor(person1,&quot;name&quot;));//Object {value: &quot;Nicholas&quot;, writable: true, enumerable: true, configurable: true}注意上面的那句话啊！！！每个词都是关键啊！上面说要在原型对象上调用，不是直接用构造函数名调用啊，用构造函数名调用很奇怪，console.log(Object.getOwnPropertyDescriptor(person1,&quot;name&quot;));返回的描述符中的value是“Person”，第二个参数改成“job”或“age”返回的却是undefined。用console.log(Object.getOwnPropertyDescriptor(Person.prototype,&quot;name&quot;));就能返回value是“Nicholas”的描述符。例子：console.log(Object.getOwnPropertyDescriptor(Person,&quot;job&quot;)); //undefinedconsole.log(Object.getOwnPropertyDescriptor(Person,&quot;name&quot;)); //Object {value: &quot;Person&quot;, writable: false, enumerable: false, configurable: true}console.log(Object.getOwnPropertyDescriptor(Person.prototype,&quot;name&quot;));//Object {value: &quot;Nicholas&quot;, writable: true, enumerable: true, configurable: true}后来又继续测试console.log(Person.name);返回的也是“Person”，难道name是每个函数都有的属性返回函数的函数名？2.原型与 in 操作符in操作符的使用有两种方式，一种是单独使用和在for - in循环中使用。在单独使用时，in操作符用于判断某一属性是否在对象中，无论是在实例中还是原型中，只要有就返回true。例子：console.log(&quot;name&quot; in person1) //true 无论name是在实例中还是原型中console.log(&quot;name&quot; in Person) //顺便做了个实验，name属性确实在Person构造函数中console.log(&quot;name&quot; in Person) //false这让我想到一个问题，Person已经有一个name属性的值是“Person”，我们又通过原型对象给原型对象中添加了name属性的值是Nicholas，那值为“Person”的name属性又是来自哪里？？做了个实验，创建一个叫zoo的空函数：function zoo(){}console.log(&quot;name&quot; in zoo); //truein操作符判断后也是返回true，这个name不在原型对象中，也不在实例中，仍然返回true，这个name到底是放在哪？有意思。又做了好多实验，发现用函数声明，函数表达式创建出来的函数都有name属性，但是把这个自定义的函数当构造函数用，实例出来的对象就没有这个name属性。所以还是只有函数有咯。用Object（）构造函数实例的对象也没有name属性。利用 in操作符，结合hasOwnProperty（）方法，我们可以创建一个函数来判断一个属性值到底是来自实例还是原型：function hasPrototypeProperty(object,name){ return !object.hasOwnProperty(name)&amp;&amp;(name in object);}这个是书里定义的函数，我觉得有点绕。这个是检测属性是原型属性返回true。是实例中的属性就返回假，跟我想的相反。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var person = new Person();console.log(hasPrototypePerty(person,&quot;name&quot;)) //trueperson.name = &quot;Greg&quot;;console.log(hasPrototypePerty(person,&quot;name&quot;)) //falsefor - in循环的作用，返回的是所有能通过对象访问的，可枚举的（enumerated）属性，其中既包括实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（[[Enumerable]]：false）的实例属性也会在for - in属性中返回（意思是：比如toString（）方法是Object的原生方法，一般这类方法都是不可枚举的，如果你在实例对象中重写了toString（），那toString（）就变成了可枚举的，会在for - in循环中被列出来）。因为根据规定，所有开发人员定义的属性都是可枚举的。但是IE8及更早版本会有BUG，即屏蔽不可枚举属性的实例属性也不会出现在for - in循环中。例如：var o = { toString : function(){ //重写toString（）方法 return &quot;My Object&quot;; }};for(var prop in o){ if(prop == &quot;toString&quot;){ console.log(&quot;Found String&quot;); //IE8中不会显示 }}上面的例子，本来我已经改写了toString（）了，应该是可以被for - in循环枚举出来的，但是在IE8及更早版本并不会被枚举出来。这个BUG会影响默认不可枚举的所有属性和方法，包括：hasOwnProperty（）、propertyIsEnumerable（）、toLocalString（）、toString（）和valueOf（）。ECMAScript5把constructor和property属性的[[Enumerable]]特性设置为false，但并不是所有浏览器都乖乖听ECMAScript的。要想获取对象上所有可枚举的实例属性（实例属性！原型对象中的属性不会被列举出来），可以使用ECMAScript5的Object.keys（）方法，这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var keys = Object.keys(Person.prototype);console.log(keys) //[&quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]var peron1 = new Person();person1.name = &quot;Mike&quot;;console.log(Object.keys(person1)) //[&quot;name&quot;]有什么实例，数组里才有什么属性，property里定义的属性是Person.prototype对象的实例属性，不是person1的实例属性，person1的实例属性只有一个。如果想要得到所有实例属性，无论是否可枚举，可以使用Object.getOwnPropertyNames（）方法。例子：console.log(Object.getOwnPropertyNames(Person.prototype)); //[&quot;constructor&quot;, &quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]person1.age=28;Object.defineProperty(person1,&quot;name&quot;,{ writable:false, value:&quot;Mike&quot;, enumerable:false}); console.log(Object.keys(person1)); // [&quot;age&quot;]console.log(Object.getOwnPropertyNames(person1)); // [&quot;name&quot;, &quot;age&quot;]还记得前面说的ECMAScript5把constructor（构造函数）属性也设置为不可枚举吗？看来这个浏览器遵循ECMAScript5的规定。Object.keys（）和Object.getOwnPropertyNames（）都可以用来替代for - in循环。支持这两个方法的浏览器有：IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。记住他们返回的都是实例属性，不包括原型对象中的属性。3.更简单的原型语法作者介绍给我们，前面的每添加一个原型属性就要敲一遍Person.prototype的方法太傻了，为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。例子：function Person(){}Person.prototype = { constructor : Person, name : &quot;Nicholas&quot;, age :29, job : &quot;Software Engineer&quot;, sayName : function(){ console.log(this.name); }}理清除，Person.property是指针指向原型对象，所以用对象字面量法给原型对象添加属性和方法是没毛病的。但是这种写法本质上重写了Person.prototype对象，而每个prototype属性都自带有constructor属性，如果在重写中没有加入constructor属性，为constructor重新赋值，则constructor属性将从原型对象中消失。说消失是不准确的，这时候原型对象的constructor属性不再指向Person构造函数，而是指向Object构造函数。但是Person对象的实例仍然是Person的实例。下面的例子假设重写时没有加入constructor属性：console.log(friend instanceof Object); //trueconsole.log(friend instanceof Person); //trueconsole.log(friend.constructor == Person); //falseconsole.log(friend.constructor == Object); //true还有一点要注意的是，重写之后的constructor属性，它的[[Enumerable]]特性会被设置为true（当然是在ECMAScript5已经规定了constructor属性的[[Enumerable]]特性 默认为false且浏览器听它的的情况下）。如果想让它重新变为false，可以人工用Object.defineProperty（）方法设置。4.原型的动态性由于在原型中查找值是一次搜索，所以即使先创建实例后修改原型也是可以的。例子：var friend = new Person();Person.prototype.sayHi = function(){ console.log(&quot;Hi&quot;);};friend.sayHi(); //&quot;Hi&quot; （正常运行）可以看到我们先实例化了Person对象为friend，再修改Person的原型对象。firend仍然能访问到sayHi（）方法。其原因可以归结为实例与原型之间的松散连接关系。因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的sayHi属性并返回保存在那里的函数。尽管可以随时为原型添加属性和方法，但如果是重写整个原型对象，情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototyoe]]指针，而把原型重写为另外一个对象就等于切断了构造函数与最初原型之间的联系（从书中关系图来看，最初原型（旧原型对象）仍指向构造函数，但是构造函数指向了新的原型对象，所以也不是完全切断吧）。作者写到这里突然要我们记住：实例中的指针仅指向原型，不指向构造函数（实例与构造函数之间没有联系）例子：function Person(){}var friend = new Person();Person.prototype = { constructor : Person, name : &quot;Nicholas&quot;, age :29, job : &quot;Software Engineer&quot;, sayName : function(){ console.log(this.name); }};friend.sayName(); //报错： friend.sayName is not a function在这个例子中，我们先创建了一个Person对象，先实例化出一个friend，再重写了原型对象。然后在调用friend.sayName（）的时候就出现了错误。因为friend指向的原型是旧原型，不包含以该名字命名的属性。图6-3展示了这个过程。可以看到重写原型对象会切断现有原型与任何之前已经存在的对象实例之间的关系；之前已经存在的对象实例 仍然引用的是最初的原型。也就是说用重写原型的方式给原型对象添加属性的方法要在重写的那段代码之后再实例化对象，如果是用Person.prototype.属性 = XX这种方法则不存在这种问题。5.原生对象的原型这节讲的是原生对象的原型，什么是原生对象？就是原生的引用类型（Array，Object，String and so on）所有原生引用类型都在其构造函数的原型上（注意原型是谁的属性（prototype是个属性，这个属性是个指针），是构造函数的属性）定义了方法。例如Array类型的sort（）方法就是定义在Array.prototype中的。String类型的substring（）方法就是定义在String.prototype中的。证明例子：console.log(typeof Array.prototype.sort); //functionconsole.log(typeof String.prototype.substring); //functionconsole.log(typeof Array.sort); //undefinedtypeof Array.sort竟然是undefined是令我惊讶的，我以为后台会自动规定sort是Array的方法（所以以前的每次array.sort( )的调用都是在调用Array对象的原型对象中的方法，向Array.prototype致敬！）通过原生对象的原型，不仅可以取得所有默认方法的引用，而且可以定义新方法，可以像修改自定义对象的原型一样修改原生对象的原型，在里面添加新的方法。亲测可以改写原本已经定义的方法，比如toString（）这些。但是不要这样做。书中给出了在原生对象的原型中添加方法的例子，但是他建议不哟这样做，避免命名冲突。就不举例了。6.原型对象的问题原型对象也是有问题的（不能说BUG，合情合理）。原型对象的好处是可以共享属性，但最大的问题也处在了共享的问题上，属性的值是基本类型值还好，如果是包含引用类型的属性，就会出问题了：function Car(){}Car.prototype={ constructor:Car, friends:[&quot;Shelby&quot;,&quot;Court&quot;]}var car1 = new Car();var car2 = new Car();car1.friends.push(&quot;Van&quot;);console.log(car1.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]console.log(car2.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]本来只是像给实例对象car1的friends属性中的数组加入“Van”而已，但是最后car2也有了。因为car1并没有自己重写friends属性，而是直接在默认有的属性值中添加数据，而这个数组是保存在Person.prototype中的，所以刚刚提到的修改也会通过person2.friends反映出来。所以很少有人单独使用原型模式。6.2.4组合使用构造函数模式和原型模式创建自定义类型的最常见方式，是组合使用构造函数模式和原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。这样，每个实例都有自己的一份实例属性的副本（不懂这个实例属性的副本是什么意思），但同时共享对方法的引用，最大限度地节省了内存。重写前面的代码的例子：function Person(name,age,job){ //通过对构造函数传参给独特的属性赋值 this.name = name; this.age = age; this.job = job; this.friends = [&quot;Shelby&quot;,&quot;Court&quot;]; //引用类型写在构造函数中}Person.prototype = { constructor:Person, //别忘了重写constructor属性 sayName:function(){ //一样的方法可以共用 console.log(this.name); }}var person3 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);var person4 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);person3.friends.push(&quot;Van&quot;);console.log(person3.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]console.log(person4.friends); //[&quot;Shelby&quot;, &quot;Court&quot;]console.log(person3.friends == person4.friends); //falseconsole.log(person3.sayName == person4.sayName); //true这种构造函数与原型混成的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。后面几节讲的都是定义引用类型的几种方法，既然说上面的是最好用的，后面的就不写了。6.2.5动态原型模式为看不惯上面的写法的有其他OO语言开发人员使用的方法。6.2.6寄生构造函数模式作者不推荐这种方法，因为这个方法返回的对象与构造函数或者与构造函数的原型属性之间没有关系。也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。也就是说假设用创建了一个Person构造函数，用这个构造函数实例出来的对象并不属于Person，而是属于Object。6.2.7稳妥构造函数模式这个方法也是创建的对象与构造函数之间没有什么关系。6.3继承许多OO语言都支持两个继承方式：接口继承和实现继承。接口继承只继承方法签名。而实现继承则继承实际的方法。如前面章节讲过的，由于函数没有签名（函数没有“函数名”只是一个指针，所以叫没有签名？），在ECMAScript中无法实现接口继承。实现继承主要是依靠原型链实现的。6.3.1原型链ECMAScript中描述了原型链的概念。并将原型链作为实现继承的主要方法。其基本思想是：利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型链实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针（constructor），而实例都包含一个指向原型对象的内部指针（[[Prototype]]）。那么，如果我们让原型对象等于另一个类型的实例，会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针。相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条，这就是所谓原型链的基本概念。实现原型链的基本模式如下：function SuperType(){ this.property = true; //定义的变量名有点复杂，看得有点晕，其实就是一个值为true的变量}SuperType.prototype.getSuperValue = function(){ return this.property;};function SubType(){ this.subproperty = false; //另一个false的变量}//继承了SuperTypeSubType.prototype = new SuperType(); //让一个构造函数A的原型等于另一个构造函数B的实例，这个实例又有一个指向B的原型的指针SubType.prototype.getSubValue = function(){ //这里看得有点懵，其实就是给子对象的原型定义了一个方法，跟上面的代码无关，也没用上 return this.subproperty;}var instance = new SubType(); //创建子对象的实例console.log(instance.getSuperValue()); //true 发现子对象的实例可以调用父对象的方法，返回保存在父对象的变量以上代码定义了两个类型：SuperType和SubType。每个类型各有一个属性一个方法。他们的区别是SubType继承了SuperType。继承的步骤是：通过创建SuperType的实例（new SupperType），并将该实例赋给了SubType.prototype实现。实现的本质是重写原型对象，给原型对象赋值为一个新类型的实例（所以SubType.prototype里的constructor属性也改变了，不是没有了，变成了新类型实例里指向父构造函数的constructor属性，此时constructor为SuperType）。换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了。在确定了继承关系后，我们又不知道有什么卵用地给SubType.prototype添加了一个方法。这样就在继承了SuperType的实例的属性和方法后，又有了自己的方法。这个例子中的实例以及构造函数和原型之间的关系如图：在代码中，我们没有使用SubType默认提供的原型，而是把它重写成了一个新原型，这个新原型就是SuperType的实例。于是，新原型不仅具有作为一个SuperType的实例所拥有的全部属性和方法，而且内部还有一个指针（[[Prototype]]，通了，一开始觉得叫[[Prototype]] 不恰当，想明白了根本不会！因为这个[[Prototype]]属性本来就是SuperType实例中有的），指向SuperType的原型。结果就是这样：instance的[[Prototype]]指向SubType的原型，SubType的原型里的[[Prototype]]又指向SuperType的原型。注意：getSuperValue（）方法仍然还在SuperType.prototype里，SubType.prototype里没有，但property则在SubType.prototype中。书中的解释是：因为property是一个实例属性，而getSuperValue（）是一个原型方法（实例属性会跟着继承在子对象中，原型方法仍然留在父对象的原型中）。解释：既然SubType.prototype现在是SuperType的实例，那么property当然位于实例中了，而getSuperValue（）是在原型中，不在实例中。此外，要注意instance.constructor现在指向的是SuperType，这是因为原来Subtype的原型指向了另一个对象SuperType 的实例，这个实例指向了对象SuperType的原型，SuperType的原型里的constructor属性就是指向SuperType。（书里这样写，可是为什么instance会有constructor属性？constructor不是原型对象才有吗？亲测每个实例都有这个属性，返回这个实例的构造函数。字符串类型的constructor返回到是String（）构造函数）通过原型链的介绍，原型搜索机制又要重新扩展：当以读取模式访问一个实例属性时，首先会在实例中搜索该属性，如果没有找到该属性，就继续搜索实例的原型，在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用instance.getSuperValue（）会经历三个搜索步骤：1）搜索实例；2）搜索SubType.prototype；3）搜索SuperType.prototype，最后一步找到这个方法。搜索过程总是这样一环一环地走到原型链末端才停下来。1.别忘记默认的原型事实上，前面例子中展示的原型链少了一环。我们知道，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是Object的实例（new Object( )），因此默认原型都会包含一个内部指针，指向Object.prototype（又不说这个指针的名字）。这也正是所有自定义类型都会继承toString（）等默认方法的原因（上面讲原型对象的时候说过，原生引用类型的方法都是定义在prototype上的）。所以所有函数的toString（）等默认方法不是在他们自己的prototype属性中，而是通过指针，一层层地找到那些放在Object.prototype里的原型方法的，这样就减少了还能多内存占用吧。所以上面例子展示的原型链中还应包括另外一个继承层次，如图才是真正完整的原型链：2.确定原型和实例的关系可以通过两种方式来确定原型和实例之间的管理，第一种方式使用instanceOf操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。例子：console.log(instance instanceof Object) //trueconsole.log(instance instanceof SubType) //trueconsole.log(instance instanceof SuperType) //true由于原型链的关系，我们可以说instance是Object、SuperType、SubType中任何一个类型的实例。因此三个构造函数的结果都返回true。第二种方式是使用isPrototypeOf（）方法，同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf（）也会返回true:console.log(Object.prototype.isPrototypeOf(instance)); //trueconsole.log(SubType.prototype.isPrototypeOf(instance)); //trueconsole.log(SuperType.prototype.isPrototypeOf(instance)); //true3.谨慎地定义方法子类型有时候会需要覆盖超类型中的某个方法，或者添加超类型中不存在的某个方法。但无论如何，给原型添加方法的代码一定要放在替换原型的语句之后。例子：function SuperType(){ this.property = true;}SuperType.prototype.getSuperValue = function(){ return this.property;};function SubType(){ this.subproperty = false;}//继承了SuperTypeSubType.prototype = new SuperType(); //无论是覆盖还是添加，都要放在替换原型的语句之后//添加新方法SubType.prototype.getSubValue = function(){ return this.subproperty;}//重写超类型中的方法SubType.prototype.getSuperValue = function(){ return false;}var instance = new SubType();console.log(instance.getSuperValue()); //false在上面代码中，加粗部分是两个方法的定义。第一个方法getSubValue（）被添加到了SubType中，第二个方法getSuperValue（）是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的那个方法。换句花说，当通过SubType的实例（instance）调用getSuperValue（）时，调用的是这个重新定义的方法；但通过SuperType的实例调用getSuperValue（）时，还会继续调用原来的那个方法。这里要格外注意的是，必须在用SuperType的实例替换原型之后，再定义这两个方法。从前面的原型链关系图我们知道SuperType的实例调用的是SuperType的原型里的getSuperValue（），SubType的实例一开始是用指针调用SuperType的原型里的getSuperValue（），后来就通过重写在自己的SubType里添加了自己的getSuperValue（）。还有一点要注意到是，在通过原型链实现了继承之后，不能使用对象字面量法重写原型方法，因为这样就重写了原型链，继承就断了。例子：function SuperType(){ this.property = true;}SuperType.prototype.getSuperValue = function(){ return this.property;};function SubType(){ this.subproperty = false;}//继承了SuperTypeSubType.prototype = new SuperType();//使用字面量添加新方法，会导致上一行代码失效SubType.prototype = { getSubValue : function(){ return this.subproperty; }. someOtherMethod : function(){ return this.false; }}var instance = new SubType();console.log(instance.getSuperValue()); //error! 继承关系已断以上代码展示了刚把SuperType的实例赋给Subtype的原型，下面的代码马上就把SubType的原型给重写了，相当于上面的那行赋值被替换了，无效了。相当于现在的原型里包含的是Object的实例（所有函数的默认原型都是Object的实例），而不是SuperType的实例。原型链被切断，SubType和SuperType之间已经没有关系了。4.原型链的问题通过原型链的继承还是存在问题的，就是包含引用类型的那个问题。包含引用类型值的原型属性会被所有实例共享；当其中一个实例修改了原型属性中的引用类型值，整个引用类型值就被修改了。例子：function SuperType(){ this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];}function SubType(){}SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var instance2 = new SubType();console.log(instance2.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]还是引用类型值共享会导致修改类型值会直接修改原型属性里的值的问题。原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数，实际上，应该说是没有办法在不影响所有对象的情况下，给超类型的构造函数传递参数（意思是说不能在SubType.prototype = new SuperType() 给构造函数赋值吗？）。由于前面的两个问题，很少会单独使用原型链。6.3.2借用构造函数为了解决前面的问题，开始人员开始使用一种叫借用构造函数（constructor stealing）的技术（有时候也叫做伪造对象或经典继承）。这种技术的思想相当简单：在子类型构造函数的内部调用超类型的构造函数。别忘了，函数只不过是在特定环境中执行代码的对象。因此，通过使用apply（）和call（）方法也可以在（将来）新创建的对象上执行构造函数。例子：function SuperType(name){ //另一个好处是可以给构造函数赋值 this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; this.name = name;}function SubType(){ //继承了SuperType ，同时传递了参数 SuperType.call(this,&quot;Nicholas&quot;); //不知道这个this有什么用，this不是指向window吗，可能“将来”实例化变成对象之后就指向SubType对象了 this.age = 29}var instance1 = new SubType(); //前面说的将来就是指这个时候，调用了内部的SuperType构造函数instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var instance2 = new SubType();console.log(instance2.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]console.log(instance1.name) //&quot;Nicholas&quot;console.log(instance1.age) //29代码中加粗那行代码“借调”了超类型的构造函数。通过使用call()方法，我们实际上是在（未来将要）新创建的SubType实例的环境（this指向的是SubType实例的环境 ）下调用SuperType构造函数（不一定有new才能调用构造函数）。这样一来，就会在新SubType对象上执行SuperType（）函数中定义的所有对象初始化代码。结果SubType的每个实例都会有自己的colors属性的副本了。但是这种方式并没有使用到SubType.prototype哦。1.传递参数传递参数的例子被我写在上面一起讲了。代码中SuperType接收一个参数name，并在函数内直接给name属性赋值。在SubType构造函数内部调用SuperType构造函数时，实际上是为SubType的实例设置了name的默认属性，虽然这个默认属性不在prototype上。为了确保SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。2.借用构造函数的问题如果只使用借用构造函数，那么也将出现构造函数模式出现的问题——方法都在构造函数中，每实例一个对象就重新复制了一份函数中的方法，影响性能。因此函数的复用就无从谈起。而且，在超类型中定义的方法，对子类型而言是不可见的，结果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数技术也很少使用。6.3.3组合继承组合继承（combination inheritance）有时候也叫伪经典继承。指的是将原型链和借用构造函数的技术组合到一块。背后的思路是：是哦那个原型链实现对原型属性和方法的继承、而通过借用构造函数来实现对实例的继承。例子：function SuperType(name){ this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; //属性写进构造函数里 this.name = name;}SuperType.prototype.sayName = function(){ console.log(this.name);};function SubType(name){ //继承属性 SuperType.call(this,name); ] this.age = age;}//继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType; //如果没有这一步，SubType的原型里concerned属性就是指向SuperTypeSubType.prototype.sayAge = function(){ //方法写进原型里 console.log(this.age);}var instance1 = new SubType(&quot;Nicholas&quot;,29); instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]instance1.sayName(){}; //&quot;Nicholas&quot;instance1.sayAge(){}; //29var instance2 = new SubType(&quot;Greg&quot;,27);console.log(instance2.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]instance2.sayName(); //&quot;Greg&quot;instance2.sayAge(); //27在例子中，SuperType构造函数定义了两个属性：name和colors。SuperType的原型定义了一个方法sayName（）。SubType构造函数在调用SuperType构造函数时传入了name参数，紧接着又定义了自己的属性age。然后，将SuperType的实例赋值给SubType的原型，然后又在该新原型上定义了方法sayAge（）。这样一来，就可以让两个不同的SubType实例既分别拥有自己的属性——包括colors属性，又可以使用相同的方法了。组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中 n继承模式。而且instanceOf和isPrototypeOf（）也能够用于识别基于组合继承创建的对象。6.3.4原型式继承一个有缺陷的继承方式，但是ECMAScript5为这个方式创建了一个create（）方法，跟原型式继承原理相似。这种方法没有使用严格意义上的构造函数。道格拉斯·克罗克福德（提出者）的想法是：借助原型可以基于已有的对象创建新对象。同时还不必因此创建自定义类型（意思就是那个子构造函数（比如那个SubType构造函数）都不用创建了，下面那个方法的返回值直接赋给一个变量，那个变量就是实例了）。下面就是那个函数：function object(o){ function F(){} F.prototype = o; //这个构造函数的原型等于传进来的那个对象，所以不用创建自定义类型，这个F就相当于那个自定义类型了 return new F(); //返回一个构造函数的实例，赋给一个变量就相当于实现了继承}在Object（）函数内部，先创建了一个临时性的构造函数（F），然后将闯入的对象作为这个构造函数的原型（ F.prototype = o ），最后返回这个临时类型的新实例。从本质上讲，object（）对传入其中的对象执行了一次浅复制。看下面例子：var person = { name:&quot;Nicholas&quot;, friends:[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]};var anotherPerson = object(person); //调用object()，传进去的person相当于超类型anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;); //注意这里给friends数组引用类型值推入一个数据的只是anotherPersonvar yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;); //注意这里第二个子实例yetAnotherPerson也给数组推入一个Barbieconsole.log(person.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;, &quot;Rob&quot;, &quot;Barbie&quot;] //超类型里的数组里也多了Rob和Barbie✎：反正直接在对象字面量里定义值为引用类型值的属性被改写就会GG（一开始打这句话的时候是写“直接在原型里定义值为引用类型值的属性就GG”，想想不对，上面的person是在自己那里定义的引用类型值属性不是在原型里啊。object（）方法返回的是F（）的实例，是F的原型（F.prototype）复制了person的属性哦，所以anotherPerson和yetAnotherPerson对象改的应该是F.prototype里的数组吧，为什么person也会受影响呢？想想，可能是：person对象作为函数参数传入了函数object（），虽然JavaScript是按值传递的，但person是对象，F.prototype = o 相当于F.prototype成了对象person的指针（相当于复制了对象的指针），所以看起来改的是F.prototype，但其实F.prototype里没有这个属性，本质上改的应该是person对象里的属性，况且F在object（）函数执行完后已经被销毁，但anotherPerson和yetAnotherPerson 保存了F的实例，也就保存了F的prototype原型对象）。如果有一个超类型的对象在的话，我们就可以使用object( )函数，把超类型作为参数传入，然后函数就会返回一个新对象。在这个例子中，作为超类型的对象是person对象（注意对象首字母是小写，它的作用不是作为构造函数），把person放入object（）传入函数，返回一个新对象，这个新对象将person作为原型（其实应该说 F 将person作为原型），所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。这意味着person.friend不仅属于person所有，而且也会被anotherPerson和yetAnotherPerson共享。实际上，这就相当于又创建了person对象的两个副本（说副本还是有门道的，是副本不是指针，如果是指针的话，anotherPerson和yetAnotherPerson 修改name属性的话，person也会被改，但亲测并不会，虽然F.prototype是person的指针，但new F（），F的实例不是指针，算了解释不下去了，以前是SubType.portotype = new SuperType（）好歹是别人的实例就一定不是指针，但 F.prototype = o 是指针无疑啊，为什么anotherPerson和yetAnotherPerson 会有自己的name属性呢？）。ECMAScript5通过新Object.create（）方法规范了原型式继承。这个方法接收两个参数：一个用作新对象的父对象和一个为新对象定义额外的属性的对象（可选，意思就是用对象字面量的方法定义新对象的额外属性）。在传入一个参数的情况下，Object.create（）与object（）方法的行为相同。var person = { name:&quot;Nicholas&quot;, friends:[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]};var anotherPerson = Object.create(person);anotherPerson.name = &quot;Greg&quot;; //后面的代码会教不用这样写anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);console.log(person.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;, &quot;Rob&quot;, &quot;Barbie&quot;] 仍然存在的问题Object.create（）的第二个参数与Object.defineProperties（）方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性：var anotherPerson = Object.create(person,{ name:{ value:&quot;Greg&quot; //好麻烦啊这样写 }})console.log(anotherPerson.name) //&quot;Greg&quot;果然用上面的参数格式，其他三个特性不写，全部会由默认true变成默认false:console.log(Object.getOwnPropertyDescriptor(anotherPerson,&quot;name&quot;))//Object {value: &quot;Greg&quot;, writable: false, enumerable: false, configurable: false}console.log(Object.getOwnPropertyDescriptor(yetAnotherPerson,&quot;name&quot;))//Object {value: &quot;Linda&quot;, writable: true, enumerable: true, configurable: true}默认的自定义对象的三个特性都是true，如果用Object.defineProperties（）的格式修改描述符的定义，没有列出来，则默认会被后台修改为false。6.3.5寄生式继承寄生式（parasitic）继承也是克罗克福德提出来的，与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工程模式类似，既创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。Conflicting modification on 2017年2月15日 下午11:36:25:目录6.1理解对象6.1.1属性类型（对象有两种属性：数据属性和访问器属性） 1.数据属性（[ [Configurable] ]、[ [Enumerable] ]、[ [Writable] ]、[ [Value] ] ；修改默认特性的方法） 2.访问器属性（[ [Configurable] ] 、[ [Enumerable] ] 、[ [Get] ] 、[ [Set] ] ）6.1.2定义多个属性（Object.defineProperties( ）用对象字面量的方式传入第二个参数)6.1.3读取属性的特性（Object.getOwnPropertyDsecriptor（）方法）6.2创建对象6.2.1工厂模式（没有解决对象识别问题）6.2.2构造函数模式（每多一个实例就添加很多重复的方法；实例对象的constructor属性；自定义函数是定义在Global对象中的）1.将构造函数当作函数2.构造函数的问题（每个实例上都重新创建了一次方法）6.2.3原型模式1.理解原型对象（prototype属性，prototype里的constructor属性，实例的[[prototype]]属性；isprototypeOf（）；getPrototypeOf（）；hasOwnProperty（）判断是原型属性的值还是有重写）2.原型与in操作符（）首先要知道的：ECMAScript中没有类这个概念。ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值，对象或者函数。”每个对象都是基于一个引用类型创建的，这个引用类型可以是第五章讨论的原生类型（Array，Object，Function等），也可以是开发人员定义的类型。6.1理解对象这节就是告诉我们定义对象的时候不要用Object的构造函数那种方法，直接用对象字面量创建对象更好。例子：var person = { name:&quot;Nicholas&quot;, age:29, job:&quot;Software Engineer&quot;, sayName:function(){ console.log(this.name); }};6.1.1属性类型ECMAScript的对象中有两种不同的属性：数据属性和访问器属性。ECMA-262第5版在定义只有内部才有的特性（attribute）时，描述了属性（property）的各种特征。ECMA-262定义特性是为了实现JavaScript引擎用的，所以在JavaScript中无法直接访问特性。为了表示特性是内部值，该规范把他们放在了两对方括号中。例如[[Enumerable]]（[[特性]]）1.数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值（这两句还不懂）。数据属性有4个描述其行为的特性：·[ [Configurable] ]：表示能否通过delete删除属性，能否修改属性的特性，能否把属性从数据属性修改为访问器属性。直接在对象上定义的属性，[ [Configurable] ]的默认值一般为true。·[ [Enumerable] ]：表示能否通过for - in循环返回属性。直接在对象上定义的属性，[ [Enumerable] ] 的默认值一般为true。·[ [Writable] ]：表示该属性是否可写（属性值能不能修改）。直接在对象上定义的属性，[ [Writable ] ] 的默认值一般为true。·[ [Value] ]：包含这个属性的数据值，读取属性值的时候，就是在这个位置读。写入属性值的时候，新值就保存在这个位置。这个特性的默认值为undefined。例子：var person = { name:&quot;Nicholas&quot;,};这里创建了一个名为name的属性，为它指定的值是“Nicholas”。也就是说，[[value]]特性将被设定为“Nicholas”，而对这个值的任何修改都将反映在这个位置。name属性的[Configurable] ]，[ [Writable] ]，[ [Enumerable] ]都默认为true。要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty（）方法。这个方法接收三个参数：属性所在的对象、属性的名字、一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable、value中的其中一个或多个。例子：var person = {};Object.defineProperty(person,&quot;name&quot;,{ writable:false, value:&quot;Nicholas&quot; //利用Object.defineProperty给属性name赋值，顺便设置了这个本来没有的属性});console.log(person.name); //&quot;Nicholas&quot;person.name = &quot;Greg&quot;;console.log(person.name); //&quot;Nicholas&quot;这里例子创建了一个名为name的属性，设置name属性的[ [Writable] ]为不可写。如果尝试为它指定新值，在非严格模式下，赋值操作被忽略，在严格模式下，赋值操作将会导致抛出错误。类似的“非忽严错”的规则也适用于把[ [Configurable] ]设置为false的属性：var person = {};Object.defineProperty(person,&quot;name&quot;,{ configurable:false, value:&quot;Nicholas&quot;});console.log(person.name); //&quot;Nicholas&quot;delete person.nameconsole.log(person.name); //&quot;Nicholas&quot;configurable被设置为false，则无法从对象中删除属性，若进行删除操作，则会“非忽严错”。注意：一旦把属性定义为不可配置的，就不能把它变回可配置的了（有意思）。此时，再调用Object.defineProperty（）方法修改特性，就会抛出错误。注意：在调用Object.defineProperty（）修改属性的特性时，如果不指定，则configurable、enumerable、writable的默认值就会变成false！属性就会自动变成不可配置，不能通过for - in循环返回属性。所以设置的时候最好四个都写上去。不过作者说，在多数情况下，没有必要利用到Object.defineProperty（）。不过，理解这些概念对理解JavaScript对象非常有用。✎IE8是第一个实现Object.defineProperty（）的浏览器版本，但是仍然存在限制，实现不完全。建议不要在IE8上使用这个方法。2.访问器属性需要使用getter和setter函数才能读写的属性。（但是这两个函数都不是必需的）。在读取访问器属性时，会调用getter函数，在写入访问器属性时，会调用setter函数并传入新值。访问器属性有4个特性：·[ [Configurable] ]：表示能否通过delete删除属性，能否修改属性的特性，能否把属性从数据属性修改为访问器属性。直接在对象上定义的属性，[ [Configurable] ]的默认值一般为true。·[ [Enumerable] ]：表示能否通过for - in循环返回属性。直接在对象上定义的属性，[ [Enumerable] ] 的默认值一般为true。·[ [Get] ]：在读取属性时调用的函数。默认值为undefined。·[ [Set] ]：在写入属性时调用的函数。默认值为undefined。访问器属性不能直接定义，必须使用Object.defineProperty（）定义。例子：var book = { _year:2004, edition:1};Object.defineProperty(book,&quot;year&quot;,{ get:function(){ return this._year; }, set:function(newValue){ if(newValue&gt;2004){ this._year = newValue; this.edition += newValue-2004; } }});book.year = 2005;console.log(book.edition); // 2以上代码创建了一个book对象，并给它定义两个默认的属性：_year和edition。_year前面的下划线是一种常用的人为规定的记号（没有程序上的作用），用于表示只能通过对象方法访问的属性（亲测console.log(book._year)可以访问到，大概是因为有用到对象方法访问）。注意这个_year属性并不是访问器属性。访问器属性是year。year包含一个getter函数和setter函数。getter函数返回_year的值，setter函数通过计算来确定正确的版本。因此，把year属性修改为2005会导致_year变成2005（setter属性set的属性不仅是自己的，还可以是同一对象下的其他属性）。而edition变为2。这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。支持ECMAScript5的这两个方法的浏览器有IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。在这个方法之前，要创建访问器，一般都使用两个非标准的方法：defineGetter（）和defineSetter（）。这两个方法最初都是由Firefox引入的，后来Safari 3、Chrome 1和Opera 9.5也给出了相同的实现。使用这两个遗留的方法，可以像下面这样重写前面的例子：var book = { _year:2004, edition:1};book.defineGetter(&quot;year&quot;,function(){ return this._year;});book.defineSetter(&quot;year&quot;,function(newValue){ if(newValue&gt;2004){ this._year = newValue; this.edition += newValue-2004; }});book.year = 2005;console.log(book.edition);console.log(book.year); // 2在不支持Object.defineProperty（）方法的浏览器中不能修改[ [Configurable] ]和[ [Enumerable] ]特性。6.1.2定义多个属性由于为对象定义多个属性的可能性很大，ECMAScript5又定义了一个Object.defineProperties（）方法。利用这个方法可以一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加或修改属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。例子：var book1 = {};object.defineProperties(book,{ _year:{ writable:true, value:2004 }, edition:{ writable:true, value:1 }, year:{ get:function(){ return this._year; }, set:function(){ if(newValue &gt; 2004){ if(newValue &gt; 2004){ this._year = newValue; this.edition += newValue -2004; } } } }});支持Object.defineProperties（） 方法的浏览器有：IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。 6.1.3读取属性的特性使用ECMAScript5的Object.getOwnPropertyDescriptor（）方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象。是访问器属性就有访问器属性的四个特性，是数据属性就有数据属性的四个特性。例如上面的book对象为例子：console.log(Object.getOwnPropertyDescriptor(book,&quot;_year&quot;));//返回：Object {value: 2004, writable: true, enumerable: true, configurable: true}console.log(Object.getOwnPropertyDescriptor(book,&quot;year&quot;));//返回：Object {enumerable: false, configurable: false} 很奇怪set和get特性要通过Object.getOwnPropertyDescriptor(book,&quot;year&quot;).get和~.set去得到里面set和get里面的函数。在JavaScript中，可以针对任何对象——包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor（）方法。支持这个方法的浏览器有：IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。6.2创建对象为了不写重复代码讨论了很多创建对象的方法。6.2.1工厂模式工厂模式是软件工程领域广为人知的设计模式，这种模式抽象了创建具体对象的过程（把创建对象的过程抽象简化）。因为在ECMAScript中没有类，开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节。例子：function createPerson(name,age,job){ var o = new Object(); //显式地创建对象 o.name = name; o.age = age; o.job = job; o.sayName = function(){ console.log(this.name) }; return 0; //有return语句，不知道有什么不好}var person = createPerson(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);工厂模式解决了创建多个相似对象要写重复代码的问题，但没有解决对象识别的问题（即怎样知道一个对象的类型，后面的由Person对象实例化的对象的类型就是Person类型而不是Object类型，解决了对象识别问题）。随着JavaScript的发展，又一个模式出现了。6.2.2构造函数模式前面几章说过，ECMAScript中的构造函数可以用来创建特定类型的对象（？说过？还不知道原来特定类型的对象可以自己定义，比如后面的Person对象）。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如，可以使用构造函数模式将前面的例子重写如下：function Person(name,age,job){ //构造函数首字母大写，普通函数首字母小写 this.name = name; this.age = age; this.job = job; this.sayName = function(){ console.log(this.name); };}var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);console.log(person1.name);在这个例子中，Person（）与createPerson（）的不同之处在于：没有显式地调用对象，直接将属性和方法赋给了this对象，没有return语句。✎注意：遵照其他OO语言的惯例，构造函数始终都以大写字母开头，非构造函数用小写字母开头。目的是为了区别于ECMAScript中的其他函数。要创建Person对象的实例，必须使用new操作符。以这种方式调用构造函数会经历以下4个步骤：（1）创建一个新对象；（2）将构造函数的作用域赋给新对象（环境变量对象就变成了这个对象，因此this就指向了这个对象）；（3）执行构造函数中的代码（为这个新对象添加属性）；（4）返回新对象。（对象实例诞生！）在前面例子的最后，person1和person2分别保存着Perso的一个不同的实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person（亲测console.log(person1.constructor)打印出了整个构造函数Person的源代码）。例子：console.log(person1.constructor == Person); //trueconsole.log(person1.constructor) //打印出上面构造函数Person的源代码对象的constructor属性最初是用来标识对象类型的。但是想要检测对象类型，还是instanceOf操作符更可靠一些。例子中创建的所有对象既是Object的实例，也是Person的实例，这一点可以通过instanceOf（）操作符验证：console.log(person1 instanceof Object); //trueconsole.log(person1 instanceof Person); //true创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式完胜工厂模式的地方。在这个例子中person1和person2之所以同时是Object的实例，是因为所有对象均继承自Object（详细内容稍后讨论）。✎：以这种方式定义的构造函数是定义在Global对象（在浏览器中是window对象）中的。（？？？又说所有对象继承自Object？？？）第八章会详细讨论浏览器对象模型（BOM）1将构造函数当作函数构造函数与其他函数的唯一区别，就在于调用他们的方式不同。但是归根到底构造函数还是函数。任何函数，只要通过new操作符调用，它就可以作为构造函数。而构造函数如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中的Person（）函数，可以用下面的任一方式调用，例子的重点是，体会用构造函数的方式调用和用普通方式调用两种方法，他们的作用域有什么不同：//当作构造函数调用var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);person1.sayName();//作为普通函数调用Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);window.sayName();//作为普通函数在另一个对象的作用域中调用var o = new Object();Person.call(o,&quot;Kristen&quot;,25,&quot;Nurse&quot;);o.sayName();第一种用法是构造函数的经典用法。第二种用普通的函数调用法：属性和方法都添加给了window对象（window.sayName（）正确的过程是，方法内的this总是指向Global对象，在浏览器中就变成了window对象）。第三种是重点：使用call（）在对象o的作用域中调用Person函数，类似在window对象中调用Person，调用后o也拥有 了所有属性和sayName（）方法。2构造函数的问题还是有人挑出了构造函数的问题。构造函数的问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName（）的方法，但那两个方法不是同一个Function的实例，因为他们在不同的对象环境中创建。从逻辑上讲，此时的构造函数可以这样定义：function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.sayName = new Function(&quot;console.log(this.name)&quot;); //与声明函数在逻辑上是等价的}从这个角度来看构造函数，就更容易明白每个Person实例都包含一个不同的Function实例（但他们的用途完全一样，就是显示name属性）（感觉学到了JavaScript不可言传的东西，这两个方法看起来一模一样，但是他们是两个不同的实例，要纠结他们是不同的实例的原因是，这样会产生不同的作用域链和标识符解析）。但创建Function新实例的机制仍然是相同的。因此，不同对象实例上的同名函数是不相等的，即person1的sayName（）不等于person2的sayName（）。以下代码可以证明这点：console.log(person1.sayName == person2.sayName); // false然而，创建两个完成同样任务的Function实例的确没有必要（导致产生不同的作用域链和标识符解析 ）；况且有this对象在，根本不用在执行代码前把函数绑定到每一个要实例的对象上，因此，可以像下面这种“等一下就要被作者推翻的方法”一样，把函数定义转移到构造函数外面来解决这个问题：function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.sayName sayName; //与声明函数在逻辑上是等价的}function sayName(){ console.log(this.name);}不知道这样会不会产生不同的作用域链，但是这样的好处是Function不用实例两次吧，可能是Function的作用域链不会产生两个，但是实例对象的作用域链还是会产生的。亲测console.log(person1.sayName == person2.sayName)返回的是true。证明他们用到的是一样的在全局环境下的sayName（）函数。但是这样又有一个问题，你在全局作用域定义的函数实际上只被某一个对象调用，如果对象需要很多个这样的方法，那不就要定义很多的全局函数吗。如此一来，我们这个自定义的引用类型就没有丝毫封装性可言了（太多函数暴漏在全局作用域中）。好在，我们可以用原型模式解决这个问题。6.2.3原型模式我们创建的每个函数都有一个prototype（原型）属性。这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的对象的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象（刚又说prototype是函数属性，现在又说是那个又构造函数实例出来的对象的原型对象？）使用原型对象的好处是可以让所有对象实例共享他们所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中（相当于对属性和方法设置一个默认值，在没有明确赋值的情况下，属性和方法的值就等于这个默认值）。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var person1 = new Person();person1.sayName();在此，我们将所有属性和sayName（）直接添加到Person的prototype属性中，构造函数变成了空函数。即便如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法，而且这些属性和方法是所有对象实例共享的。换句话说，person1和person2访问的都是同一组属性和同一个sayName（）函数。console.log(person1.sayName == person2.sayName)//true.要理解原型模式的工作原理，必须先理解ECMAcript中原型对象的性质。1.理解原型对象无论什么情况，只要创建了一个新函数，就会根据一组特定的规则（没有详讲）为该函数创建一个prototype属性（所有函数自带prototype属性）。这个属性指向函数的原型对象（前面又说prototype是原型对象现在又说是指向原型对象，大概因为prototype是个指针指向了原型对象，所有也可以说prototype属性是原型对象吧，有点函数名是函数的指针，所以也可以说这个函数是XX函数名，XX函数名是这个函数的意思）。在默认情况下，所有原型对象（暂且说是prototype，因为prototype指向原型对象）都会自动获得一个constructor（构造函数）属性（每个原型对象自带constructor属性），这个属性是一个指向prototype属性所在函数的指针。就拿前面的例子来说，Person.prototype.constructor指向Person这个函数，这个构造函数（也就是说一个函数里的prototype属性里的constructor属性是个指针，指向这个函数自己）。创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性，至于其他方法和属性，则都是从Object继承而来。当调用构造函数创建一个实例后（注意，这里开始讲的是实例，不是原来那个构造函数了），该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262管这个指针叫[[Prototype]]。虽然在JavaScript中没有标准的方式访问[[Prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性protp；而在其他浏览器中，[[Prototype]]则是完全不可见的。要明确的一点是，这个连接是在实例与构造函数的原型对象之间，而不是在实例与构造函数之间（即[[Prototype]]指向构造函数的prototype而不是指向构造函数）。以前面的Person构造函数和Person.prototype创建实例的代码为例，图6-1展示了各个对象之间的关系：上图展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。在此Person.prototype指向了原型对象，而原型对象中的constructor属性又指向了Person.prototype。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例——person1和peron2都包含一个内部属性[[Prototype]]，该属性又指向了原型对象（书里这里写的指向Person.prototype，但应该是指向原型对象才对）；换句话说，他们与构造函数没有直接关系（实例与构造函数没有直接关系！？）。此外，要格外注意的是，虽然这两个实例都不包括属性和方法，但我们却可以调用person1.sayName（）。这是通过查找对象属性的过程来实现的。虽然没有标准的方式访问[[Prototype]]（书里说所有实现（即浏览器）都无法访问到[[Prototype]]，但前面已经说了有三个浏览器可以用proto访问，亲测也确实可以），但可以通过isPrototypeOf（）方法来确定对象之间知否存在这种关系。从本质上讲，如果[[Prototype]]指向调用isPrototypeOf（）方法的这个对象（Person.prototype），那么这个方法就返回true。例子：console.log(Person.prototype.isPrototypeOf(person1)); //trueconsole.log(Person.prototype.isPrototypeOf(person2)); //trueperson1，2的原型对象是Person.prototype，所以返回true，也说明person1，2的[[Prototype]]指向Person.prototype。记住[[Prototype]]是实例对象的内部属性，是一个指针。ECMAScript5还增加了一个新方法，叫Object.getPrototypeOf（），在所有支持的实现（浏览器）中，这个方法返回[[Prototype]]的值。例子：console.log(Object.getPrototypeOf(person1)==Person.prototype); //true，相等，可以证明person1的[[Prototype]]是指向Person.prototype的console.log(Object.getPrototypeOf(person1).name); //&quot;Nicholas&quot; Object.getPrototypeOf（）可以用来获取对象原型的属性第一行代码确定了Object.getPrototypeOf（）返回的对象实际就是这个对象的原型（又跟我自己在注释里写的见解不一样）。第二行代码取得对象原型中name属性的值，即“Nicholas”。使用Object.getPrototypeOf（）可以方便地取得一个对象的原型（prototype）。而这在利用原型实现继承的情况下是非常重要的。支持这个方法的浏览器有： IE9+、Firefox 3.5+、Safari 5+、Opera 12+和Chrome。知道了构造函数有prototype属性之后，我们可以知道，当代码读取某个对象的某个属性时，都会执行一次搜索，目的是找到具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性值；如果没有找到，就继续搜索指针（[[Prototype]]）指向的原型对象（prototype），在原型对象中查找具有给定名字的属性，如果在原型对象中找到这个属性，就返回这个属性的值。所以我们在调用实例对象的属性和方法时会执行两次搜索。这正是多个对象实例共享原型对象所保存的属性和方法的基本原理。✎：前面提到过，原型对象最初只包含一个constructor属性，这个属性也是共享的，可以通过对象实例访问。（亲测访问这个属性会返回构造函数的源代码，之前亲测过了？）虽然我们可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加一个与原型对象中存在的同名属性，则我们就在实例中创建该属性。该属性会屏蔽掉原型中那个属性。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var person1 = new Person();var person2 = new Person();person1.name=&quot;Mike&quot;person1.sayName(); //“Mike” ←来自实例person1.sayName(); //&quot;Niicholas&quot; ←来自原型当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性（书中对“屏蔽”两个字黑体加粗，但是我觉得屏蔽的原理估计又有一大篇文章要讲）。如果把实例中的属性设置为null，也只会在实例中设置这个属性，无法恢复其指向原型的连接。要恢复其指向原型的连接，方法就是使用delete操作符完全删除实例属性，从而我们就可以重新访问原型中的属性。例子：person1.name = &quot;Mike&quot;;person1.name = null;person1.sayName(); //nulldelete person1.name person1.sayName(); //&quot;Nicholas&quot;使用hasOwnProperty（）（注意是Property不是prototype了，property是属性的意思）方法可以检测一个属性是存在实例中，还是原型中。这个方法（不要忘了这个方法继承自Object）在检测的属性是存在实例中的时候，返回true。例子：var person1 = new Person();person1.name=&quot;Mike&quot;delete person1.name;console.log(person1.hasOwnProperty(&quot;name&quot;)); //false，把第三行注释掉就变成true通过hasOwnProperty（）方法，我们访问属性的时候到底访问的是原型对象中的属性还是实例重新定义的属性就一清二楚了。（做了有趣的实验，把实例中的属性保存为跟原型对象属性一样的值，用hasOwnProperty（）方法返回的是true。可不可以说明他们存放的空间不一样？）person1.name=&quot;Nicholas&quot; 与原型对象中的属性值相同console.log(person1.hasOwnProperty(&quot;name&quot;)); //true✎：ECMAScript5的Object.getOwnPropertyDescriptor（）方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用Object.getOwnPropertyDescroptor（）方法。原来前面已经讲过这个方法竟然忘了。不知道什么是属性的描述符，测试了一次发现返回的是对象的属性的四个特性：console.log(Object.getOwnPropertyDescriptor(person1,&quot;name&quot;));//Object {value: &quot;Nicholas&quot;, writable: true, enumerable: true, configurable: true}注意上面的那句话啊！！！每个词都是关键啊！上面说要在原型对象上调用，不是直接用构造函数名调用啊，用构造函数名调用很奇怪，console.log(Object.getOwnPropertyDescriptor(person1,&quot;name&quot;));返回的描述符中的value是“Person”，第二个参数改成“job”或“age”返回的却是undefined。用console.log(Object.getOwnPropertyDescriptor(Person.prototype,&quot;name&quot;));就能返回value是“Nicholas”的描述符。例子：console.log(Object.getOwnPropertyDescriptor(Person,&quot;job&quot;)); //undefinedconsole.log(Object.getOwnPropertyDescriptor(Person,&quot;name&quot;)); //Object {value: &quot;Person&quot;, writable: false, enumerable: false, configurable: true}console.log(Object.getOwnPropertyDescriptor(Person.prototype,&quot;name&quot;));//Object {value: &quot;Nicholas&quot;, writable: true, enumerable: true, configurable: true}后来又继续测试console.log(Person.name);返回的也是“Person”，难道name是每个函数都有的属性返回函数的函数名？2.原型与 in 操作符in操作符的使用有两种方式，一种是单独使用和在for - in循环中使用。在单独使用时，in操作符用于判断某一属性是否在对象中，无论是在实例中还是原型中，只要有就返回true。例子：console.log(&quot;name&quot; in person1) //true 无论name是在实例中还是原型中console.log(&quot;name&quot; in Person) //顺便做了个实验，name属性确实在Person构造函数中console.log(&quot;name&quot; in Person) //false这让我想到一个问题，Person已经有一个name属性的值是“Person”，我们又通过原型对象给原型对象中添加了name属性的值是Nicholas，那值为“Person”的name属性又是来自哪里？？做了个实验，创建一个叫zoo的空函数：function zoo(){}console.log(&quot;name&quot; in zoo); //truein操作符判断后也是返回true，这个name不在原型对象中，也不在实例中，仍然返回true，这个name到底是放在哪？有意思。又做了好多实验，发现用函数声明，函数表达式创建出来的函数都有name属性，但是把这个自定义的函数当构造函数用，实例出来的对象就没有这个name属性。所以还是只有函数有咯。用Obect（）构造函数实例的对象也没有name属性。利用 in操作符，结合hasOwnProperty（）方法，我们可以创建一个函数来判断一个属性值到底是来自实例还是原型：function hasPrototypeProperty(object,name){ return !object.hasOwnProperty(name)&amp;&amp;(name in object);}这个是书里定义的函数，我觉得有点绕。这个是检测属性是原型属性返回true。是实例中的属性就返回假，跟我想的相反。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var person = new Person();console.log(hasPrototypePerty(person,&quot;name&quot;)) //trueperson.name = &quot;Greg&quot;;console.log(hasPrototypePerty(person,&quot;name&quot;)) //falsefor - in循环的作用，返回的是所有能通过对象访问的，可枚举的（enumerated）属性，其中既包括实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（[[Enumerable]]：false）的实例属性也会在for - in属性中返回（意思是：比如toString（）方法是Object的原生方法，一般这类方法都是不可枚举的，如果你在实例对象中重写了toString（），那toString（）就变成了可枚举的，会在for - in循环中被列出来）。因为根据规定，所有开发人员定义的属性都是可枚举的。但是IE8及更早版本会有BUG，即屏蔽不可枚举属性的实例属性也不会出现在for - in循环中。例如：var o = { toString : function(){ //重写toString（）方法 return &quot;My Object&quot;; }};for(var prop in o){ if(prop == &quot;toString&quot;){ console.log(&quot;Found String&quot;); //IE8中不会显示 }}上面的例子，本来我已经改写了toString（）了，应该是可以被for - in循环枚举出来的，但是在IE8及更早版本并不会被枚举出来。这个BUG会影响默认不可枚举的所有属性和方法，包括：hasOwnProperty（）、propertyIsEnumerable（）、toLocalString（）、toString（）和valueOf（）。ECMAScript5把constructor和property属性的[[Enumerable]]特性设置为false，但并不是所有浏览器都乖乖听ECMAScript的。要想获取对象上所有可枚举的实例属性（实例属性！原型对象中的属性不会被列举出来），可以使用ECMAScript5的Object.keys（）方法，这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。例子：function Person(){}Person.prototype.name = &quot;Nicholas&quot;;Person.prototype.age = 29;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var keys = Object.keys(Person.prototype);console.log(keys) //[&quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]var peron1 = new Person();person1.name = &quot;Mike&quot;;console.log(Object.keys(person1)) //[&quot;name&quot;]有什么实例，数组里才有什么属性，property里定义的属性是Person.prototype对象的实例属性，不是person1的实例属性，person1的实例属性只有一个。如果想要得到所有实例属性，无论是否可枚举，可以使用Object.getOwnPropertyNames（）方法。例子：console.log(Object.getOwnPropertyNames(Person.prototype)); //[&quot;constructor&quot;, &quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]person1.age=28;Object.defineProperty(person1,&quot;name&quot;,{ writable:false, value:&quot;Mike&quot;, enumerable:false}); console.log(Object.keys(person1)); // [&quot;age&quot;]console.log(Object.getOwnPropertyNames(person1)); // [&quot;name&quot;, &quot;age&quot;]还记得前面说的ECMAScript5把constructor（构造函数）属性也设置为不可枚举吗？看来这个浏览器遵循ECMAScript5的规定。Object.keys（）和Object.getOwnPropertyNames（）都可以用来替代for - in循环。支持这两个方法的浏览器有：IE9+、Firefox 4+、Safari 5+、Opera 12+和Chrome。记住他们返回的都是实例属性，不包括原型对象中的属性。3.更简单的原型语法作者介绍给我们，前面的每添加一个原型属性就要敲一遍Person.prototype的方法太傻了，为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。例子：function Person(){}Person.prototype = { constructor : Person, name : &quot;Nicholas&quot;, age :29, job : &quot;Software Engineer&quot;, sayName : function(){ console.log(this.name); }}理清除，Person.property是指针指向原型对象，所以用对象字面量法给原型对象添加属性和方法是没毛病的。但是这种写法本质上重写了Person.prototype对象，而每个prototype属性都自带有constructor属性，如果在重写中没有加入constructor属性，为constructor重新赋值，则constructor属性将从原型对象中消失。说消失是不准确的，这时候原型对象的constructor属性不再指向Person构造函数，而是指向Object构造函数。但是Person对象的实例仍然是Person的实例。下面的例子假设重写时没有加入constructor属性：console.log(friend instanceof Object); //trueconsole.log(friend instanceof Person); //trueconsole.log(friend.constructor == Person); //falseconsole.log(friend.constructor == Object); //true还有一点要注意的是，重写之后的constructor属性，它的[[Enumerable]]特性会被设置为true（当然是在ECMAScript5已经规定了constructor属性的[[Enumerable]]特性 默认为false且浏览器听它的的情况下）。如果想让它重新变为false，可以人工用Object.defineProperty（）方法设置。4.原型的动态性由于在原型中查找值是一次搜索，所以即使先创建实例后修改原型也是可以的。例子：var friend = new Person();Person.prototype.sayHi = function(){ console.log(&quot;Hi&quot;);};friend.sayHi(); //&quot;Hi&quot; （正常运行）可以看到我们先实例化了Person对象为friend，再修改Person的原型对象。firend仍然能访问到sayHi（）方法。其原因可以归结为实例与原型之间的松散连接关系。因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的sayHi属性并返回保存在那里的函数。尽管可以随时为原型添加属性和方法，但如果是重写整个原型对象，情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototyoe]]指针，而把原型重写为另外一个对象就等于切断了构造函数与最初原型之间的联系（从书中关系图来看，最初原型（旧原型对象）仍指向构造函数，但是构造函数指向了新的原型对象，所以也不是完全切断吧）。作者写到这里突然要我们记住：实例中的指针仅指向原型，不指向构造函数（实例与构造函数之间没有联系）例子：function Person(){}var friend = new Person();Person.prototype = { constructor : Person, name : &quot;Nicholas&quot;, age :29, job : &quot;Software Engineer&quot;, sayName : function(){ console.log(this.name); }};friend.sayName(); //报错： friend.sayName is not a function在这个例子中，我们先创建了一个Person对象，先实例化出一个friend，再重写了原型对象。然后在调用friend.sayName（）的时候就出现了错误。因为friend指向的原型是旧原型，不包含以该名字命名的属性。图6-3展示了这个过程。可以看到重写原型对象会切断现有原型与任何之前已经存在的对象实例之间的关系；之前已经存在的对象实例 仍然引用的是最初的原型。也就是说用重写原型的方式给原型对象添加属性的方法要在重写的那段代码之后再实例化对象，如果是用Person.prototype.属性 = XX这种方法则不存在这种问题。5.原生对象的原型这节讲的是原生对象的原型，什么是原生对象？就是原生的引用类型（Array，Object，String and so on）所有原生引用类型都在其构造函数的原型上（注意原型是谁的属性（prototype是个属性，这个属性是个指针），是构造函数的属性）定义了方法。例如Array类型的sort（）方法就是定义在Array.prototype中的。String类型的substring（）方法就是定义在String.prototype中的。证明例子：console.log(typeof Array.prototype.sort); //functionconsole.log(typeof String.prototype.substring); //functionconsole.log(typeof Array.sort); //undefinedtypeof Array.sort竟然是undefined是令我惊讶的，我以为后台会自动规定sort是Array的方法（所以以前的每次array.sort( )的调用都是在调用Array对象的原型对象中的方法，向Array.prototype致敬！）通过原生对象的原型，不仅可以取得所有默认方法的引用，而且可以定义新方法，可以像修改自定义对象的原型一样修改原生对象的原型，在里面添加新的方法。亲测可以改写原本已经定义的方法，比如toString（）这些。但是不要这样做。书中给出了在原生对象的原型中添加方法的例子，但是他建议不哟这样做，避免命名冲突。就不举例了。6.原型对象的问题原型对象也是有问题的（不能说BUG，合情合理）。原型对象的好处是可以共享属性，但最大的问题也处在了共享的问题上，属性的值是基本类型值还好，如果是包含引用类型的属性，就会出问题了：function Car(){}Car.prototype={ constructor:Car, friends:[&quot;Shelby&quot;,&quot;Court&quot;]}var car1 = new Car();var car2 = new Car();car1.friends.push(&quot;Van&quot;);console.log(car1.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]console.log(car2.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]本来只是像给实例对象car1的friends属性中的数组加入“Van”而已，但是最后car2也有了。因为car1并没有自己重写friends属性，而是直接在默认有的属性值中添加数据，而这个数组是保存在Person.prototype中的，所以刚刚提到的修改也会通过person2.friends反映出来。所以很少有人单独使用原型模式。6.2.4组合使用构造函数模式和原型模式创建自定义类型的最常见方式，是组合使用构造函数模式和原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。这样，每个实例都有自己的一份实例属性的副本（不懂这个实例属性的副本是什么意思），但同时共享对方法的引用，最大限度地节省了内存。重写前面的代码的例子：function Person(name,age,job){ //通过对构造函数传参给独特的属性赋值 this.name = name; this.age = age; this.job = job; this.friends = [&quot;Shelby&quot;,&quot;Court&quot;]; //引用类型写在构造函数中}Person.prototype = { constructor:Person, //别忘了重写constructor属性 sayName:function(){ //一样的方法可以共用 console.log(this.name); }}var person3 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);var person4 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);person3.friends.push(&quot;Van&quot;);console.log(person3.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]console.log(person4.friends); //[&quot;Shelby&quot;, &quot;Court&quot;]console.log(person3.friends == person4.friends); //falseconsole.log(person3.sayName == person4.sayName); //true这种构造函数与原型混成的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。后面几节讲的都是定义引用类型的几种方法，既然说上面的是最好用的，后面的就不写了。6.2.5动态原型模式为看不惯上面的写法的有其他OO语言开发人员使用的方法。6.2.6寄生构造函数模式作者不推荐这种方法，因为这个方法返回的对象与构造函数或者与构造函数的原型属性之间没有关系。也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。也就是说假设用创建了一个Person构造函数，用这个构造函数实例出来的对象并不属于Person，而是属于Object。6.2.7稳妥构造函数模式这个方法也是创建的对象与构造函数之间没有什么关系。6.3继承许多OO语言都支持两个继承方式：接口继承和实现继承。接口继承只继承方法签名。而实现继承则继承实际的方法。如前面章节讲过的，由于函数没有签名（函数没有“函数名”只是一个指针，所以叫没有签名？），在ECMAScript中无法实现接口继承。实现继承主要是依靠原型链实现的。6.3.1原型链ECMAScript中描述了原型链的概念。并将原型链作为实现继承的主要方法。其基本思想是：利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型链实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针（constructor），而实例都包含一个指向原型对象的内部指针（[[Prototype]]）。那么，如果我们让原型对象等于另一个类型的实例，会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针。相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条，这就是所谓原型链的基本概念。实现原型链的基本模式如下：function SuperType(){ this.property = true; //定义的变量名有点复杂，看得有点晕，其实就是一个值为true的变量}SuperType.prototype.getSuperValue = function(){ return this.property;};function SubType(){ this.subproperty = false; //另一个false的变量}//继承了SuperTypeSubType.prototype = new SuperType(); //让一个构造函数A的原型等于另一个构造函数B的实例，这个实例又有一个指向B的原型的指针SubType.prototype.getSubValue = function(){ //这里看得有点懵，其实就是给子对象的原型定义了一个方法，跟上面的代码无关，也没用上 return this.subproperty;}var instance = new SubType(); //创建子对象的实例console.log(instance.getSuperValue()); //true 发现子对象的实例可以调用父对象的方法，返回保存在父对象的变量以上代码定义了两个类型：SuperType和SubType。每个类型各有一个属性一个方法。他们的区别是SubType继承了SuperType。继承的步骤是：通过创建SuperType的实例（new SupperType），并将该实例赋给了SubType.prototype实现。实现的本质是重写原型对象，给原型对象赋值为一个新类型的实例（所以SubType.prototype里的constructor属性也改变了，不是没有了，变成了新类型实例里指向父构造函数的constructor属性，此时constructor为SuperType）。换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了。在确定了继承关系后，我们又不知道有什么卵用地给SubType.prototype添加了一个方法。这样就在继承了SuperType的实例的属性和方法后，又有了自己的方法。这个例子中的实例以及构造函数和原型之间的关系如图：在代码中，我们没有使用SubType默认提供的原型，而是把它重写成了一个新原型，这个新原型就是SuperType的实例。于是，新原型不仅具有作为一个SuperType的实例所拥有的全部属性和方法，而且内部还有一个指针（[[Prototype]]，通了，一开始觉得叫[[Prototype]] 不恰当，想明白了根本不会！因为这个[[Prototype]]属性本来就是SuperType实例中有的），指向SuperType的原型。结果就是这样：instance的[[Prototype]]指向SubType的原型，SubType的原型里的[[Prototype]]又指向SuperType的原型。注意：getSuperValue（）方法仍然还在SuperType.prototype里，SubType.prototype里没有，但property则在SubType.prototype中。书中的解释是：因为property是一个实例属性，而getSuperValue（）是一个原型方法（实例属性会跟着继承在子对象中，原型方法仍然留在父对象的原型中）。解释：既然SubType.prototype现在是SuperType的实例，那么property当然位于实例中了，而getSuperValue（）是在原型中，不在实例中。此外，要注意instance.constructor现在指向的是SuperType，这是因为原来Subtype的原型指向了另一个对象SuperType 的实例，这个实例指向了对象SuperType的原型，SuperType的原型里的constructor属性就是指向SuperType。（书里这样写，可是为什么instance会有constructor属性？constructor不是原型对象才有吗？亲测每个实例都有这个属性，返回这个实例的构造函数。字符串类型的constructor返回到是String（）构造函数）通过原型链的介绍，原型搜索机制又要重新扩展：当以读取模式访问一个实例属性时，首先会在实例中搜索该属性，如果没有找到该属性，就继续搜索实例的原型，在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，调用instance.getSuperValue（）会经历三个搜索步骤：1）搜索实例；2）搜索SubType.prototype；3）搜索SuperType.prototype，最后一步找到这个方法。搜索过程总是这样一环一环地走到原型链末端才停下来。1.别忘记默认的原型事实上，前面例子中展示的原型链少了一环。我们知道，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是Object的实例（new Object( )），因此默认原型都会包含一个内部指针，指向Object.prototype（又不说这个指针的名字）。这也正是所有自定义类型都会继承toString（）等默认方法的原因（上面讲原型对象的时候说过，原生引用类型的方法都是定义在prototype上的）。所以所有函数的toString（）等默认方法不是在他们自己的prototype属性中，而是通过指针，一层层地找到那些放在Object.prototype里的原型方法的，这样就减少了还能多内存占用吧。所以上面例子展示的原型链中还应包括另外一个继承层次，如图才是真正完整的原型链：2.确定原型和实例的关系可以通过两种方式来确定原型和实例之间的管理，第一种方式使用instanceOf操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。例子：console.log(instance instanceof Object) //trueconsole.log(instance instanceof SubType) //trueconsole.log(instance instanceof SuperType) //true由于原型链的关系，我们可以说instance是Object、SuperType、SubType中任何一个类型的实例。因此三个构造函数的结果都返回true。第二种方式是使用isPrototypeOf（）方法，同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf（）也会返回true:console.log(Object.prototype.isPrototypeOf(instance)); //trueconsole.log(SubType.prototype.isPrototypeOf(instance)); //trueconsole.log(SuperType.prototype.isPrototypeOf(instance)); //true3.谨慎地定义方法子类型有时候会需要覆盖超类型中的某个方法，或者添加超类型中不存在的某个方法。但无论如何，给原型添加方法的代码一定要放在替换原型的语句之后。例子：function SuperType(){ this.property = true;}SuperType.prototype.getSuperValue = function(){ return this.property;};function SubType(){ this.subproperty = false;}//继承了SuperTypeSubType.prototype = new SuperType(); //无论是覆盖还是添加，都要放在替换原型的语句之后//添加新方法SubType.prototype.getSubValue = function(){ return this.subproperty;}//重写超类型中的方法SubType.prototype.getSuperValue = function(){ return false;}var instance = new SubType();console.log(instance.getSuperValue()); //false在上面代码中，加粗部分是两个方法的定义。第一个方法getSubValue（）被添加到了SubType中，第二个方法getSuperValue（）是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的那个方法。换句花说，当通过SubType的实例（instance）调用getSuperValue（）时，调用的是这个重新定义的方法；但通过SuperType的实例调用getSuperValue（）时，还会继续调用原来的那个方法。这里要格外注意的是，必须在用SuperType的实例替换原型之后，再定义这两个方法。从前面的原型链关系图我们知道SuperType的实例调用的是SuperType的原型里的getSuperValue（），SubType的实例一开始是用指针调用SuperType的原型里的getSuperValue（），后来就通过重写在自己的SubType里添加了自己的getSuperValue（）。还有一点要注意到是，在通过原型链实现了继承之后，不能使用对象字面量法重写原型方法，因为这样就重写了原型链，继承就断了。例子：function SuperType(){ this.property = true;}SuperType.prototype.getSuperValue = function(){ return this.property;};function SubType(){ this.subproperty = false;}//继承了SuperTypeSubType.prototype = new SuperType();//使用字面量添加新方法，会导致上一行代码失效SubType.prototype = { getSubValue : function(){ return this.subproperty; }. someOtherMethod : function(){ return this.false; }}var instance = new SubType();console.log(instance.getSuperValue()); //error! 继承关系已断以上代码展示了刚把SuperType的实例赋给Subtype的原型，下面的代码马上就把SubType的原型给重写了，相当于上面的那行赋值被替换了，无效了。相当于现在的原型里包含的是Object的实例（所有函数的默认原型都是Object的实例），而不是SuperType的实例。原型链被切断，SubType和SuperType之间已经没有关系了。4.原型链的问题通过原型链的继承还是存在问题的，就是包含引用类型的那个问题。包含引用类型值的原型属性会被所有实例共享；当其中一个实例修改了原型属性中的引用类型值，整个引用类型值就被修改了。例子：function SuperType(){ this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];}function SubType(){}SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var instance2 = new SubType();console.log(instance2.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]还是引用类型值共享会导致修改类型值会直接修改原型属性里的值的问题。原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数，实际上，应该说是没有办法在不影响所有对象的情况下，给超类型的构造函数传递参数（意思是说不能在SubType.prototype = new SuperType() 给构造函数赋值吗？）。由于前面的两个问题，很少会单独使用原型链。6.3.2借用构造函数为了解决前面的问题，开始人员开始使用一种叫借用构造函数（constructor stealing）的技术（有时候也叫做伪造对象或经典继承）。这种技术的思想相当简单：在子类型构造函数的内部调用超类型的构造函数。别忘了，函数只不过是在特定环境中执行代码的对象。因此，通过使用apply（）和call（）方法也可以在（将来）新创建的对象上执行构造函数。例子：function SuperType(name){ //另一个好处是可以给构造函数赋值 this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; this.name = name;}function SubType(){ //继承了SuperType ，同时传递了参数 SuperType.call(this,&quot;Nicholas&quot;); //不知道这个this有什么用，this不是指向window吗，可能“将来”实例化变成对象之后就指向SubType对象了 this.age = 29}var instance1 = new SubType(); //前面说的将来就是指这个时候，调用了内部的SuperType构造函数instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]var instance2 = new SubType();console.log(instance2.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]console.log(instance1.name) //&quot;Nicholas&quot;console.log(instance1.age) //29代码中加粗那行代码“借调”了超类型的构造函数。通过使用call()方法，我们实际上是在（未来将要）新创建的SubType实例的环境（this指向的是SubType实例的环境 ）下调用SuperType构造函数（不一定有new才能调用构造函数）。这样一来，就会在新SubType对象上执行SuperType（）函数中定义的所有对象初始化代码。结果SubType的每个实例都会有自己的colors属性的副本了。但是这种方式并没有使用到SubType.prototype哦。1.传递参数传递参数的例子被我写在上面一起讲了。代码中SuperType接收一个参数name，并在函数内直接给name属性赋值。在SubType构造函数内部调用SuperType构造函数时，实际上是为SubType的实例设置了name的默认属性，虽然这个默认属性不在prototype上。为了确保SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。2.借用构造函数的问题如果只使用借用构造函数，那么也将出现构造函数模式出现的问题——方法都在构造函数中，每实例一个对象就重新复制了一份函数中的方法，影响性能。因此函数的复用就无从谈起。而且，在超类型中定义的方法，对子类型而言是不可见的，结果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数技术也很少使用。6.3.3组合继承组合继承（combination inheritance）有时候也叫伪经典继承。指的是将原型链和借用构造函数的技术组合到一块。背后的思路是：是哦那个原型链实现对原型属性和方法的继承、而通过借用构造函数来实现对实例的继承。例子：function SuperType(name){ this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; //属性写进构造函数里 this.name = name;}SuperType.prototype.sayName = function(){ console.log(this.name);};function SubType(name){ //继承属性 SuperType.call(this,name); ] this.age = age;}//继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType; //如果没有这一步，SubType的原型里concerned属性就是指向SuperTypeSubType.prototype.sayAge = function(){ //方法写进原型里 console.log(this.age);}var instance1 = new SubType(&quot;Nicholas&quot;,29); instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]instance1.sayName(){}; //&quot;Nicholas&quot;instance1.sayAge(){}; //29var instance2 = new SubType(&quot;Greg&quot;,27);console.log(instance2.colors); //[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]instance2.sayName(); //&quot;Greg&quot;instance2.sayAge(); //27在例子中，SuperType构造函数定义了两个属性：name和colors。SuperType的原型定义了一个方法sayName（）。SubType构造函数在调用SuperType构造函数时传入了name参数，紧接着又定义了自己的属性age。然后，将SuperType的实例赋值给SubType的原型，然后又在该新原型上定义了方法sayAge（）。这样一来，就可以让两个不同的SubType实例既分别拥有自己的属性——包括colors属性，又可以使用相同的方法了。组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中 n继承模式。而且instanceOf和isPrototypeOf（）也能够用于识别基于组合继承创建的对象。6.3.4原型式继承一个有缺陷的继承方式，但是ECMAScript5为这个方式创建了一个create（）方法，跟原型式继承原理相似。这种方法没有使用严格意义上的构造函数。道格拉斯·克罗克福德（提出者）的想法是：借助原型可以基于已有的对象创建新对象。同时还不必因此创建自定义类型（意思就是那个子构造函数（比如那个SubType构造函数）都不用创建了，下面那个方法的返回值直接赋给一个变量，那个变量就是实例了）。下面就是那个函数：function object(o){ function F(){} F.prototype = o; //这个构造函数的原型等于传进来的那个对象，所以不用创建自定义类型，这个F就相当于那个自定义类型了 return new F(); //返回一个构造函数的实例，赋给一个变量就相当于实现了继承}在Object（）函数内部，先创建了一个临时性的构造函数（F），然后将闯入的对象作为这个构造函数的原型（ F.prototype = o ），最后返回这个临时类型的新实例。从本质上讲，object（）对传入其中的对象执行了一次浅复制。看下面例子：var person = { name:&quot;Nicholas&quot;, friends:[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]};var anotherPerson = object(person); //调用object()，传进去的person相当于超类型anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;); //注意这里给friends数组引用类型值推入一个数据的只是anotherPersonvar yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;); //注意这里第二个子实例yetAnotherPerson也给数组推入一个Barbieconsole.log(person.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;, &quot;Rob&quot;, &quot;Barbie&quot;] //超类型里的数组里也多了Rob和Barbie✎：反正直接在对象字面量里定义值为引用类型值的属性被改写就会GG（一开始打这句话的时候是写“直接在原型里定义值为引用类型值的属性就GG”，想想不对，上面的person是在自己那里定义的引用类型值属性不是在原型里啊。object（）方法返回的是F（）的实例，是F的原型（F.prototype）复制了person的属性哦，所以anotherPerson和yetAnotherPerson对象改的应该是F.prototype里的数组吧，为什么person也会受影响呢？想想，可能是：person对象作为函数参数传入了函数object（），虽然JavaScript是按值传递的，但person是对象，F.prototype = o 相当于F.prototype成了对象person的指针（相当于复制了对象的指针），所以看起来改的是F.prototype，但其实F.prototype里没有这个属性，本质上改的应该是person对象里的属性，况且F在object（）函数执行完后已经被销毁，但anotherPerson和yetAnotherPerson 保存了F的实例，也就保存了F的prototype原型对象）。如果有一个超类型的对象在的话，我们就可以使用object( )函数，把超类型作为参数传入，然后函数就会返回一个新对象。在这个例子中，作为超类型的对象是person对象（注意对象首字母是小写，它的作用不是作为构造函数），把person放入object（）传入函数，返回一个新对象，这个新对象将person作为原型（其实应该说 F 将person作为原型），所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。这意味着person.friend不仅属于person所有，而且也会被anotherPerson和yetAnotherPerson共享。实际上，这就相当于又创建了person对象的两个副本（说副本还是有门道的，是副本不是指针，如果是指针的话，anotherPerson和yetAnotherPerson 修改name属性的话，person也会被改，但亲测并不会，虽然F.prototype是person的指针，但new F（），F的实例不是指针，算了解释不下去了，以前是SubType.portotype = new SuperType（）好歹是别人的实例就一定不是指针，但 F.prototype = o 是指针无疑啊，为什么anotherPerson和yetAnotherPerson 会有自己的name属性呢？）。ECMAScript5通过新Object.create（）方法规范了原型式继承。这个方法接收两个参数：一个用作新对象的父对象和一个为新对象定义额外的属性的对象（可选，意思就是用对象字面量的方法定义新对象的额外属性）。在传入一个参数的情况下，Object.create（）与object（）方法的行为相同。var person = { name:&quot;Nicholas&quot;, friends:[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]};var anotherPerson = Object.create(person);anotherPerson.name = &quot;Greg&quot;; //后面的代码会教不用这样写anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);console.log(person.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;, &quot;Rob&quot;, &quot;Barbie&quot;] 仍然存在的问题Object.create（）的第二个参数与Object.defineProperties（）方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性：var anotherPerson = Object.create(person,{ name:{ value:&quot;Greg&quot; //好麻烦啊这样写 }})console.log(anotherPerson.name) //&quot;Greg&quot;果然用上面的参数格式，其他三个特性不写，全部会由默认true变成默认false:console.log(Object.getOwnPropertyDescriptor(anotherPerson,&quot;name&quot;))//Object {value: &quot;Greg&quot;, writable: false, enumerable: false, configurable: false}console.log(Object.getOwnPropertyDescriptor(yetAnotherPerson,&quot;name&quot;))//Object {value: &quot;Linda&quot;, writable: true, enumerable: true, configurable: true}默认的自定义对象的三个特性都是true，如果用Object.defineProperties（）的格式修改描述符的定义，没有列出来，则默认会被后台修改为false。6.3.5寄生式继承寄生式（parasitic）继承也是克罗克福德提出来的，与原型式继承紧密相关的一种思路。寄生式继承的思路与寄生构造函数和工程模式类似，既创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"高程","slug":"高程","permalink":"https://millionqw.github.io/tags/高程/"}]},{"title":"《Javascript》高级程序设计 第五章 详细解释引用类型（下）","date":"2017-07-10T14:02:24.000Z","path":"2017/07/10/《Javascript》高级程序设计-第五章-详细解释引用类型（下）/","text":"我的文章会在我的Blog同步更新，Blog刚搭了几天，用于记录我的学习过程：Million 5.5Function类型作者说ECMAScript中最有意思的是函数，有意思的根源在于，函数实际上是对象。每个函数都是Function类型的实例。与其他引用类型一样，函数类型也有属性和方法。由于函数是对象，因此函数名实际上只是一个指向函数对象的指针，不会与某个函数绑定。 函数通常是使用函数声明语法定义的，如下面的例子所示：123function sum(num1,num2)&#123; return num1+num2;&#125; 这与下面使用函数表达式定义函数的方法几乎相差无几:123var sum = function(num1,num2)&#123; return num1+num2;&#125;; // ← 注意最后的分号，声明完变量必加的分号 第二段代码定义了变量sum并将其初始化为一个函数（注意这句话的顺序，把一个定义好的变量初始化为一个函数）。我们可以发现用函数表达式创建的函数，function关键字后面没有函数名。因为没有必要。通过变量sum即可以引用到函数（注意，你不能说变量sum是函数名）。另外，注意函数末尾有一个分号，因为说到底sum还是个变量，只是变量的值是一个函数！最后一种定义函数的方式，因为函数是对象，所以可以使用Function构造函数。Function可以接收任意个数量的参数，最后一个参数始终被当作函数体，前面的都是函数的参数。例子：1var sum = new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;num3&quot;,&quot;return num1+num2&quot;); //不推荐 从技术的角度讲，这是一个函数表达式，但是不推荐使用。因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript，第二次是解析传入构造函数中的字符串），从而影响性能。不过这种语法有利于理解“函数是对象，函数名是指针”这个概念。由于函数名仅仅是指针（好唏嘘，函数名以为用它的名字创建的函数就是它的，结果，它只是一个指针。）一个对象可以有很多指针，所以一个函数也可以有多个名字。例子：123456789function sum(num1,num2)&#123; return num1+num2;&#125;var anotherSum = sum;alert(anotherSum(10,10)); //20sum = null;alert(anotherSum(10,10)); //20 即使把sum给设置为null，但因为这个指针已经复制了一份给anotherSum，所以这个函数对象还是可以被引用到，不会因为sum不见了，函数就跟着没了。（亲测PHP似乎就不能用这种方法“转换函数名”）注意，使用不带圆括号的函数名是访问函数指针，使用带括号的函数名就表示要调用这个函数。 5.5.1没有重载把函数名想象为指针，就能理解为什么ECMAScript没有重载。例子：12345678function sum(num1,num2)&#123; return num1+100;&#125;function sum(num1)&#123; return num1+200;&#125;console.log(sum(100,100)); // 300 显然，例子中声明了两个同名函数，而结果是后面的函数覆盖了前面的函数。因为在创建第二个函数时，实际上覆盖了引用第一个函数的变量addSomeNumber。 5.5.2函数声明与函数表达式实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明并使其在执行任何代码之前可用（可以访问）；至于函数表达式，就必须等到解析器执行到它所在的代码行，才会真正被解释执行。（所以函数声明有函数声明提升（function declaration hoisting），函数表达式没有）函数表达式不能写在要调用这个函数的代码之后。函数声明提升：Javascript引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以即使声明函数的代码在调用它的代码后面。JavaScript也能把函数声明提升到顶部。除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。再无其他差别。 ✎ 有人觉得不妨在使用函数表达式的同时给函数命名，like this : var sum = function sum(){ }但这种语法在 Safari 中会出错。 5.5.3作为值的函数因为ECMAScript中的函数名本身就是变量，所以函数也可以作为一个值来使用。也就是说，不仅可以像传递参数一样把一个函数当作参数传递给一个函数，而且可以将一个函数作为另一个函数的结果返回。例子：123function callSomeFunction(someFunc,someArgument)&#123; return someFunc(someArgument)&#125; 这个函数接收两个参数，一个是函数，一个是普通参数，这个普通参数给传进来的函数使用。然后，就可以像下面这样传递函数了：123456789101112function add10(num)&#123; return num+10;&#125;var result1 = callSomeFunction(add10,10); //注意函数作为参数传递是不带括号的，带括号的函数会执行，参数就变成这个函数执行完成返回的那个值了alert(result1); //20 function getGreeting(name)&#123; return &quot;Hello &quot; + name;&#125;var result2 = callSomeFunction(getGreeting,&quot;Nicholas&quot;);alert(result2); // Hello Nicholas 注意，要访问函数的指针而不执行函数的话，必须去掉函数名后面的括号。因此上面例子给callSomeFunction（）传递的是add10 和 getGreeting。而不是执行它们之后的结果。可以从一个函数中返回一个函数，是一项极为有用的技术。例如，假设有一个对象数组（由对象组成的数组），我们想要根据对象中的某一个属性对数组进行排序，而传递给sort（）方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来告诉sort（）按照哪个对象属性排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据属性名来创建一个匿名比较函数。下面就是这个函数的定义：1234567891011121314function creatComparisonFunction(propertyName)&#123; return function(obj1,obj2)&#123; var val1 = obj1[propertyName]; //细节，用方括号访问保存在变量propertyName中的属性，终于知道用处了 var val2 = obj2[propertyName]; if(val1&lt;val2)&#123; return -1; &#125;else if(val1&gt;val2)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;;&#125; 看起来很复杂，其实就是嵌套了一个函数，而且内部函数前面加了一个return操作符。在内部函数接收到propertyName参数后，它会用方括号表示法来取得给定属性的值。取得这个对象属性后，就用这个属性进行比较。完成对象数组的排序。用法：123456var data = [&#123;name:&quot;Zachary&quot;,age:28&#125;,&#123;name:&quot;Nicholas&quot;,age:29&#125;];data.sort(creatComparisonFunction(&quot;name&quot;));console.log(data[0].name); //Nicholasdata.sort(creatComparisonFunction(&quot;age&quot;));console.log(data[0].name); //Zachary 5.5.4函数内部的属性在函数内部，有两个特殊的对象（函数对象中的对象）：arguments和this。arguments在第三章介绍过，是一个类数组对象，包含这个传入函数的所有参数。虽然arguments的主要用途是保存所有函数参数，但arguments对象还有一个名叫callee的属性，该属性是一个指针。arguments.callee( )可以指代这个函数本身。用处是可以消除函数的执行与函数名之间的耦合。还是那个阶乘的例子：1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*factorial(num-1); &#125;&#125; 如果我把factorial这个函数名改为另一个函数的函数名：12345var trueFactorial = factorial;function factorial()&#123; return 0;&#125;console.log(trueFactorial(5)) // 0 这个时候trueFactorial（）函数就出错了，要降低这种耦合，使用arguments.callee( )是最好方法。1234567function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*arguments.callee(num-1); //即使factorial被改写，arguments.callee()仍代表当前函数。 &#125;&#125; 函数内部的另一个特殊对象是this，其行为与Java和C#中的this大致类似。换句话说，this引用的是函数据以执行的环境对象。当在网页的全局作用域中调用函数时，this对象引用的就是window。例子：123456789indow.color = &quot;red&quot;;var o = &#123;color:&quot;blue&quot;&#125;;function sayColor()&#123; console.log(this.color);&#125;sayColor(); //redo.sayColor=sayColor;o.sayColor(); //blue 函数sayColor( )首先是在全局作用域中定义的，它引用了this对象。但在调用它之前，并不确定是在哪个作用域中调用。当在全局作用域中调用sayColor( )，this引用的是全局对象，所以this.color = window.color。结果返回red。当把这个函数赋给对象o，并调用o.sayColor( )时，this引用的是对象o，因此this.color = o.color。结果返回blue。（亲测把sayColor（）函数放在另一个函数中去调用，最后得到的结果还是window，再嵌多一层函数也还是window，说明this引用的不是作用域，而是函数据以执行的环境对象，还有一个原因是当你把函数嵌套进另一个函数的时候，返回是window的原因是你此时调用的实际上已经不是一个方法，而是一个函数。） ECMAScript5还规范化了另一个函数对象的属性caller。除了Opera早期版本不支持，其他浏览器IE，Firefox，Chrome，和Safari的所有版本及Opear9.6都支持caller属性。这个属性保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。例如：1234567function outer()&#123; inner();&#125;function inner()&#123; console.log(inner.caller); //会打印出outer()的源代码&#125;outer(); 以上代码会打印出outer( )的源代码，因为outer（）调用了inner（），所以inner.caller就指向outer（）。当然不能试图用inner.caller( )来调用outer。否则会陷入无限回调使代码出错。为了更松散的耦合，也可以通过arguments.callee.caller(）来访问相同的信息。1234567function outer()&#123; inner();&#125;function inner()&#123; console.log(arguments.callee.caller); //会打印出outer()的源代码&#125;outer(); arguments在严格模式下无法使用，arguments对象也有一个caller属性，但这个值永远是undefined。定义这个属性是为了分清arguments.caller和函数的caller属性，这个变化是出于增强这门语言的安全性。严格模式还有一个限制：不能为函数的caller属性赋值，否则会导致错误。 5.5.5函数属性和方法前面提过ECMAScript中函数是对象，所以函数就有属性和方法，上面介绍了一个caller。还有两个是length和prototype。length属性表示函数希望接收的命名参数的个数。命名参数有1个，length的值就是1，参数有两个，length的值就是2。不解释。 作者说，在ECMAScript核心所定义的全部属性中，最耐人寻味的就要数prototype属性了（不止函数的prototype，其他对象的prototype属性也耐人寻味！）对与ECMAScript中的引用类型而言，prototype是保存他们所有实例方法的真正所在。换句话说，诸如valueOf（）,toString（）等方法实际上都是保存在了prototype属性名下。只不过是通过各自对象的实例访问到了。在创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的（第6章会详细介绍）。在ECMAScript中，prototype属性是不可枚举的，因此无法用for-in无法发现prototype这个属性。（对property属性的讲解到此为止） 每个函数都包含两个非继承而来的方法：apply（）和call（）。这两个方法的用途都是在特定的作用域中调用函数。实际上等于设置函数体内this对象的值。两个方法的区别只是在传入参数的方法上有区别而已。首先，apply（）方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例（就是普通数组），也可以是arguments对象。例子：12345678910111213function sum(num1,num2)&#123; return num1+num2;&#125;function callSum1(num1,num2)&#123; return sum.apply(this,arguments);&#125;function callSum2(num1,num2)&#123; return sum.apply(this,[num1,num2]);&#125;console.log(callSum1(10,10)); //20console.log(callSum2(10,10)); //20 在上面这个例子中，callSum1( )在执行sum（）函数时传入了 this 作为 this 值（？？？）（因为是在全局作用域中调用的，所以传入的就是window对象）和arguments对象，而callSum2传入的第二个参数则是数组型。这两个函数都会正常执行并返回正确结果。（这个例子只是为了说明两种传入参数的方式都可以，还没体现出apply（）和call（）的作用） ✎在严格模式下，未指定环境对象而用函数，则this值不会转型为window（严格模式下的this不会默认转型为window）除非明确把函数添加到某个对象或者调用apply（）或call（），否则this值将是undefined。 call（）方法与apply（）方法的作用相同，区别仅在于接收参数的方式不同。对于call（）方法，第一个参数仍是this不变，变化的是其余参数都是直接传递给函数。换句话说，在使用call（）方法时，参数都是逐个列举出来的。例子：12345678function sum(num1,num2)&#123; return num1+num2;&#125;function callSum1(num1,num2)&#123; return sum.call(this,num1,num2);&#125;console.log(callSum1(10,10)); // 20 在使用call（）方法的情况下，callSum( )必须明确地传入每一个参数。结果与apply（）没有什么不同。使用哪一种完全是看你觉得哪个更方便（MD以前还觉得这两个方法多深奥ZZ）。apply（）和call（）的真正强大之处，是能够扩充函数赖以运行的作用域。例子：12345678910window.color = &quot;red&quot;;var o = &#123;color:&quot;blue&quot;&#125;;function sayColor()&#123; console.log(this.color)&#125;sayColor(); //redsayColor.call(window); //redsayColor.call(o); //blue 第一次调用sayColor()时在全局作用域中调用它，会显示“red”——因为对this.color的求值会转换成对window.color的求值。当运行sayColor。call(o)时，函数的执行环境对象就不一样了，因此此时函数体内的this对象指向了O,于是结果显示“blue”。使用call（）和apply（）的最大好处，就是对象不需要与方法有任何耦合关系（不用为了在这个对象内调用方法而把函数写进对象中）。在书中前面的第一个例子中（笔记没有），为了在对象o中调用sayColor( )，要把这个函数写进对象o中，再通过o调用，而在这里的例子中，就不需要那么多步骤了。ECMAScript5又定义了一个方法：bind（）（所以函数对象的方法有三个）。这个方法会创建一个函数的实例（会创建一个函数），其this值会被绑定到传给bind（）函数的值。例子：12345678window.color = &quot;red&quot;;var o = &#123;color:&quot;blue&quot;&#125;;function sayColor()&#123; console.log(this.color)&#125;var objSayColor = sayColor.bind(o);objSayColor(); 在这里，sayColor（）调用bind（）并传入对象o，创建了objSayColor（）函数。objSayColor（）的this值等于o。因此无论在哪个环境对象中调用这个函数，都会看到“blue”。这种技巧的优点参考第22章。因为是ECMAScrip5才有的方法，所以可以使用bind（） 的浏览器有： IE9+，Firefox4+，Safari 5.1+，Opera 12+和Chrome。（兼容性挺低的） 最后说每个引用类型值都有继承的，都会被重写的toLocaleString（）和toString（），valueOf（），这三个方法都始终返回函数的代码。返回代码的格式根据浏览器的不同会有差异。因为有返回值差异，所以返回的结果无法被用来实现任何功能，不过这些信息在调试代码时很有用。 5.6基本包装类型读到这里又刷新了三观。这里说Boolean、Number、String是3个ECMAScript提供的特殊引用类型。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。实际上，每创建一个基本类型的时候，后台就会创建一个对应的基本包装类型对象（WTF？？？），从而让我们能够调用一些方法来操作这些数据（这解释了为什么三种基本类型值也有自带的属性和方法）。例子，我们可以这样使用基本类型值的方法：12var s1 = &quot;some text&quot;;var s2 = s1.subString(2); 可以看到我们可以调用String类型自带的方法，但如下面的例子，我们不能在运行时为基本类型值添加属性和方法：123var s1 = &quot;some text&quot;;s1.color = &quot;red&quot;;console.log(s1.color); //undefined 我们知道，基本类型不是对象，因而从逻辑上它不应该有方法（尽管如我们所愿，它有方法）。其实，为了让我们能用方法操作基本类型值，后台已经自动完成了一系列的处理（注意后面是原理）：当第一段代码的第二行（var s2 = s1.subString(2); ）访问s1时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理：（1）创建String类型的一个实例；（2）在实例上调用指定的方法；（3）销毁这个实例。以上三个步骤用代码表示就是：123var s1 = new String(&quot;some txt&quot;);var s2 = s1.subString(2); //把结果放回给另一个变量s1 = null; //销毁这个对象 上面的步骤也适用于Boolean，Number类型。这也就解释了为什么不能给基本类型值添加属性和方法，因为基本类型值对象在调用完方法后就会被后台自动销毁。 引用类型和基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中（离开了作用域后可能就会被标记，然后被垃圾收集机制回收）。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁（亲测手动用new操作符创建的基本类型对象，可以添加属性和方法。）所以我们无法为基本类型值添加属性和方法。当然如果没有必要的话，就不要显示地调用Boolean和Number、String来创建基本包装类型对象（不要var s1 = new String(“some txt”)这样写）。因为这样容易让人分不清自己是在处理基本类型还是引用类型的值。 Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：123var obj = new Object(&quot;some text&quot;);console.log(obj instanceof String); //trueconsole.log(obj instanceof Object); //true 就是把字符串传给Object构造函数，就会创建String的实例，传入数值参数就会得到Number实例，传入布尔值参数就会得到Boolean实例，但是你检测它是以上基本类型值会返回true，检测是不是Object也会返回true。下面会讲每个基本包装类型提供的操作相应值的便捷方法。 5.6.1Boolean类型这节的重点是理解基本类型的布尔值与Boolean对象之间的区别。当然，作者的建议是永远不要使用Boolean对象，这节就当冷知识吧。 创建Boolean对象可以像下面这样调用Boolean构造函数并传入true或false值。1var booleanObject = new Boolean(false) Boolean类型的实例重写了的valueOf( )方法会返回基本类型的true和false，重写了的toString( )会返回字符串型的“true”和“false”。书中前面提到过，但是当时不懂有什么用就没记的一段话：布尔表达式中的所有对象都会被转换为true。例子：123var falseObject = new Boolean(false);var result = falseObject &amp;&amp; true;console.log(result); //true 在这个例子中我们用false值创建了Boolean对象的实例falseObject，并对这个对象与true进行&amp;&amp;运算，却发现返回到结果是true。因为，示例中的代码是对falseObject而不是对它的值（false）求值。而布尔表达式中的所有对象都会被转换为true，结果true&amp;&amp;true当然就等于true了。 5.6.2Number类型Number类型也重写了valueOf（）、toLocaleString（）、toString（）。valueOf（）返回这个对象表示的基本类型的数值（亲测就是一个数）。toLocaleString（）、toString（）返回字符串类型的数值。Number的toString（）方法可以传递一个表示基数的参数，参数是几，就按几进制的数字的字符串形式返回。12var num = 10;console.log(num.toString(2)) //&quot;1010&quot; 注意返回的是字符串形式的。 上面的几个是继承的方法，Number类型提供了一些可以将数值格式化的方法。 toFixed（）：按照指定的小数位返回数字的字符串表示，且支持四舍五入。比如25.005用toFixed(2)，会变成“25.01”。 toExponential(（）：返回以指数表示法表示的数值的字符串形式。接收的参数也是指定输出结果中的小数位数。 12345var num = 10.005;console.log(num.toFixed(2)) //&quot;10.01&quot;var num = 10;console.log(num.toExponential(1))//&quot;1.0e+1&quot; 5.6.3String类型String对象继承的valueOf（）、toLocaleString（）、toString（）返回的都是这个对象表示的基本字符串值。String类型的每个实例都有一个length属性，表示字符串中有多少个字符（亲测中文也是有多少个字长度就是几）。书中说了，即使字符串中包含双字节字符（不是占一个字节的ASCII字符，每个字符也仍然算一个字符）。 String类型提供的方法很多，看到都怕。 1.字符方法两个用于访问字符串中特定位置字符的方法：charAt( )和charCodeAt( )。两个方法都接收一个参数，即基于0的字符位置。两个方法的区别是charAt( )返回的是给定位置的那个字符。charCodeAt( )返回的是那个字符的字符编码。例子：123var stringValue = &quot;hello World&quot;;console.log(stringValue.charAt(1)); // &quot;e&quot;console.log(stringValue.charCodeAt(1)); // &quot;101&quot; 是小写字母e的字符编码 ECMAScript5定义了另一个访问个别字符的方法，可以用方括号加数字索引来访问字符串中的特定字符。例子：12var stringValue = &quot;hello World&quot;;console.log(stringValue[1]); //&quot;e&quot; 类似于把字符串当成一个“数组”，按位置取出所在位置的字符。亲测可以直接在字符串后面加方括号，例子：1console.log(&quot;sdsdsdsd&quot;[2]); //&quot;s&quot; 66666 支持这个语法的浏览器有IE8，Firefox，Safari，Opera 和Chrome所有版本的支持。冷知识：在IE7及更早版本使用这种语法会返回undefined值，尽管不是特殊的undefined值（不是很懂最后一句的意思，我以为返回的那个undefined是字符串型的，但是不是） 2.字符串操作方法操作字符串的方法有几个，第一个是concat( )，可以将一或多个字符串拼接起来，参数就是要添加进去的字符串，参数数量不限。返回得到的新字符串。数组类型也有这个方法，不解释。不过在实践中使用最多的是加号操作符（+）（MDZZ）。ECMAScript还提供了三个基于子字符串创建新字符串的方法：slice（）、substr（）、substring（）。三个方法都返回被操作字符串的一个子字符串。三个方法的第一个参数都是指定子字符串的开始位置。slice（）和substring（）的第二个参数指定的是子字符最后一个字符后面的位置（忽略结尾那个位置）。而substr（） 的第二个参数指定的则是返回字符的个数。如果没有第二个参数，则默认将字符串的长度作为结束的位置。（太乱实际用再百度）。与concat（）方法一样，这三个方法也不会修改本身的那个字符串。对原始字符串无任何影响。例子：1234567var stringValue = &quot;Hello World&quot;;console.log(stringValue.slice(3)); //&quot;lo world&quot;console.log(stringValue.substring(3)); //&quot;lo World&quot;console.log(stringValue.substr(3)); //&quot;lo World&quot;console.log(stringValue.slice(3,7)); //&quot;lo W&quot;console.log(stringValue.substring(3,7)); //&quot;lo W&quot;console.log(stringValue.substr(3,7)); //&quot;lo Worl&quot; substr()第二个参数表示要截取的字符个数 看起来三个方法作用很容易理解，但是传递给这些方法的参数是负数的情况下，他们的行为就不尽相同了。其中，slice（）会将传入的负值与字符串的长度相加，substr（）将负的第一个参数加上字符串的长度，而将第二个负的参数转换为0.最后，substring（）方法会将所有负值参数都转换为0.很恐怖，不想举例子了，实践中没事不要用负数就行。需要再看书。 3.字符串位置方法有两个可以从字符串中查找子字符串的方法：indexOf( )和lastIndexOf( )。这两个方法都是从一个字符串中搜索给定的子字符串，然后返回子字符串的位置。查找不到就返回-1.两个方法的区别是一个从头向后查询，一个从后向前查询。例子：123var stringValue = &quot;hello world&quot;;console.log(stringValue.indexOf(&quot;o&quot;)); //4console.log(stringValue.lastIndexOf(&quot;o&quot;)) //7 这两个方法都接收第二个参数，表示从字符串哪个位置开始搜索。换句话说，indexOf（）从该参数指定的位置向后搜索，忽略之前的所有字符；而lastIndexOf（）则会从指定的位置向前搜索，忽略该位置之后的所有字符（为什么在讲第二次的时候才讲这么清楚）。例子：123var stringValue = &quot;hello world&quot;;console.log(stringValue.indexOf(&quot;o&quot;,6)); //7console.log(stringValue.lastIndexOf(&quot;o&quot;,6))//4 indexOf( )从位置6（字母“w”）开始向后搜索，在位置7找到“o”。lastIndexOf( )从位置6开始向前搜索，找到的是“hello”中的“o”，所以返回4。 我们可以在使用第二个参数的情况下，通过循环把所有匹配的子字符串找出来，例子：123456789var stringValue = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit&quot;;var positions = new Array();var pos = stringValue.indexOf(&quot;e&quot;);while(pos&gt;-1)&#123; positions.push(pos); pos = stringValue.indexOf(&quot;e&quot;,pos+1);&#125;console.log(positions); //[3, 24, 32, 35, 52] 4.trim（）方法ECMAScript5定义了trim（）方法，该方法会创建一个字符串副本，删除前置和后置的所有空格，然后返回结果。支持这个方法的浏览器有：IE9+，Firefox 3.5+，Safari 5+，Opera 10.5+和Chrome。此外，Firefox 3.5+，Safari 5+和Chrome 8+还支持非标准的trimLeft( )和trimRight( ) ，分别用于删除字符串开头和末尾的空格。 5.字符串大小写转换方法toLowerCase（）、toLocaleLowerCase（）、toUpperCase（）和toLocaleUpperCase（）。为什么会有toLocaleLowerCase（）、toLocaleUpperCase（）这两个方法是因为有些地区比如土耳其语回味iUnicode大小写转换应用特殊的规则也是醉了，所以用这两个针对地区的方法来保证正确的转换。 6.字符串的模式匹配方法正则看得头大 7.localCompare方法tolocalCompare（）方法就是用字符串跟方法的字符串参数比较，如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1），如果字符串等于字符串参数，则返回0；如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1）。而且localCompare（）方法有个与众不同的地方，大小写是否区分要视使用方法的地区不同而定。比如美国以英语作为ECMAScript实现的标准语言，因此localCompare（）就是区分大小写的，则大写字母在字母表中会排在小写字母前面。所以是否区分大小写要根据地区而定。（亲测中国地区区分大小写且大写字母在小写字母之前） 8.fromCharCode（）方法String构造函数（是构造函数的方法不是普通字符串的方法）本身还有一个静态方法：fromCharCode( )。这个方法可以接收一或多个字符编码，将他们转换为字符串。例子： 9.HTML方法作者建议尽量不用这些方法，因为他们创建的标记通常无法表达语义（不懂）。方法有12个，需要再查书吧。 5.7单体内置对象ECMA-262对内置对象的定义是：“由ECMAScript实现提供的，不依赖宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了，所以开发人员不用显示地实例化内置对象，因为他们已经实例化了。”前面介绍的Object、Array和String等都是内置对象。ECMA-262还定义了两个单体内置对象：Global和Math。 5.7.1Global对象Global（全局）对象是ECMAScript中最特别的一个对象，因为你不管从什么角度上看，这个对象都是不存在的（？？？）。ECMAScript中的Global对象在某种意义上是作为一个“兜底儿对象”。换句话说，不属于任何对象的属性和方法，都是global对象的属性和方法。事实上，没有全局变量和全局函数，因为所有在全局作用域中定义的属性和函数，都是Global对象的属性（只是属性，函数也是Global对象的属性）。本书前面介绍过的那些函数，比如isNan（），isFinite（）、parseInt（）以及parseFloat（），都是Global对象的方法（array,object等类型对象的方法当然不是Global对象的，是array、object等这些对象的，不要混淆）。除此之外，Global还有其他一些方法。下面介绍这几个方法： 1.URI编码方法Global对象的encodeURI（）和encodeURIComponent（）方法可以对URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的URI不能包含某些字符，例如空格，而这两个URI编码方法就会对URI进行编码，用特殊的UTF-8字符替换所有无效的字符，让浏览器能够接受和理解。encodeURI（）和encodeURIComponent（）的第一个区别是，encodeURI（）只会把URI中无效的字符替换掉，encodeURIComponent（）会把正确的特殊符号例如冒号、正斜杠、问号和井号也给替换掉。第二个区别是，encodeURI（）用于整个URI，而encodeURIComponent（）用于对URI中的某一段进行编码。例子：12345var uri = &quot;http://www.wrow.com/illegal value.html#start&quot;;console.log(encodeURI(uri)); //http://www.wrow.com/illegal%20%20value.html#startconsole.log(encodeURIComponent(uri)); //http%3A%2F%2Fwww.wrow.com%2Fillegal%20%20value.html%23start 第二个方法中连12345有编码的函数，就有解码的函数，与这两个函数对应的函数是**decodeURI（）和decodeURIComponent（）**。其中，decodeURI（）**只能对非法字符进行解码**，decodeURIComponent（）可以对**所有被编译的符号**进行解码。例如，decodeURI（）可以将%20替换成空格，但不能对%23做任何处理，因为%23表示井字号（#），而井字号是合法符号。但是decodeURIComponent（）就%20和%23都可以解码。&lt;h4&gt;2.eval（）方法&lt;/h4&gt;最后一个Global对象的方法，大概是**整个ECMAScript语言中最强大的一个方法：eval（）**（见仁见智，有些人觉得这个方法弊端多多）。eval（）就像一个**完整的ECMAScript解析器**，它只接收一个参数，即**要执行的ECMAScript（或JavaScript）字符串**。例子： eval(“alert(‘hi’)”);1以上代码等价于下面这行（so what??）： alert(‘hi’)；1当解析器发现代码中调用eval（）方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原来位置。**通过eval（）方法执行的代码被认为是包含该次调用的执行环境的一部分**，因此被执行的代码具有与该执行环境相同的**作用域链**。这意味着通过eval（）执行的代码**可以引用在包含环境中定义的变量**。例子： var msg = “hello world”;eval(“alert(msg)”);1可见，变量msg是在eval（）调用的环境之外定义的，但其中调用的alert（）仍然能够显示“hello world”。这是因为上面第二行代码最终被替换成了一行真正的代码（so？那干嘛要加个eval（），直接写进执行环境不就好了吗）。同样地，我们也可以在eval（）调用中定义一个函数，然后在外部代码中引用这个函数： eval(“function sayHi(){ alert(‘Hi’); }”);sayHi();12345显然，函数sayHi（）是在eval（）内部定义的。但由于对eval（）的调用最终会被替换成定义函数的实际代码，因此可以在下一行的外部代码中调用sayHi( )。在eval（）中创建的仍和变量或函数**都不会被提升**，原理：因为在解析代码的时候，他们被包含在一个字符串中，它们只在eval（）执行的时候创建。严格模式下，在外部访问不到eval（）中创建的任何变量或函数，因此前面的那个例子就会导致错误。在严格模式下，为eval赋值也会导致错误： “use strict”;eval = “hi”; //causes error123456&lt;h4&gt;3.Global对象的属性&lt;/h4&gt;前面说过了，没有明确对象的属性，最后都是Global的属性，例如，特殊的值undefined、NaN以及Infinity等。此外，所有原生引用类型的**构造函数**，像Object，Function也都是Global对象的属性。书中列出了所有Global对象的所有属性。在P133.ECMAScript 5明确禁止给undefined、NaN和Infinity赋值，这样做即使在非严格模式下也会导致错误。&lt;h4&gt;4.window对象&lt;/h4&gt;ECMAScript没有明确告诉我们如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的（在浏览器中，Global对象是**window对象的一部分**，注意范围：浏览器中，window对象的一部分。）例子： var color = “red”; function sayColor(){ alert(window.color);}window.sayColor(); //“red”12345在这里我们定义了一个名为color的全局变量和一个sayColor（）全局函数。在sayColor（）内部，我们用window.color来访问变量，前面我们说过，全局环境中定义的变量和函数，实际上都是Global的属性，所以**window.color等价于Global.color**。以此说明，全局变量是window对象的属性。然后，又使用window.color来直接通过window.sayColor( )直接通过window对象调用这个函数。&gt;✎JavaScript中的window对象除了扮演ECMAScript规定的Global对象的角色外，还承担了很多任务，所以说Global对象这是window对象的一部分。第8章在讨论浏览器对象模型时将详细介绍window对象。另一种取得Global对象的方法是使用以下代码： var global = function(){ return this; // 亲测return出来的是 window}();```这是个立即调用的函数表达式，返回this的值。如前所述，在没有给函数明确指定this值的情况下，this值等于Global对象。而像这样通过简单地返回this来取得Global对象，在任何执行环境下都是可行的。（因为是立即执行函数的原因？） 5.7.2Math对象不想写了这个，就是Math下的各种方法。可以直接在书中查阅。","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"高程","slug":"高程","permalink":"https://millionqw.github.io/tags/高程/"}]},{"title":"Postcss使用体验：在未来写CSS","date":"2017-07-07T12:24:46.000Z","path":"2017/07/07/Postcss使用体验：在未来写CSSSS/","text":"&nbsp;&nbsp;接触Postcss的起因是在用Npm安装模块的时候看到的提示语句，一番接触后发现：我以后可能不需要写Sass了。&nbsp;&nbsp;今天用Npm安装模块的时候出现了一段提示语句：&nbsp;&nbsp;大致了解了一下Postcss是一个平台，上面有各种插件用来处理CSS，不过里面讲的东西，我觉得没必要用得这么麻烦。 &nbsp;&nbsp;重点是他推荐的大漠老师POSTCSS深入学习,进了这个指引，你对Postcss的理解，最重要使用就能非常清晰了。 &nbsp;&nbsp;说说我对Postcss的误解，一开始我以为它是像Sass、Less一样的预处理器，心想又要去学一种预处理器吗？后来又发现它竟然还有autoprefixer（自动添加浏览器前缀），压缩代码等功能，后来又觉得，这些功能能做的，gulp也能做，那我还要Postcss干嘛？ &nbsp;&nbsp;通过学习后发现，它就是gulp+Sass的结合版，最重要的是一下几点： 一、清晰、简短的配置&nbsp;&nbsp;只要你引入了Npm中各种“postcss-”前缀的插件，只要你不是很想特别定制，只要在处理css的‘gulp’的’task’中给一个数组，写进你要添加的处理模块，gulp就能编译出CSS代码，相比gulp的插件，要写一个个方法，一些方法的配置还要去查文档，Postcss的配置简直简单到“引入即用”的感觉。 &nbsp;&nbsp;这个就是我gulpfile.js中Postcss部分的配置： 123456789101112131415161718192021222324var gulp = require(&apos;gulp&apos;);var postcss = require(&apos;gulp-postcss&apos;);var autoprefixer = require(&apos;autoprefixer&apos;); //自动添加前缀var opacity = require(&apos;postcss-opacity&apos;); //opacity属性的降级处理var pseudoelements = require(&apos;postcss-pseudoelements&apos;); //让IE8支持::的伪元素var vmin = require(&apos;postcss-vmin&apos;); //为IE9支持viewport相对单位vminvar pixrem = require(&apos;pixrem&apos;); //给rem添加px作为降级处理为IE8var will_change = require(&apos;postcss-will-change&apos;); //为will-change属性添加回退var cssnext = require(&apos;cssnext&apos;); //写未来的CSSvar precss = require(&apos;precss&apos;); //用函数的方法写CSSvar color_rgba_fallback = require(&apos;postcss-color-rgba-fallback&apos;); //给rgba()提供降级方案为IE8var atImport = require(&apos;postcss-import&apos;); //可以使用@import引入其他CSS文件，减少Http请求var mqpacker = require(&apos;css-mqpacker&apos;); //合并媒体查询var size = require(&apos;postcss-size&apos;); //CSS中一个size属性同时写height和widthgulp.task(&apos;css&apos;, function () &#123; //will_change必须在autoprefixer之前 var processors = [ will_change, autoprefixer, cssnext,color_rgba_fallback, opacity, pseudoelements, vmin, pixrem,precss,atImport,mqpacker,size ]; return gulp.src(&apos;./src/*.css&apos;) .pipe(postcss(processors)) .pipe(gulp.dest(&apos;./dest&apos;));&#125;); &nbsp;&nbsp;可以看到除了长长的引用模块外，想要使用Postcss中的插件，只需要在processors数组中添加你要使用的模块，用pipe()处理即可。 二、极大减少CSS书写量&nbsp;&nbsp;如果你已经厌倦了一次次地写重复的垂直居中、水平居中，Postcss中，有postcss-center帮你搞定，只要你引入了postcss-center，top:center用于实现垂直居中，left:center用于实现水平居中：1234.centered &#123; top:center; left:center;&#125; 编译出来的CSS：1234567.centered&#123; position: absolute; top: 50％; right: 50%; margin-right: -50%; transform: translate(-50%, -50%);&#125; 两段代码来自大漠老师教程 &nbsp;&nbsp;诸如此类，清除浮动，设置定位，设置水平，垂直间距，输出颜色代码等等等，都分别有postcss-clearfix，postcss-position，postcss-verthorz，postcss-color-short等插件可以实现，极大提升写代码效率。因为我还在学习中，这些东西我觉得还是先自己写明白了比较适合，所以只使用了postcss-size这个插件，就是使用后height和width可以同时写在同一行，我早就想这么做啦23333：123.img &#123; size: 200px 200px;&#125; 编译后的CSS：1234img &#123; height: 200px; width: 200px;&#125; 三、类似Sass的语法&nbsp;&nbsp;并不是说postcss有类似Sass的语法，而是因为postcss有cssnext插件，可以用未来使用的css语法，再转化为css现在浏览器支持的语法，而类似Sass中的mixin，extend，定义变量，函数等功能，未来的CSS语法也都有，只是与Sass有少许差异，而且如果你想用Sass，Less编写也可以，只要调整一下编译顺序，让编译Sass的命令在postcss命令之前即可。 &nbsp;&nbsp;总而言之，postcss上这么多插件，合理搭配使用可以极大地提高开发效率，我觉得既然未来的CSS语法已经摆在了你面前，就像ES6语法有了babel的支持一样，可以借助postcss而提前使用，那么为什么不早点使用迟早会成为标准的语法呢，我已经打算开始尝试结合gulp上的其他配置，开始学习“未来的CSS”，尝试postcss的使用，在未来写CSS，一起试试吧！","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"https://millionqw.github.io/tags/CSS/"}]},{"title":"《Javascript》高级程序设计 第五章 详细解释引用类型（上）","date":"2017-07-06T13:45:07.000Z","path":"2017/07/06/《Javascript》高级程序设计 第五章 详细解释引用类型（上）/","text":"第五章 引用类型引用类型的值（对象）是引用类型的一个实例。如前所述，对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身也是一个函数，只不过该函数是出于创建新对象的目的而定义的。例子：1var person = new Object(); 这行代码创建了一个Object这个引用类型的新实例，然后把该实例保存在了变量person中。（这句话特别有意思，如果我用自己的话说，会说“创建了一个叫person的Object的新实例，而不会说先创建了实例再把实例保存在person中”）使用的构造函数就是Object( )。它为新对象（person定义了默认的属性和方法）。ECMAScript提供了很多原生引用类型（例如Object( ),Date( ),RegExp( )）。以便开发人员完成常见的计算任务。 5.1Object类型创建Object类型的方法有两种。第一种，使用new操作符后跟Object构造函数。例子：123var person = new Object();person.name = &quot;Nicholas&quot;;person.age = 29; 第二种，用对象字面量表示法。这种方法更被开发人员所接受，最推荐使用。代码量少，且给人封装数据的感觉。实际上，对象字面量也是向函数传递大量可选参数的首选方式。例子：1234var person = &#123; name : &quot;Nicholas&quot;, //属性名也可以用字符串如：&quot;name&quot; : &quot;Nicholas&quot; age : 29 // &quot;age&quot; : 29&#125; 在对象字面量中使用逗号来分隔不同的属性，因此“Nicholas”后面记得加逗号，最后一个属性后面不能加逗号。否则IE7及更早版本和opera会出现错误。✎注意：使用对象字面量定义对象时，并没有调用到Object函数（即内在原理不是Object函数，Firefox 2以及更早版本的Firefox会调用Object函数，但Firefox3之后就不会了。） ✎关于表达式上下文（expression context）和语句上下文（statement context）在用对象字面量定义新对象的例子中，左边的花括号“｛”表示对象字面量的开始，因为它出现在了表达式上下文（expression context）中（”person=”，等号的后面）。ECMAScript中的表达式上下文指的是该上下文期待一个值（表达式）。赋值操作符（“=”）表示后面是一个值（这里的值是一个对象，不要直觉觉得值就是一个数字），所以左花括号在这里表示一个表达式的开始。同样的花括号如果出现在一个语句上下文（statement context）中，例如跟在 if 语句条件的后面，则表示一个语句块的开始。 对象字面量除了可以用来定义新对象，当函数需要大量可选参数时，使用对象字面量也是不错的选择。例子：12345678910111213141516171819202122function displayInfo(args)&#123; var output = &quot;&quot;; if(typeof args.name == &quot;string&quot;)&#123; output += &quot;Name:&quot; + args.name + &quot;\\n&quot;; console.log(output); &#125; if(typeof args.age == &quot;number&quot;)&#123; output=&quot;&quot;; output += &quot;Age&quot; +args.age + &quot;\\n&quot;; console.log(output); &#125;&#125;//用对象字面量传递参数，这时候args就是对象，name,age就是args的属性displayInfo(&#123; name:&quot;Nicholas&quot;, age:29&#125;)displayInfo(&#123; name:&quot;Greg&quot;&#125;) 这个例子中，函数displayInfo（）接受一个名为args的参数，这个参数可能带有一个名为name或age的属性，有可能同时有也可能都没有。在函数内部用typeof操作符检测每个属性是否存在，再根据相应属性来构建显示信息。对象字面量传递参数法特别适合在需要向函数传递大量可选参数的情形。最好的做法是：对那些必需值使用命名参数（直接写在括号内），用对象字面量来封装多个可选参数。 ✎访问对象属性时用点表示法或者是方括号“[ ]”的取舍仍然以上面的person对象为例子。使用方括号访问对象属性的时候，千万千万记得要给对象属性加双引号（亲测单引号也可以）才能真正访问到那个对象属性，这是个很容易出现错误但找不到原因的地方。例子：12alert(person[&quot;name&quot;]); // Nicholasalert(person[name]); // undefined 使用方括号的优点一是，可以使用变量间接地访问对象属性。例子：123var propertyName = &quot;name&quot;; // 必须加双引号，否则是undefinedalert(person[propertyName]); // Nicholasalert(person.name); // undefined 方括号的优点二：如果对象属性名中包含会导致语法错误的字符（比如空格），或者属性名使用的是关键字或保留字，也可以使用方括号表示法。例子：123person[&quot;first name&quot;] = &quot;Nicholas&quot;;person[&quot;last-name&quot;] = &quot;Tom&quot;;alert(person[&quot;first name&quot;]); 有空格，“ - ”等会导致错误的属性名，只能通过方括号语法赋值（对象字面量也不行）和访问。（亲测）当然，除非是使用变量来访问属性，或者属性中带有特殊字符，否则还是建议用点表示法访问。 5.2Array类型avaScript的数组类型与其他语言的数组类型的最大不同，就是JavaScript数组的每一项可以保存任何类型的数据，比如第一项保存数字，第二项保存字符串，第三项保存对象。而且可以随着数据的添加自动增长以容纳新增数据。创建数组的两种方法。方法一是使用Array构造函数，例子：1var colors = new Array(); 如果预先知道了数组是多少位，也可以给Array构造函数直接传递数量，该数字就会成为该数组的length属性的值1var colors = new Array(20); // colors.length = 20 也可以直接向Array构造函数直接传递数组包含的值1var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;orange&quot;); 在使用Array构造函数的时候，可以省略“new”操作符。省略“new”操作符的效果与添加“new”的效果相同。第二种创建数组的方法：数组字面量表示法。（与对象一样，使用数组字面量表示法时也不会调用Array( )构造函数（Firefox3及更早的版本除外））1234var colors = [ &quot;red&quot;, &quot;blue&quot;, &quot;orange&quot; ];var names = [];var values = [1,2,] //不要这样做，IE8及之前的版本会出BUGvar options = [, , , , ,] //不要这样做，IE8及之前的版本会出BUG 第三种情况在IE8及之前的版本中，数组values会有1，2，undefined三个值，其他浏览器则只有1和2.第四种的情况与第三种类似，IE会创建6个值，其他浏览器会创建5个，因为有浏览器差异，所以强烈建议不这么做。不过正常人谁这么做。把玩Array引用类型的属性length数据的length属性有一个特点——可写可读。如果设置这个属性的值比现有数组长度短，则设置的长度后面的数组的值就会被删除。如果设置length的值比现有的length大（比如设置array.length=100），则数组的长度变为100，空位置为undefined。利用length也可以很方便地在数组末尾添加新的值。例子：12var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;orange&quot;]; // colors.length = 3;colors[colors.length] = &quot;black&quot; // clolors[3] = &quot;black&quot;; 当把一个值放在超出当前数组大小的位置，数组就会重新计算长度，长度值变成最后一项的索引(索引就是从0开始的)加一。例子：123var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;orange&quot;];var colors[99] = &quot;black&quot;;alert(colors.length) //100 中间colors[3]到colors[99]的值都是undefined。 数组的最大长度可以到4294967295（算冷知识吧）如果超过这个数就会出现异常。如果一个数组的大小接近这个上限值，会导致运行时间超长的脚本错误。 5.2.1检测数组对于一个网页或一个全局作用域而言，使用instanceof操作符就能得到满意的结果。而instanceof操作符的问题在于，它假定只有一个全局执行环境。如果网页红包含多个框架，那实际上就会出现两个及以上的执行环境，从而存在两个以上不同版本的Array构造函数，如果从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。为了解决这个问题，ECMAScript5新增了 Array.isArray( ) 方法，这个方法的目的是最终确定这个值到底是不是数组，而不管它是在哪个全局执行环境中创建的（我也不知道为什么多个执行环境下有多个不同的构造函数就使instanceof操作符无法检测数组。）该方法用法如下：123if(Array.isArray(value))&#123; //对数组执行操作&#125; 5.2.2转换方法前面章节提过，所有对象都自带 toLocalString( )、toString( ) 和 valueOf( )方法。其中，调用数组的toString( )方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用valueOf( )返回的还是数组。实际上，toString( )方法为了创建这个字符串会调用数组每一项的toString（）方法（原理）。例子：1234var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;orange&quot;];alert(colors.toString()); //red,blue,orangealert(colors.valueOf()); //red,blue,orangealert(colors); //red,blue,orange 第一个alert显式地调用了toString方法（相对第三个alert）,每个值的字符串表示拼接成了一个字符串，中间用逗号分隔。第二个alert调用valueOf方法，最后一行代码直接将数组传递给alert。由于alert( ) 要接收字符串参数，所以它会在后台自动调用toString方法（相对第一个alert的显示调用），由此得到与第一个alert相同的结果。（用typeof 和 valueOf亲测 colors.valueOf( )的类型是Array,colors.toString( ）的类型是String） ✎toString（）和toLocalString（）的不同toLocaleString 方法返回一个 String 对象，这个对象中包含了用当前区域设置的默认格式表示的日期。 toLocaleString 只是用来显示结果给用户；最好不要在脚本中用来做基本计算，因为返回的结果是随机器不同而不同的。示 例:下面这个例子说明了 toLocaleString 方法的用法。12345var d, s; // 声明变量。d = new Date(); // 创建 Date 对象。s = &quot;Current setting is &quot;;s += d.toLocaleString(); // 转换为当前区域。根据所在地区（中国，欧洲）的不同，返回的日期格式不同return(s); // 返回转换的日期。 数组继承的前面三个方法，在默认情况一都会以逗号分隔的字符串的形式返回数组项（有点争议，valueOf( )返回的类型应该是Array类型，或对象型）而如果使用join( ) 方法，则可以使用不同的分隔符来构建这个字符串。join（）方法只接受一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。例子：123var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;orange&quot;];alert(colors.join(&quot;-&quot;)); //red-blue-orangealert(colors.join(&quot;||&quot;)); //red||blue||orange 5.2.3栈方法就是数据结构中的栈。栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构（碟子模型）。栈中项的推入和弹出都发生在一个位置——栈的顶部（数组的尾部）。ECMAScript为数组提供了push( )和pop（）方法，以便实现类似栈的行为。push( )（push: v. 推入）方法可以接收任意数量的参数（！），把他们逐个添加到数组的末尾，并返回修改后数组的长度。pop（）（pop: n. 啪的一声，数据弹出的声音），把数组末尾的最后一项移除，减少length的值，然后返回那个被移出的项。 5.2.4队列方法队列数据结构的访问规则是FIFO（Firest-In-First-Out，先进先出，派对模型），队列在列表的末端添加项，从列表的前端移除项。实现这两个操作的数组方法是shift（），它能移出数组的第一项，并返回该项。同时将数组长度减1。结合使用shift（）和 push（）方法，可以像使用队列一样使用数组。 5.2.5重排序方法数组中已经存在两个可以直接用来重排序的方法：reverse（）和sort（）。 reverse（）故名思义会翻转数组项的顺序。数组是被直接覆盖，不是翻转它的副本。在默认情况下，sort（）方法按升序排列数组项——即最小的值位于前面，最大的值排在最后面。但sort（）的大小即使数组是数字也不是按照数字大小排序的，而是都会先在内部通过toString( )转换为字符串，通过比较字符串按大到小排序。例子：123var values = [0,1,5,10,15];values.sort( );alert(values); //0,1,10,15,5 可见，即使例子中值的顺序没有问题，但sort( ) 方法也会根据测试字符串的结果改变原来的顺序。(其实JS中的sort()方法是按比较值的Unicode顺序进行排序的)这种排序方式很明显不是最佳方案，因此sort（）方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值前面。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等，则返回0，如果第一个参数应该位于第二个参数之后，则返回一个正数。以下就是一个简单的比较函数：123456789function compare(value1,value2)&#123; if(value1&lt;value2)&#123; return -1; &#125;else if(value1&gt;value2)&#123; return 1; &#125;else&#123; return 0; &#125;&#125; 只要将其作为参数传递给sort（）方法即可。例子：123var values = [0,1,5,10,15];varlues.sort(compare);alert(values); //0,1,5,10,15 如果想要产生降序的结果，只要交换比较函数返回的值即可。（把return 1 和return -1交换位置） ✎注意：reverse（）和sort（）方法的返回值是经过排序之后的数组（不会变成字符串）。对于数值类型或者其valueOf( ) 方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。对于这个函数只要用第二个值减第一个值即可。1234//用两行代码实现数值类型数组的升降排序function compare(value1,value2)&#123; return value2-value1; //return value1-value2就是降序&#125; 由于比较函数通过返回一个小于零，等于零，或大于零的值来影响排序结果，因此减法操作就可以适当地处理所有这些情况。 5.2.6操作方法操作方法就是讲操作数组的各种方法。第一个方法是concat（）。可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。如果没有给concat（）传递参数，它就只会复制当前数组并返回副本。如果传递给concat（）方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中，如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。例子：12345var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);alert(colors); //red,green,bluealert(colors2); //red,green,blue,yellow,black,brown 下一个方法是slice（）。它能够基于当前数组中的一或多个项创建一个新数组。slice（）方法可以接受一或两个参数。即要返回项的起始位置和结束位置（位置从0开始算）。只有一个参数：slice（）返回从该参数指定位置开始到当前数组末尾的所有项。两个参数：返回起始和结束位置之间的项——但不包括结束位置的项。且slice（）方法不会影响原始数组。例子：123456var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);alert(colors2); //green，blue,yellow,purplealert(colors3); //green,blue,yellow ✎注意：如果slice方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含5项的数组上调用slice（-2，-1）与调用slice（3，4）得到的结果相同。如果结束位置小于起始位置，则返回空数组。 第三个是splice（）方法。最强大的数组方法，其有很多种用法。splice（）的主要用途是向数组的中部插入项，但使用这种方法的方式有如下3种。 删除：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。例如：splice（0，2）会从位置0开始，删除数组中的前两项。 插入：可以向指定位置插入任意数量的项。只需3个参数：起始位置，0（要删除的项数，不删就是0）和要插入的项，如果要插入多个项，可以再传入第四，第五等任意多个项。例如，splice(2,0,”red”,”green”)会从当前数组的位置2开始插入字符串“red”和“green”（“red”会成为在位置2的值，“green”在位置3） 替换：可以向指定位置插入任意数量的项，同时删除一定数量的项，插入的项数不必与删除的项数相等。例如：splice（2，1，“red”,”green”）会删除当前数组位置2的项，然后从位置2开始插入字符串“red”和“green”。“red”在位置2。splice（）方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项就返回一个空数组）。下面是三种用法的例子：1234var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var removed = colors.splice(0,1);alert(colors); //green，bluealert(colors); //red，返回被删除的那一项 5.2.7位置方法ECMAScript5为数组添加的两个位置方法：indexOf( ) 和lastIndexOf( ) 都接收两个参数：要查找到项，表示查找起点的索引（可选，起点也可以被搜索到）。indexOf（）是从前向后查找，lastIndexOf（）是从后向前查找。两个方法返回的都是查找的项在数组中的位置。查找不到则返回-1。lastIndexOf（）返回的位置也是从头开始计的，虽然是从最后开始找。在用第一个参数与数组中的项比较时，使用的是全等操作符（“===”），非常严格。例子：123456789101112131415var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)) // 3alert(numbers.lastIndexOf(4)) // 5alert(number.indexOf(4,4)); //5alert(number.lastIndexOf(4,4)) //3 第二个参数是4，则相当于数组只有前面五项[1,2,3,4,5]以5为最后一项开始找。var person = &#123;name : &quot;Nicholas&quot;&#125;;var people = &#123;name : &quot;Nicholas&quot;&#125;;var morePlople = [person];alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person))//0 比较难懂的是lastIndexOf（）加第二个参数，测试了一下终于自己测出来。lastIndexOf（）的第二个参数查找起点的索引也是从头开始计算的，比如第二个参数是2，则相当于整个数组只剩前面的0，1，2.后面的项相当于“不见了”，然后以第2为最后一个位置开始查找数组。支持indexOf( ) 和lastIndexOf( )的浏览器有 IE9+(IE9+的意思用IE9也能成功)，Safari 3，Opera 5和Chrome. 5.2.8迭代方法ECMAScript5为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和运行该函数的作用域对象（可选）——影响this的值。传入这些方法中的函数（函数由我们自己编写）会接收三个参数（要写在函数的参数栏里）：数组的项的值（不能说“数组的项”，因为数组的项包括数组的项的值和位置），项的位置，数组对象（迭代方法是数组对象的方法，对象才有方法，是数组，对象）本身。 以下是这5个迭代方法： every（）：让数组中的每一项都过一遍every（）里的那个函数，全部返回true了，every（）方法才返回true。 some（）：让数组中的每一项都过一遍some（）里的那个函数，只要有一个返回true，some（）方法就返回true。 filter（）：筛选器。数组的每一项都过一遍filter（）里的函数，只返回一个通过了“考验”的数组。 forEach（）：对数组运行给定的函数，这个方法没有返回值。 map（）：对数组每一项过一遍map（）里的函数，返回经过这个函数“加工”过的结果组成的数组。 下面是every（）和some（） 的例子，返回true,false123456789var numbers = [1,2,3,4,5,6];var result = numbers.every(function(item,index,array)&#123; return item&gt;2;&#125;)console.log(result); //falsevar result = numbers.some(function(item,index,array)&#123; return item&gt;2;&#125;)console.log(result); //true 两个例子的ES6写法：12345let result = numbers.every((item,index,array) =&gt; item&gt;2);console.log(result); //falselet result = numbers.some((item,index,array) =&gt; item&gt;2);console.log(result); 使用的是ES6的箭头函数，适合简短的函数，不需要命名，箭头后面默认是return，具体看阮一峰的文档。 下面是filter（）的例子，返回一个由通过函数筛选条件的数组12345var numbers = [1,2,3,4,5,6];var result = numbers.filter(function(item,index,array)&#123; return item&gt;2;&#125;)console.log(result); // [3,4,5,6] 下面是运行map（）的例子，返回一个经过map（）内函数加工的数组12345var numbers = [1,2,3,4,5,6];var result = numbers.map(function(item,index,array)&#123; return item*2;&#125;)console.log(result); // [2,4,6,8,10,12] 下面是forEach（）的例子，这个方法（请严谨地说——方法，不是函数，它是数组对象的，方法）没有返回值。本质上相当于对封装了一个for循环给数组。1234var numbers = [1,2,3,4,5,6];numbers.forEach(function(item,index,array)&#123; console.log(item); //会像使用了for循环打印7次&#125;) 亲测在forEach（）里对数组的项进行赋值、计算得到的结果不会影响本来的那个数组，甚至在函数内打印出对每项经过计算后的数组，得到的数组也是没有改变的原来的数组。因为函数的参数是按值传递的。例子：1234567var numbers = [1,2,3,4,5,6];numbers.forEach(function(i,u,a)&#123; i=i+1; console.log(i); //每一项都打印出来，都被+1 console.log(a); //打印七次数组，每次都是原来那个数组[1,2,3,4,5,6]&#125;)console.log(numbers); //外面的数组没有改变，仍是[1,2,3,4,5,6] 以上every（），filter（） ，some（） ，map（） ，forEach（）只在IE9+，Firefox2+，Safari 3+，Opera 9.5+和Chrome有效。 打完上面那句因为函数的参数是按值传递的后发现一个有意思的事情，函数参数是按值传递没错，但数组是对象，函数的参数也是原来那个函数的指针，在函数里改变数组内的值，原来的那个数组也会被改变才对。经过亲自测试，当把数组当作参数传入函数，在函数内对数组内的值+1，在外部打印的数组也是经过+1的了！所以上面好像也不是因为函数的参数是按值传递的这个原因。大概forEach（）方法不会返回任何值所以也不会改变任何值吧，而console.log(a)打印出来的就是参数里的那个a，所以是原来那个参数。例子：123456789101112131415161718var numbers = [1,2,3,4,5,6];function add(array)&#123; for (var i = array.length - 1; i &gt;= 0; i--) &#123; array[i]+=1; &#125; console.log(array);&#125;add(numbers); //把数组作为参数传入函数，对每个值+1console.log(numbers); //外部的numbers也被改变[2,3,4,5,6,7]//于此同时用基本类型值number做同样的实验，全局的num在函数内经过计算后在全局打印出来的num还是等于6var num=6;function addOne(num)&#123; num+=1; console.log(num);&#125;addOne(num);console.log(num); //6 5.2.9归并方法ECMAScript5还新增了两个归并数组的方法：reduce（）和reduceRight（）这两个数组会迭代所有项，然后构建一个最终返回的值。两个方法只有一个区别：一个从头开始归并，一个从后向前归并。两个方法都接收两个参数：一个在每项上调用的函数和作为归并基础的初始值。传进这两个方法的函数接收4个参数：前一个值，当前值，项的索引和数组的对象。这个函数返回的任何值都会作为第一个参数（“前一个值”）自动传给下一项。第一次迭代发生在数组的第二项上（在这句话体会“迭代这个词的意思”），前一个值在第一次迭代时是数组的第一项，第二个参数是数组的第二项。第二次迭代的第一个参数就是第一项和第二项迭代（迭代有可能是加减乘除或其他计算方式）后的值。下面是用reduce（）方法求数组uoyou值之和的操作：12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev,cur,index,array)&#123; return prev+cur;&#125;);alert(sum); //15 第一次执行回调函数，prev是1，cur是2.第二次，prev是3（1加2的结果），cur是3（数组第三项）。这个过程持续到把数组最后一项访问到。最后返回结果。reduceRight( )方法不讲了区别只是开始的顺序是从后面开始罢了。 支持这两个归并函数的浏览器有： IE9+，Firefox3+，Safari 4+，Opera 10.5+和Chrome。（可以看出这两个方法比上面5个迭代方法要更难兼容。所有浏览器的版本都上了一个数，IE仍是9+才可以访问）。 5.3Date类型要创建一个日期对象，同样使用new操作符和Date构造函数即可。1var now = new Date(); 不向Date构造函数传递函数的情况下，新创建的对象默认自动获得当前日期和时间。如果想根据特定的日期和时间（日期：年月日；时间：时分秒），理论上应该传入表示该日期的毫秒数（即从UTC时间1970年1月1日午夜起至该日期经过的毫秒数）。当然JavaScript不可能这么不人道，ECMAScript提供了两个方法：Date.parse( ) 和Date.UTC( )这两种方法可以让你直接写入正常人类的日期即可使日期对象具备特定的日期和时间。两种方法表示日期的格式不同。而且也不用傻傻地写123//不用这么做！var someDate = new Date(Date.parse(&quot;May 25,2004&quot;));var allFives = new Date(Date.UTC(2005,4,5,17,55,55)); Date构造函数已经自带了这两个方法，如果直接写入“May 25,2004”，函数会自动调用Date.parse( )。如果写入的是2005，4，5，17，55，55，构造函数也会自动调用Date.UTC( )。所以不用像上面那样写。正确的写法：12var someDate = new Date(&quot;May 25,2004&quot;);var allFives = new Date(2005,4,5,17,55,55); ✎注意：第二个日期表示的是2005年5月5日，因为月份是从0开始计算的，0-11。 ECMAScript5添加了Date.now( )方法，返回程序运行到这个方法时的日期和时间的毫秒数，可以用来当计时器用，简化了使用Date对象分析代码的工作（不用专门构建Date对象就可以调用的方法）。例子：12345var start = Date.now( );doSomething();var stop = Date.now();result = stop - start; //通过start-stop可以得出运行doSomething()具体用了多少时间 又是ECMAScript5才发布的方法，所以能用的浏览器包括： IE9+，Firefox3+，Safari 3+，Opera 10.5+和Chrome。不支持这个方法的浏览器中，可以使用+操作符获取Date对象的时间戳，也可以达到同样的目的。12345var start = +new Date();doSomething();var stop = +new Date();result = stop - start; 5.3.1继承的方法与其他引用类型一样，Date类型也重写了toLocaleString（）、toString（）和valueOf（）方法。总而言之这一段就是告诉我们用toLocaleString（）和toString（）写出来的日期格式在同一个浏览器中是不一样的。恐怖的是根据浏览器的不同，每个浏览器用toString（）输出的结果也是不一样的。toLocalString（）同理。书里还有一句话：事实上，toLocaleString（）和toString（）在浏览器上显示格式的差别仅在调试代码时比较有用，在显示日期和时间上没有什么价值。 至于Date类型中的valueOf（）方法则根本不会返回字符串，而是返回日期的毫秒表示（ZZ）。 还有一点是：日期是可以比较大小的，下面例子：12345var date = new Date(2007,0,1);var date = new Date(2007,1,1);alert(date1&lt;date2); //truealert(date1&gt;date2); //false 比较早的日期小于比较晚的日期。 5.3.2日期格式化方法介绍了toDateString（）,toTimeString（） ,toLocalDateString（） ,toLocaleDateString（） ,toLocaleTimeString（） ,toUTCString（） ,这几个根据特定实现的格式或特定地区的格式显示的日期格式。与toLocaleString（）和toString（）相同，以上几个方法的显示格式也会因浏览器的不同有差异。没有哪一个方法能够用来在用户界面中显示一致的日期信息。 5.3.3日期/时间组件方法介绍了一大堆getFullYear（）、getMonth（）等方法，有用到自然会去百度，不写。 5.4RegExp类型正则网上有很多现成的正则案例，本人真的看到正则头大，所以这部分是跳过的，有兴趣的可以先看看JavaScript正则表达式视频教程-慕课网学习。","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"高程","slug":"高程","permalink":"https://millionqw.github.io/tags/高程/"}]},{"title":"《JS高级程序设计》第四章 作用域和内存问题","date":"2017-07-03T04:38:37.000Z","path":"2017/07/03/《JS高级程序设计》第四章-变量、作用域和内存问题/","text":"&ensp;&ensp;把2016年寒假写的对《JavaScript高级程序设计》的笔记写在博客上，同时回看加修改，同时也更新到简书上。尽量一天一篇一章。 第四章 变量、作用域和内存问题4.1基本类型和引用类型的值ECMAScript变量可能包含两个不同类型数据的值：基本类型值和引用类型值。基本类型值指的是简单的数据段（Boolean类型、Number类型、String类型、Undefined、Null） 引用类型值指那些可能由多个值构成的对象（Object类型、Array类型、Date类型、RegExp类型、Function类型）&gt;ES6中新增了Symbol,是JavaScript的第七种数据类型。4.1.1动态的属性基本类型值和引用类型值的区别一：对于引用类型值，我们可以为其添加或删除属性和方法，但是基本类型值没有属性和方法。例子:var person = new Object(); var name = “Nicholas”person.name = “Nicholas”; name.age = 27;alert(person.name); //“Nicholas” alert(name.age) //undefined以上代码一创建了一个对象并给他一个name属性，又通过alert访问成功。代码二给字符串name定义了一个age属性，但当我们访问的时候会发现这个属性不存在。这说明只能给引用类型值动态地添加属性，以便将来使用。4.1.2复制变量值基本类型值和引用类型值的区别二：在复制变量的时候，复制基本类型值和引用类型值也是有区别的。如果只是复制基本类型值，那就是简单复制到为新变量分配的位置上没毛病。当复制的是引用类型的值时，同样会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个新的副本实际上是一个指针，复制结束后，两个变量实际上将引用同一个对象。因此，如果复制的是引用类型值，当改变其中一个变量，就会影响另一个变量。例子：var obj1 = new Object();var obj2 = obj1;obj1.name=”Nicholas”;alert(obj2.name); //“Nicholas”变量对象中的变量保存在堆中的对象之间的关系如图：图片来自《JavaScript高级程序设计》可以看到当变量复制后，指针仍然指向一开始的Object，而不是复制出多一个Object。.4.1.3传递参数ECMAScript中所有函数的参数都是按值传递的。（无论参数是引用类型值和基本类型值）。也就是说，把函数外部的值复制给函数内部的参数，就和4.1.2复制变量值的原理一样，把一个变量复制到另一个变量（函数的参数）一样。有不少开发人员在这点会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。————————–讨论参数传递的是引用类型值的情况————————–function setName(obj){ obj.name = “Nicholas”;}var person = new Object();setName(person);alert(person.name); //“Nicholas”以上代码创建了一个对象person，这个变量被传递到setName（）函数中后被复制给了obj，在这个函数内部，obj和person引用的是同一个对象。换句话说，即使这个变量是按值传递的，obj也会按引用来访问同一个对象（遵循4.1.2的复制变量值原理）。于是当为函数内部为obj添加name属性后，函数外部的person也会有所反映。因为person指向的对象在堆内存中只有一个，而且是全局对象。有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的（大错特错）。为了证明对象是按值传递的。看下面的例子:function setName（obj）{ obj.name = “Nicholas”; obj = new Object(); obj.name = “Greg”;}var person = new Object();setName(person);alert(person.name); //“Nicholas”这段代码增加了两行，为obj重新定义了一个对象，第二行为该对象定义了一个带有不同值的name属性。如果person是按引用传递的，那么person最后会被自动修改为指向其name属性值为“Greg”的新对象。但是在函数外访问person.name时，显示的值仍然是”Nicholas”。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了(这个函数范围的局部对象)。而这个局部对象会在函数执行完毕后立即被销毁。4.1.4检测类型检测变量类型的方法有两种，一种是检测基本类型值的，用typeof，另一种是检测引用类型值的，用instanceof。typeof操作符是确定一个变量是string,boolean,number，undefined的最佳工具，如果变量是对象（根据规定，所有引用类型的值都是Object的实例）或null，则typeof操作符返回的值会是“object”。例子：var s = “Nicholas”, b = true, i = 22, u , n = null, o = new Object(), d = new Date();alert(typeof s); //stringalert(typeof i); //numberalert(typeof b); //booleanalert(typeof u); //undefinedalert(typeof n); //objectalert(typeof i); //objectalert(typeof d); //object因为typeof只能检测基本类型值，检测引用类型值时只会返回object，所以ECMAScript又提供了一个insanceof操作符，用法跟typeof不同，且只返回true 或 false。✎另类的情况使用typeof操作符检测函数时，该操作符会返回”function”。在Safari 5 及之前版本和Chrome 7及之前的版本中使用typeof检测正则表达式时，由于规范的原因，这个操作符也返回“function”。ECMA-262规定任何在内部实现 [ [ call ] ] 方法的对象都应该在应用typeof操作符时返回“function“。由于上述浏览器(Safari 5,Chrome 7)中的正则表达式也实现了这个方法，因此对正则表达式应用typeof会返回“function”。在IE和Firefox中，对正则表达式应用typeof会返回“object”. 如果变量是给定引用类型（根据它的原型链来识别，第6章将介绍原型链。#原书句）的实例那么instanceof操作符就会返回true。例子： alert(person instanceof Object); //变量person是Object吗？ alert(colors instanceof Array); //变量colors是Array吗？ alert(pattern instanceof RegExp); //变量pattern是RegExp吗？ //亲测左右两边位置不可互换，互换不会出现提示框 因为根据规定，所有引用类型的值都是Object的实例，因此把Date，Array，RegExp等引用类型值用instanceof 与Object验证时，始终都会返回true。用instanceof操作符检测基本类型值时，该操作符时钟返回false，因为基本类型不是对象。 4.2执行环境及作用域 作用域链重要的一点就是内部执行环境可以使用其外部环境的变量和函数，并且可以改变那个变量的值，只要那个变量不是被当作参数传进去的而是直接使用的。（当作参数传入的是按值传递，改变的是复制出来的变量，不会改变原来的变量） 执行环境（execution context）和作用域其实超级简单。每个执行环境都有一个与之关联的变量对象（variable object），环境变量中定义的所有变量和函数都保存在这个对象中。但是我们无法用代码访问到这个变量对象。但解析器在处理数据时会在后台使用它。 全局执行环境是最外围的执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是window对象（第七章将详细讨论），因此，所有全局变量和函数都是作为window对象的属性和方法创建的（window对象是个变量对象，全局变量和函数是它的属性和方法）。某个执行环境（例如一个函数）中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出（网页关闭或浏览器关闭时才被销毁）） > &ensp;&ensp;在Node.js中的全局执行环境是global 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权交给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制在控制。 当代码在其中一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的最前端，始终都是当前执行代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中不存在）。作用域链中的下一个变量对象来自包含它的外部环境，而再下一个变量对象则来自下一个包含环境。这样，一直延伸到全局执行环境； 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程从作用域链最前端开始，然后逐级向后回溯，直到找到标识符为止（如果找不到，就会发生错误） 例子：var color = \"blue\"； function changeColor(){ if(color == \"blue\"){ color = \"red\"; } } changeColor(); alert(color); // \"red\" 在这个例子中，函数changeColor( )的作用域链包含两个对象：它自己的变量对象（其中定义着arguments对象）和全局环境的变量对象。可以在函数内部访问变量color，就是因为可以在这个作用域链中找到它。 此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面这个例子所示： var color = \"blue\"; function changeColor(){ var anotherColor = \"red\"; function swapColors(){ var tempColor = anotherColor; anotherColor = color; color = tempColor; //这里可以访问color，anotherColor 和 tempColor } //这里可以访问color和anotherColor，但不能访问tempColor swapColors(); } //这里只能访问color changeColor();以上代码涉及三个执行环境：全局环境、changeColor（）的局部环境和swapColor（） 的局部环境。swapColor的局部变量中有一个变量tempColor，该变量只有在swapColor环境中能访问到，但是swapColor（）内部可以访问其他两个环境中的所有变量。 越在内部的局部环境，作用域链越长。对于这个例子中的swapColor（）而言，其作用域链中包含3个对象：swapColor( )的变量对象、changeColor（）的变量对象和全局对象。swapColor（）的局部环境开始时会现在自己的变量对象中搜索变量和函数名，如果搜索不到则再搜搜上一级作用域链。changeColor()的作用域链中只包含两个对象：它自己的变量对象和全局对象。也就是说，它不能访问swapColor（）的环境。 4.2.1延长作用域 有些语句可以在作用域链前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象，具体来说，就是当执行流执行到下列任何一个语句时，作用域链会得到增长 * try-catch语句的catch块 * with语句 这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中，对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。例子： function buildUrl(){ var qs = \"?debug=true\"; with(location){ var url = href + qs; } return url; } ✎添加一个with语句块的知识点当在with语句块中使用方法或者变量时，程序会检查该方法是否是本地函数，变量是否是已定义变量，如果不是，它将检查伪对象（with的参数），看它是否为该对象的方法，属性。如上面例子with语句块中的href，本地无定义，则with语句块会自动加上location.href，所以href实际上为href。这个就是with的功能。with 语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多数情况下，如果可能，最好避免使用它。在此，with语句接收的是Location对象，因此其变量对象中就包含了location对象的所有属性和方法，而这个变量对象被添加到了作用域链的最前端，buildUrl（）函数中定义了一个变量qs。当在with语句中引用变量href时(实际引用的是location.href)。可以在当前执行环境的变量对象中找到。当引用变量qs时，引用的则是在buildUrl( )中定义的那个变量，而该变量位于函数环境的变量对象中。至于with语句的内部，则定义了一个名为url的变量，因而url就成了函数执行环境的一部分，所以可以作为函数的值被返回。 4.2.2没有块级作用域 ✎添块级作用域任何一对花括号中的语句都属于一个块，在这之中定义的所有变量在代码块之外都是不可见的，我们称之为块级作用域。作用域有两种，块级作用域和函数作用域讲到这就好理解。JS没块级作用域就是说在for循环和if语句块中定义的变量是可见的，可以被外部使用的，但像其他的语言Java,C,C#语言中，在for，if语句中定义的变量在语句执行完毕之后就会被销毁。但在JavaScript中，if语句中的变量声明会将变量添加到当前执行环境中。注意只是当前执行环境，如果for循环是在一个函数里，则定义的i在函数里是确定的数，在全局环境中仍然是not defined。例子： if(true){ var color = \"blue\"; } alert(color) //\"blue\" for(var i=0; i","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"高程","slug":"高程","permalink":"https://millionqw.github.io/tags/高程/"}]},{"title":"第一个hexo博客终于建成","date":"2017-07-02T13:20:13.000Z","path":"2017/07/02/第一个hexo博客终于建成/","text":"折腾了半个下午加半个晚上，终于建成了自己的第一个hexo博客，也是自己的第一个博客ヽ(^･ω･^)丿 从开始接触技术以来，就一直知道技术人员都要有一个自己的博客，接触了两年技术，学习过程中也有把知识记录下来的习惯，但是都是记录在印象笔记里，也在博客园开过一个博客，但一直都没在那里动过笔，大概就是等一个用Hexo博客的机会吧，如果我早在博客园写日记，估计就懒得搬过来了。 虽然hexo的SEO并不好（看到别人的博客都是在简书上转过来的），但是有了博客就有了一个精神角落，放自己的技术，也督促自己记录下学到的东西吧。 第一篇博文，就记录一下自己是怎么搭建这个博客的吧！ 真的想动手搭博客是6月以来看到github上一些大神的博客，看到他们的博客都好漂亮，后来才知道是用hexo搭起来的（之前一直觉得“自己的博客”应该是从html到css都是自己写的），后来也看了一些搭hexo博客的文章，终于在6月底考完试后开始在今天做自己的博客。 首先，是阅读了 @代码咖啡 在简述上发的这篇 20分钟教你使用hexo搭建github博客 文章非常浅显易懂，这里在这篇文章的基础上补上一些我遇到的问题和我是怎么解决的： 文章中的一个步骤： 这里的终端（terminal）指的是git这个版本控制系统，需要下载在电脑中，具体的使用教程看廖雪峰大大的教程，但是在搭博客过程中我们知道怎么安装就好，然后把git bash当命令行用。文章中的命令行都是在git bash输入的。 后面的node.js和hexo的安装因为自己有学一点点node的知识所以够用，不懂的可以留言，我可以帮助你解决问题！ 还有一个是初始化博客后博客文件夹的数量会与作者的不一样，貌似会少一两个，不过不要紧接着进行。 后面的 最后的timezone不要因为你不是上海的就改成你当地的地名，根据标准，中国区只能写Asia/Shanghai、Asia/Hongkong、Asia/Taipei、Asia/Harbin. 之后@代码咖啡 又发了一篇博文 【干货】2个小时教你hexo博客添加评论、打赏、RSS等功能 是对hexo博客扩展功能的补充，他使用的博客主题是NexT，所以就这个主题做了介绍。 我使用的是yilia这个主题，似乎很多人用的都是这个类似的主题，非常受欢迎，github上有3.6k+个star。使用的时候要对配置进行一些修改。 注意在README里说到的配置_config.yml是配置themes/yilia下的_config.yml，不是根目录下的_config.yml。可以在主题里的_config.yml加上你的微博，github，知乎等链接，如果没有的，可以使用#井号注释掉。 另外当你使用这个主题的时候，点开左侧边栏的”所有文章/关于我”，打开的侧边栏会提示缺少模块，按提示下载模块后在主目录下的_config.yml配置给出的那一段配置即可，注意缩进，_config.yml的配置如果缩进错误是不生效的。 使用博客中出现的问题及解决办法 刚开始用这个主题的时候是没有头像的，一开始把图片放在source的img下用相对路径引入发现没有效果，后来用的是微博的图床，一些人似乎用了图床后也显示不出来，解决方法参考:解决头像的问题 当你更新了themes下的_config.yml且git pull后用了hexo clean hexo g //产生静态内容 hexo d //发布到github 仍然没有反应的时候，不要急，确认自己的配置无误的话，只要多刷新几遍即可，应该是网络原因造成的更新延迟。几秒后更改就会生效 我出现的问题是头像可以显示，但是样式不好看： 用F12修改了一下样式，参考了上一个问题的解决方法，在themes\\yilia\\layout_partial下找到left-col.ejs文件，在第6行中的 &lt;a href=&quot;/&quot; class=&quot;profilepic&quot;&gt; &lt;img src=&quot;&lt;%=theme.avatar%&gt;&quot; class=&quot;js-avatar&quot;&gt; &lt;/a&gt; 在img标签里添加一行行内样式： style=”position:absolute; left:-30%; top:-5%; max-width:150%; left和top的值根据你自己的图片位置调整。 如果在移动端上头像的显示仍然不理想，可以在themes\\yilia\\layout_partial下找到mobile-nav.ejs文件，在第十行&lt;img src=&quot;&lt;%=theme.avatar%&gt;&quot; class=&quot;js-avatar&quot;&gt;中添加一句style=”min-width:130%;”即可，具体数值仍然根据自己的情况调整。 几个常用的hexo命令 防止忘了又要百度，把几个命令记下来。 新建文章 hexo new \"文章标题\" 清除缓存、生成静态文件、发布 hexo clean hexo g hexo d 修改主题配置后更新 cd themes/yilia git pull 要总结的似乎就这些，接下来计划把上个寒假花了10几天写的《Javascript高级程序设计》笔记搬到上面来，可以的话，一天整理一篇。同时回顾学过的东西，再添加修改原有的笔记。最后，晚安~","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"生活","slug":"生活","permalink":"https://millionqw.github.io/tags/生活/"}]},{"title":"文章标题","date":"2017-07-02T08:20:23.000Z","path":"2017/07/02/文章标题/","text":"你好，欢迎来到我的个人技术博客。","tags":[]}]