[{"title":"《Javascript》高级程序设计 第五章 详细解释引用类型（上）","date":"2017-07-06T13:45:07.000Z","path":"2017/07/06/Javascript》高级程序设计 第五章 详细解释引用类型（上）/","text":"第五章 引用类型引用类型的值（对象）是引用类型的一个实例。如前所述，对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身也是一个函数，只不过该函数是出于创建新对象的目的而定义的。例子：1var person = new Object(); 这行代码创建了一个Object这个引用类型的新实例，然后把该实例保存在了变量person中。（这句话特别有意思，如果我用自己的话说，会说“创建了一个叫person的Object的新实例，而不会说先创建了实例再把实例保存在person中”）使用的构造函数就是Object( )。它为新对象（person定义了默认的属性和方法）。ECMAScript提供了很多原生引用类型（例如Object( ),Date( ),RegExp( )）。以便开发人员完成常见的计算任务。 5.1Object类型创建Object类型的方法有两种。第一种，使用new操作符后跟Object构造函数。例子：123var person = new Object();person.name = &quot;Nicholas&quot;;person.age = 29; 第二种，用对象字面量表示法。这种方法更被开发人员所接受，最推荐使用。代码量少，且给人封装数据的感觉。实际上，对象字面量也是向函数传递大量可选参数的首选方式。例子：1234var person = &#123; name : &quot;Nicholas&quot;, //属性名也可以用字符串如：&quot;name&quot; : &quot;Nicholas&quot; age : 29 // &quot;age&quot; : 29&#125; 在对象字面量中使用逗号来分隔不同的属性，因此“Nicholas”后面记得加逗号，最后一个属性后面不能加逗号。否则IE7及更早版本和opera会出现错误。✎注意：使用对象字面量定义对象时，并没有调用到Object函数（即内在原理不是Object函数，Firefox 2以及更早版本的Firefox会调用Object函数，但Firefox3之后就不会了。） ✎关于表达式上下文（expression context）和语句上下文（statement context）在用对象字面量定义新对象的例子中，左边的花括号“｛”表示对象字面量的开始，因为它出现在了表达式上下文（expression context）中（”person=”，等号的后面）。ECMAScript中的表达式上下文指的是该上下文期待一个值（表达式）。赋值操作符（“=”）表示后面是一个值（这里的值是一个对象，不要直觉觉得值就是一个数字），所以左花括号在这里表示一个表达式的开始。同样的花括号如果出现在一个语句上下文（statement context）中，例如跟在 if 语句条件的后面，则表示一个语句块的开始。 对象字面量除了可以用来定义新对象，当函数需要大量可选参数时，使用对象字面量也是不错的选择。例子：12345678910111213141516171819202122function displayInfo(args)&#123; var output = &quot;&quot;; if(typeof args.name == &quot;string&quot;)&#123; output += &quot;Name:&quot; + args.name + &quot;\\n&quot;; console.log(output); &#125; if(typeof args.age == &quot;number&quot;)&#123; output=&quot;&quot;; output += &quot;Age&quot; +args.age + &quot;\\n&quot;; console.log(output); &#125;&#125;//用对象字面量传递参数，这时候args就是对象，name,age就是args的属性displayInfo(&#123; name:&quot;Nicholas&quot;, age:29&#125;)displayInfo(&#123; name:&quot;Greg&quot;&#125;) 这个例子中，函数displayInfo（）接受一个名为args的参数，这个参数可能带有一个名为name或age的属性，有可能同时有也可能都没有。在函数内部用typeof操作符检测每个属性是否存在，再根据相应属性来构建显示信息。对象字面量传递参数法特别适合在需要向函数传递大量可选参数的情形。最好的做法是：对那些必需值使用命名参数（直接写在括号内），用对象字面量来封装多个可选参数。 ✎访问对象属性时用点表示法或者是方括号“[ ]”的取舍仍然以上面的person对象为例子。使用方括号访问对象属性的时候，千万千万记得要给对象属性加双引号（亲测单引号也可以）才能真正访问到那个对象属性，这是个很容易出现错误但找不到原因的地方。例子：12alert(person[&quot;name&quot;]); // Nicholasalert(person[name]); // undefined 使用方括号的优点一是，可以使用变量间接地访问对象属性。例子：123var propertyName = &quot;name&quot;; // 必须加双引号，否则是undefinedalert(person[propertyName]); // Nicholasalert(person.name); // undefined 方括号的优点二：如果对象属性名中包含会导致语法错误的字符（比如空格），或者属性名使用的是关键字或保留字，也可以使用方括号表示法。例子：123person[&quot;first name&quot;] = &quot;Nicholas&quot;;person[&quot;last-name&quot;] = &quot;Tom&quot;;alert(person[&quot;first name&quot;]); 有空格，“ - ”等会导致错误的属性名，只能通过方括号语法赋值（对象字面量也不行）和访问。（亲测）当然，除非是使用变量来访问属性，或者属性中带有特殊字符，否则还是建议用点表示法访问。 5.2Array类型avaScript的数组类型与其他语言的数组类型的最大不同，就是JavaScript数组的每一项可以保存任何类型的数据，比如第一项保存数字，第二项保存字符串，第三项保存对象。而且可以随着数据的添加自动增长以容纳新增数据。创建数组的两种方法。方法一是使用Array构造函数，例子：1var colors = new Array(); 如果预先知道了数组是多少位，也可以给Array构造函数直接传递数量，该数字就会成为该数组的length属性的值1var colors = new Array(20); // colors.length = 20 也可以直接向Array构造函数直接传递数组包含的值1var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;orange&quot;); 在使用Array构造函数的时候，可以省略“new”操作符。省略“new”操作符的效果与添加“new”的效果相同。第二种创建数组的方法：数组字面量表示法。（与对象一样，使用数组字面量表示法时也不会调用Array( )构造函数（Firefox3及更早的版本除外））1234var colors = [ &quot;red&quot;, &quot;blue&quot;, &quot;orange&quot; ];var names = [];var values = [1,2,] //不要这样做，IE8及之前的版本会出BUGvar options = [, , , , ,] //不要这样做，IE8及之前的版本会出BUG 第三种情况在IE8及之前的版本中，数组values会有1，2，undefined三个值，其他浏览器则只有1和2.第四种的情况与第三种类似，IE会创建6个值，其他浏览器会创建5个，因为有浏览器差异，所以强烈建议不这么做。不过正常人谁这么做。把玩Array引用类型的属性length数据的length属性有一个特点——可写可读。如果设置这个属性的值比现有数组长度短，则设置的长度后面的数组的值就会被删除。如果设置length的值比现有的length大（比如设置array.length=100），则数组的长度变为100，空位置为undefined。利用length也可以很方便地在数组末尾添加新的值。例子：12var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;orange&quot;]; // colors.length = 3;colors[colors.length] = &quot;black&quot; // clolors[3] = &quot;black&quot;; 当把一个值放在超出当前数组大小的位置，数组就会重新计算长度，长度值变成最后一项的索引(索引就是从0开始的)加一。例子：123var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;orange&quot;];var colors[99] = &quot;black&quot;;alert(colors.length) //100 中间colors[3]到colors[99]的值都是undefined。 数组的最大长度可以到4294967295（算冷知识吧）如果超过这个数就会出现异常。如果一个数组的大小接近这个上限值，会导致运行时间超长的脚本错误。 5.2.1检测数组对于一个网页或一个全局作用域而言，使用instanceof操作符就能得到满意的结果。而instanceof操作符的问题在于，它假定只有一个全局执行环境。如果网页红包含多个框架，那实际上就会出现两个及以上的执行环境，从而存在两个以上不同版本的Array构造函数，如果从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。为了解决这个问题，ECMAScript5新增了 Array.isArray( ) 方法，这个方法的目的是最终确定这个值到底是不是数组，而不管它是在哪个全局执行环境中创建的（我也不知道为什么多个执行环境下有多个不同的构造函数就使instanceof操作符无法检测数组。）该方法用法如下：123if(Array.isArray(value))&#123; //对数组执行操作&#125; 5.2.2转换方法前面章节提过，所有对象都自带 toLocalString( )、toString( ) 和 valueOf( )方法。其中，调用数组的toString( )方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用valueOf( )返回的还是数组。实际上，toString( )方法为了创建这个字符串会调用数组每一项的toString（）方法（原理）。例子：1234var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;orange&quot;];alert(colors.toString()); //red,blue,orangealert(colors.valueOf()); //red,blue,orangealert(colors); //red,blue,orange 第一个alert显式地调用了toString方法（相对第三个alert）,每个值的字符串表示拼接成了一个字符串，中间用逗号分隔。第二个alert调用valueOf方法，最后一行代码直接将数组传递给alert。由于alert( ) 要接收字符串参数，所以它会在后台自动调用toString方法（相对第一个alert的显示调用），由此得到与第一个alert相同的结果。（用typeof 和 valueOf亲测 colors.valueOf( )的类型是Array,colors.toString( ）的类型是String） ✎toString（）和toLocalString（）的不同toLocaleString 方法返回一个 String 对象，这个对象中包含了用当前区域设置的默认格式表示的日期。 toLocaleString 只是用来显示结果给用户；最好不要在脚本中用来做基本计算，因为返回的结果是随机器不同而不同的。示 例:下面这个例子说明了 toLocaleString 方法的用法。12345var d, s; // 声明变量。d = new Date(); // 创建 Date 对象。s = &quot;Current setting is &quot;;s += d.toLocaleString(); // 转换为当前区域。根据所在地区（中国，欧洲）的不同，返回的日期格式不同return(s); // 返回转换的日期。 数组继承的前面三个方法，在默认情况一都会以逗号分隔的字符串的形式返回数组项（有点争议，valueOf( )返回的类型应该是Array类型，或对象型）而如果使用join( ) 方法，则可以使用不同的分隔符来构建这个字符串。join（）方法只接受一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。例子：123var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;orange&quot;];alert(colors.join(&quot;-&quot;)); //red-blue-orangealert(colors.join(&quot;||&quot;)); //red||blue||orange 5.2.3栈方法就是数据结构中的栈。栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构（碟子模型）。栈中项的推入和弹出都发生在一个位置——栈的顶部（数组的尾部）。ECMAScript为数组提供了push( )和pop（）方法，以便实现类似栈的行为。push( )（push: v. 推入）方法可以接收任意数量的参数（！），把他们逐个添加到数组的末尾，并返回修改后数组的长度。pop（）（pop: n. 啪的一声，数据弹出的声音），把数组末尾的最后一项移除，减少length的值，然后返回那个被移出的项。 5.2.4队列方法队列数据结构的访问规则是FIFO（Firest-In-First-Out，先进先出，派对模型），队列在列表的末端添加项，从列表的前端移除项。实现这两个操作的数组方法是shift（），它能移出数组的第一项，并返回该项。同时将数组长度减1。结合使用shift（）和 push（）方法，可以像使用队列一样使用数组。 5.2.5重排序方法数组中已经存在两个可以直接用来重排序的方法：reverse（）和sort（）。 reverse（）故名思义会翻转数组项的顺序。数组是被直接覆盖，不是翻转它的副本。在默认情况下，sort（）方法按升序排列数组项——即最小的值位于前面，最大的值排在最后面。但sort（）的大小即使数组是数字也不是按照数字大小排序的，而是都会先在内部通过toString( )转换为字符串，通过比较字符串按大到小排序。例子：123var values = [0,1,5,10,15];values.sort( );alert(values); //0,1,10,15,5 可见，即使例子中值的顺序没有问题，但sort( ) 方法也会根据测试字符串的结果改变原来的顺序。(其实JS中的sort()方法是按比较值的Unicode顺序进行排序的)这种排序方式很明显不是最佳方案，因此sort（）方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值前面。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等，则返回0，如果第一个参数应该位于第二个参数之后，则返回一个正数。以下就是一个简单的比较函数：123456789function compare(value1,value2)&#123; if(value1&lt;value2)&#123; return -1; &#125;else if(value1&gt;value2)&#123; return 1; &#125;else&#123; return 0; &#125;&#125; 只要将其作为参数传递给sort（）方法即可。例子：123var values = [0,1,5,10,15];varlues.sort(compare);alert(values); //0,1,5,10,15 如果想要产生降序的结果，只要交换比较函数返回的值即可。（把return 1 和return -1交换位置） ✎注意：reverse（）和sort（）方法的返回值是经过排序之后的数组（不会变成字符串）。对于数值类型或者其valueOf( ) 方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。对于这个函数只要用第二个值减第一个值即可。1234//用两行代码实现数值类型数组的升降排序function compare(value1,value2)&#123; return value2-value1; //return value1-value2就是降序&#125; 由于比较函数通过返回一个小于零，等于零，或大于零的值来影响排序结果，因此减法操作就可以适当地处理所有这些情况。 5.2.6操作方法操作方法就是讲操作数组的各种方法。第一个方法是concat（）。可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。如果没有给concat（）传递参数，它就只会复制当前数组并返回副本。如果传递给concat（）方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中，如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。例子：12345var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);alert(colors); //red,green,bluealert(colors2); //red,green,blue,yellow,black,brown 下一个方法是slice（）。它能够基于当前数组中的一或多个项创建一个新数组。slice（）方法可以接受一或两个参数。即要返回项的起始位置和结束位置（位置从0开始算）。只有一个参数：slice（）返回从该参数指定位置开始到当前数组末尾的所有项。两个参数：返回起始和结束位置之间的项——但不包括结束位置的项。且slice（）方法不会影响原始数组。例子：123456var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);alert(colors2); //green，blue,yellow,purplealert(colors3); //green,blue,yellow ✎注意：如果slice方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含5项的数组上调用slice（-2，-1）与调用slice（3，4）得到的结果相同。如果结束位置小于起始位置，则返回空数组。 第三个是splice（）方法。最强大的数组方法，其有很多种用法。splice（）的主要用途是向数组的中部插入项，但使用这种方法的方式有如下3种。 删除：可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。例如：splice（0，2）会从位置0开始，删除数组中的前两项。 插入：可以向指定位置插入任意数量的项。只需3个参数：起始位置，0（要删除的项数，不删就是0）和要插入的项，如果要插入多个项，可以再传入第四，第五等任意多个项。例如，splice(2,0,”red”,”green”)会从当前数组的位置2开始插入字符串“red”和“green”（“red”会成为在位置2的值，“green”在位置3） 替换：可以向指定位置插入任意数量的项，同时删除一定数量的项，插入的项数不必与删除的项数相等。例如：splice（2，1，“red”,”green”）会删除当前数组位置2的项，然后从位置2开始插入字符串“red”和“green”。“red”在位置2。splice（）方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项就返回一个空数组）。下面是三种用法的例子：1234var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var removed = colors.splice(0,1);alert(colors); //green，bluealert(colors); //red，返回被删除的那一项 5.2.7位置方法ECMAScript5为数组添加的两个位置方法：indexOf( ) 和lastIndexOf( ) 都接收两个参数：要查找到项，表示查找起点的索引（可选，起点也可以被搜索到）。indexOf（）是从前向后查找，lastIndexOf（）是从后向前查找。两个方法返回的都是查找的项在数组中的位置。查找不到则返回-1。lastIndexOf（）返回的位置也是从头开始计的，虽然是从最后开始找。在用第一个参数与数组中的项比较时，使用的是全等操作符（“===”），非常严格。例子：123456789101112131415var numbers = [1,2,3,4,5,4,3,2,1];alert(numbers.indexOf(4)) // 3alert(numbers.lastIndexOf(4)) // 5alert(number.indexOf(4,4)); //5alert(number.lastIndexOf(4,4)) //3 第二个参数是4，则相当于数组只有前面五项[1,2,3,4,5]以5为最后一项开始找。var person = &#123;name : &quot;Nicholas&quot;&#125;;var people = &#123;name : &quot;Nicholas&quot;&#125;;var morePlople = [person];alert(people.indexOf(person)); //-1alert(morePeople.indexOf(person))//0 比较难懂的是lastIndexOf（）加第二个参数，测试了一下终于自己测出来。lastIndexOf（）的第二个参数查找起点的索引也是从头开始计算的，比如第二个参数是2，则相当于整个数组只剩前面的0，1，2.后面的项相当于“不见了”，然后以第2为最后一个位置开始查找数组。支持indexOf( ) 和lastIndexOf( )的浏览器有 IE9+(IE9+的意思用IE9也能成功)，Safari 3，Opera 5和Chrome. 5.2.8迭代方法ECMAScript5为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和运行该函数的作用域对象（可选）——影响this的值。传入这些方法中的函数（函数由我们自己编写）会接收三个参数（要写在函数的参数栏里）：数组的项的值（不能说“数组的项”，因为数组的项包括数组的项的值和位置），项的位置，数组对象（迭代方法是数组对象的方法，对象才有方法，是数组，对象）本身。 以下是这5个迭代方法： every（）：让数组中的每一项都过一遍every（）里的那个函数，全部返回true了，every（）方法才返回true。 some（）：让数组中的每一项都过一遍some（）里的那个函数，只要有一个返回true，some（）方法就返回true。 filter（）：筛选器。数组的每一项都过一遍filter（）里的函数，只返回一个通过了“考验”的数组。 forEach（）：对数组运行给定的函数，这个方法没有返回值。 map（）：对数组每一项过一遍map（）里的函数，返回经过这个函数“加工”过的结果组成的数组。 下面是every（）和some（） 的例子，返回true,false123456789var numbers = [1,2,3,4,5,6];var result = numbers.every(function(item,index,array)&#123; return item&gt;2;&#125;)console.log(result); //falsevar result = numbers.some(function(item,index,array)&#123; return item&gt;2;&#125;)console.log(result); //true 两个例子的ES6写法：12345let result = numbers.every((item,index,array) =&gt; item&gt;2);console.log(result); //falselet result = numbers.some((item,index,array) =&gt; item&gt;2);console.log(result); 使用的是ES6的箭头函数，适合简短的函数，不需要命名，箭头后面默认是return，具体看阮一峰的文档。 下面是filter（）的例子，返回一个由通过函数筛选条件的数组12345var numbers = [1,2,3,4,5,6];var result = numbers.filter(function(item,index,array)&#123; return item&gt;2;&#125;)console.log(result); // [3,4,5,6] 下面是运行map（）的例子，返回一个经过map（）内函数加工的数组12345var numbers = [1,2,3,4,5,6];var result = numbers.map(function(item,index,array)&#123; return item*2;&#125;)console.log(result); // [2,4,6,8,10,12] 下面是forEach（）的例子，这个方法（请严谨地说——方法，不是函数，它是数组对象的，方法）没有返回值。本质上相当于对封装了一个for循环给数组。1234var numbers = [1,2,3,4,5,6];numbers.forEach(function(item,index,array)&#123; console.log(item); //会像使用了for循环打印7次&#125;) 亲测在forEach（）里对数组的项进行赋值、计算得到的结果不会影响本来的那个数组，甚至在函数内打印出对每项经过计算后的数组，得到的数组也是没有改变的原来的数组。因为函数的参数是按值传递的。例子：1234567var numbers = [1,2,3,4,5,6];numbers.forEach(function(i,u,a)&#123; i=i+1; console.log(i); //每一项都打印出来，都被+1 console.log(a); //打印七次数组，每次都是原来那个数组[1,2,3,4,5,6]&#125;)console.log(numbers); //外面的数组没有改变，仍是[1,2,3,4,5,6] 以上every（），filter（） ，some（） ，map（） ，forEach（）只在IE9+，Firefox2+，Safari 3+，Opera 9.5+和Chrome有效。 打完上面那句因为函数的参数是按值传递的后发现一个有意思的事情，函数参数是按值传递没错，但数组是对象，函数的参数也是原来那个函数的指针，在函数里改变数组内的值，原来的那个数组也会被改变才对。经过亲自测试，当把数组当作参数传入函数，在函数内对数组内的值+1，在外部打印的数组也是经过+1的了！所以上面好像也不是因为函数的参数是按值传递的这个原因。大概forEach（）方法不会返回任何值所以也不会改变任何值吧，而console.log(a)打印出来的就是参数里的那个a，所以是原来那个参数。例子：123456789101112131415161718var numbers = [1,2,3,4,5,6];function add(array)&#123; for (var i = array.length - 1; i &gt;= 0; i--) &#123; array[i]+=1; &#125; console.log(array);&#125;add(numbers); //把数组作为参数传入函数，对每个值+1console.log(numbers); //外部的numbers也被改变[2,3,4,5,6,7]//于此同时用基本类型值number做同样的实验，全局的num在函数内经过计算后在全局打印出来的num还是等于6var num=6;function addOne(num)&#123; num+=1; console.log(num);&#125;addOne(num);console.log(num); //6 5.2.9归并方法ECMAScript5还新增了两个归并数组的方法：reduce（）和reduceRight（）这两个数组会迭代所有项，然后构建一个最终返回的值。两个方法只有一个区别：一个从头开始归并，一个从后向前归并。两个方法都接收两个参数：一个在每项上调用的函数和作为归并基础的初始值。传进这两个方法的函数接收4个参数：前一个值，当前值，项的索引和数组的对象。这个函数返回的任何值都会作为第一个参数（“前一个值”）自动传给下一项。第一次迭代发生在数组的第二项上（在这句话体会“迭代这个词的意思”），前一个值在第一次迭代时是数组的第一项，第二个参数是数组的第二项。第二次迭代的第一个参数就是第一项和第二项迭代（迭代有可能是加减乘除或其他计算方式）后的值。下面是用reduce（）方法求数组uoyou值之和的操作：12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev,cur,index,array)&#123; return prev+cur;&#125;);alert(sum); //15 第一次执行回调函数，prev是1，cur是2.第二次，prev是3（1加2的结果），cur是3（数组第三项）。这个过程持续到把数组最后一项访问到。最后返回结果。reduceRight( )方法不讲了区别只是开始的顺序是从后面开始罢了。 支持这两个归并函数的浏览器有： IE9+，Firefox3+，Safari 4+，Opera 10.5+和Chrome。（可以看出这两个方法比上面5个迭代方法要更难兼容。所有浏览器的版本都上了一个数，IE仍是9+才可以访问）。 5.3Date类型要创建一个日期对象，同样使用new操作符和Date构造函数即可。1var now = new Date(); 不向Date构造函数传递函数的情况下，新创建的对象默认自动获得当前日期和时间。如果想根据特定的日期和时间（日期：年月日；时间：时分秒），理论上应该传入表示该日期的毫秒数（即从UTC时间1970年1月1日午夜起至该日期经过的毫秒数）。当然JavaScript不可能这么不人道，ECMAScript提供了两个方法：Date.parse( ) 和Date.UTC( )这两种方法可以让你直接写入正常人类的日期即可使日期对象具备特定的日期和时间。两种方法表示日期的格式不同。而且也不用傻傻地写123//不用这么做！var someDate = new Date(Date.parse(&quot;May 25,2004&quot;));var allFives = new Date(Date.UTC(2005,4,5,17,55,55)); Date构造函数已经自带了这两个方法，如果直接写入“May 25,2004”，函数会自动调用Date.parse( )。如果写入的是2005，4，5，17，55，55，构造函数也会自动调用Date.UTC( )。所以不用像上面那样写。正确的写法：12var someDate = new Date(&quot;May 25,2004&quot;);var allFives = new Date(2005,4,5,17,55,55); ✎注意：第二个日期表示的是2005年5月5日，因为月份是从0开始计算的，0-11。 ECMAScript5添加了Date.now( )方法，返回程序运行到这个方法时的日期和时间的毫秒数，可以用来当计时器用，简化了使用Date对象分析代码的工作（不用专门构建Date对象就可以调用的方法）。例子：12345var start = Date.now( );doSomething();var stop = Date.now();result = stop - start; //通过start-stop可以得出运行doSomething()具体用了多少时间 又是ECMAScript5才发布的方法，所以能用的浏览器包括： IE9+，Firefox3+，Safari 3+，Opera 10.5+和Chrome。不支持这个方法的浏览器中，可以使用+操作符获取Date对象的时间戳，也可以达到同样的目的。12345var start = +new Date();doSomething();var stop = +new Date();result = stop - start; 5.3.1继承的方法与其他引用类型一样，Date类型也重写了toLocaleString（）、toString（）和valueOf（）方法。总而言之这一段就是告诉我们用toLocaleString（）和toString（）写出来的日期格式在同一个浏览器中是不一样的。恐怖的是根据浏览器的不同，每个浏览器用toString（）输出的结果也是不一样的。toLocalString（）同理。书里还有一句话：事实上，toLocaleString（）和toString（）在浏览器上显示格式的差别仅在调试代码时比较有用，在显示日期和时间上没有什么价值。 至于Date类型中的valueOf（）方法则根本不会返回字符串，而是返回日期的毫秒表示（ZZ）。 还有一点是：日期是可以比较大小的，下面例子：12345var date = new Date(2007,0,1);var date = new Date(2007,1,1);alert(date1&lt;date2); //truealert(date1&gt;date2); //false 比较早的日期小于比较晚的日期。 5.3.2日期格式化方法介绍了toDateString（）,toTimeString（） ,toLocalDateString（） ,toLocaleDateString（） ,toLocaleTimeString（） ,toUTCString（） ,这几个根据特定实现的格式或特定地区的格式显示的日期格式。与toLocaleString（）和toString（）相同，以上几个方法的显示格式也会因浏览器的不同有差异。没有哪一个方法能够用来在用户界面中显示一致的日期信息。 5.3.3日期/时间组件方法介绍了一大堆getFullYear（）、getMonth（）等方法，有用到自然会去百度，不写。 5.4RegExp类型正则网上有很多现成的正则案例，本人真的看到正则头大，所以这部分是跳过的，有兴趣的可以先看看JavaScript正则表达式视频教程-慕课网学习。","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"高程","slug":"高程","permalink":"https://millionqw.github.io/tags/高程/"}]},{"title":"《JS高级程序设计》第四章 作用域和内存问题","date":"2017-07-03T04:38:37.000Z","path":"2017/07/03/《JS高级程序设计》第四章-变量、作用域和内存问题/","text":"&ensp;&ensp;把2016年寒假写的对《JavaScript高级程序设计》的笔记写在博客上，同时回看加修改，同时也更新到简书上。尽量一天一篇一章。 第四章 变量、作用域和内存问题4.1基本类型和引用类型的值ECMAScript变量可能包含两个不同类型数据的值：基本类型值和引用类型值。基本类型值指的是简单的数据段（Boolean类型、Number类型、String类型、Undefined、Null） 引用类型值指那些可能由多个值构成的对象（Object类型、Array类型、Date类型、RegExp类型、Function类型）&gt;ES6中新增了Symbol,是JavaScript的第七种数据类型。4.1.1动态的属性基本类型值和引用类型值的区别一：对于引用类型值，我们可以为其添加或删除属性和方法，但是基本类型值没有属性和方法。例子:var person = new Object(); var name = “Nicholas”person.name = “Nicholas”; name.age = 27;alert(person.name); //“Nicholas” alert(name.age) //undefined以上代码一创建了一个对象并给他一个name属性，又通过alert访问成功。代码二给字符串name定义了一个age属性，但当我们访问的时候会发现这个属性不存在。这说明只能给引用类型值动态地添加属性，以便将来使用。4.1.2复制变量值基本类型值和引用类型值的区别二：在复制变量的时候，复制基本类型值和引用类型值也是有区别的。如果只是复制基本类型值，那就是简单复制到为新变量分配的位置上没毛病。当复制的是引用类型的值时，同样会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个新的副本实际上是一个指针，复制结束后，两个变量实际上将引用同一个对象。因此，如果复制的是引用类型值，当改变其中一个变量，就会影响另一个变量。例子：var obj1 = new Object();var obj2 = obj1;obj1.name=”Nicholas”;alert(obj2.name); //“Nicholas”变量对象中的变量保存在堆中的对象之间的关系如图：图片来自《JavaScript高级程序设计》可以看到当变量复制后，指针仍然指向一开始的Object，而不是复制出多一个Object。.4.1.3传递参数ECMAScript中所有函数的参数都是按值传递的。（无论参数是引用类型值和基本类型值）。也就是说，把函数外部的值复制给函数内部的参数，就和4.1.2复制变量值的原理一样，把一个变量复制到另一个变量（函数的参数）一样。有不少开发人员在这点会感到困惑，因为访问变量有按值和按引用两种方式，而参数只能按值传递。————————–讨论参数传递的是引用类型值的情况————————–function setName(obj){ obj.name = “Nicholas”;}var person = new Object();setName(person);alert(person.name); //“Nicholas”以上代码创建了一个对象person，这个变量被传递到setName（）函数中后被复制给了obj，在这个函数内部，obj和person引用的是同一个对象。换句话说，即使这个变量是按值传递的，obj也会按引用来访问同一个对象（遵循4.1.2的复制变量值原理）。于是当为函数内部为obj添加name属性后，函数外部的person也会有所反映。因为person指向的对象在堆内存中只有一个，而且是全局对象。有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的（大错特错）。为了证明对象是按值传递的。看下面的例子:function setName（obj）{ obj.name = “Nicholas”; obj = new Object(); obj.name = “Greg”;}var person = new Object();setName(person);alert(person.name); //“Nicholas”这段代码增加了两行，为obj重新定义了一个对象，第二行为该对象定义了一个带有不同值的name属性。如果person是按引用传递的，那么person最后会被自动修改为指向其name属性值为“Greg”的新对象。但是在函数外访问person.name时，显示的值仍然是”Nicholas”。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了(这个函数范围的局部对象)。而这个局部对象会在函数执行完毕后立即被销毁。4.1.4检测类型检测变量类型的方法有两种，一种是检测基本类型值的，用typeof，另一种是检测引用类型值的，用instanceof。typeof操作符是确定一个变量是string,boolean,number，undefined的最佳工具，如果变量是对象（根据规定，所有引用类型的值都是Object的实例）或null，则typeof操作符返回的值会是“object”。例子：var s = “Nicholas”, b = true, i = 22, u , n = null, o = new Object(), d = new Date();alert(typeof s); //stringalert(typeof i); //numberalert(typeof b); //booleanalert(typeof u); //undefinedalert(typeof n); //objectalert(typeof i); //objectalert(typeof d); //object因为typeof只能检测基本类型值，检测引用类型值时只会返回object，所以ECMAScript又提供了一个insanceof操作符，用法跟typeof不同，且只返回true 或 false。✎另类的情况使用typeof操作符检测函数时，该操作符会返回”function”。在Safari 5 及之前版本和Chrome 7及之前的版本中使用typeof检测正则表达式时，由于规范的原因，这个操作符也返回“function”。ECMA-262规定任何在内部实现 [ [ call ] ] 方法的对象都应该在应用typeof操作符时返回“function“。由于上述浏览器(Safari 5,Chrome 7)中的正则表达式也实现了这个方法，因此对正则表达式应用typeof会返回“function”。在IE和Firefox中，对正则表达式应用typeof会返回“object”. 如果变量是给定引用类型（根据它的原型链来识别，第6章将介绍原型链。#原书句）的实例那么instanceof操作符就会返回true。例子： alert(person instanceof Object); //变量person是Object吗？ alert(colors instanceof Array); //变量colors是Array吗？ alert(pattern instanceof RegExp); //变量pattern是RegExp吗？ //亲测左右两边位置不可互换，互换不会出现提示框 因为根据规定，所有引用类型的值都是Object的实例，因此把Date，Array，RegExp等引用类型值用instanceof 与Object验证时，始终都会返回true。用instanceof操作符检测基本类型值时，该操作符时钟返回false，因为基本类型不是对象。 4.2执行环境及作用域 作用域链重要的一点就是内部执行环境可以使用其外部环境的变量和函数，并且可以改变那个变量的值，只要那个变量不是被当作参数传进去的而是直接使用的。（当作参数传入的是按值传递，改变的是复制出来的变量，不会改变原来的变量） 执行环境（execution context）和作用域其实超级简单。每个执行环境都有一个与之关联的变量对象（variable object），环境变量中定义的所有变量和函数都保存在这个对象中。但是我们无法用代码访问到这个变量对象。但解析器在处理数据时会在后台使用它。 全局执行环境是最外围的执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是window对象（第七章将详细讨论），因此，所有全局变量和函数都是作为window对象的属性和方法创建的（window对象是个变量对象，全局变量和函数是它的属性和方法）。某个执行环境（例如一个函数）中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出（网页关闭或浏览器关闭时才被销毁）） > &ensp;&ensp;在Node.js中的全局执行环境是global 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权交给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制在控制。 当代码在其中一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的最前端，始终都是当前执行代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中不存在）。作用域链中的下一个变量对象来自包含它的外部环境，而再下一个变量对象则来自下一个包含环境。这样，一直延伸到全局执行环境； 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程从作用域链最前端开始，然后逐级向后回溯，直到找到标识符为止（如果找不到，就会发生错误） 例子：var color = \"blue\"； function changeColor(){ if(color == \"blue\"){ color = \"red\"; } } changeColor(); alert(color); // \"red\" 在这个例子中，函数changeColor( )的作用域链包含两个对象：它自己的变量对象（其中定义着arguments对象）和全局环境的变量对象。可以在函数内部访问变量color，就是因为可以在这个作用域链中找到它。 此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面这个例子所示： var color = \"blue\"; function changeColor(){ var anotherColor = \"red\"; function swapColors(){ var tempColor = anotherColor; anotherColor = color; color = tempColor; //这里可以访问color，anotherColor 和 tempColor } //这里可以访问color和anotherColor，但不能访问tempColor swapColors(); } //这里只能访问color changeColor();以上代码涉及三个执行环境：全局环境、changeColor（）的局部环境和swapColor（） 的局部环境。swapColor的局部变量中有一个变量tempColor，该变量只有在swapColor环境中能访问到，但是swapColor（）内部可以访问其他两个环境中的所有变量。 越在内部的局部环境，作用域链越长。对于这个例子中的swapColor（）而言，其作用域链中包含3个对象：swapColor( )的变量对象、changeColor（）的变量对象和全局对象。swapColor（）的局部环境开始时会现在自己的变量对象中搜索变量和函数名，如果搜索不到则再搜搜上一级作用域链。changeColor()的作用域链中只包含两个对象：它自己的变量对象和全局对象。也就是说，它不能访问swapColor（）的环境。 4.2.1延长作用域 有些语句可以在作用域链前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象，具体来说，就是当执行流执行到下列任何一个语句时，作用域链会得到增长 * try-catch语句的catch块 * with语句 这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中，对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。例子： function buildUrl(){ var qs = \"?debug=true\"; with(location){ var url = href + qs; } return url; } ✎添加一个with语句块的知识点当在with语句块中使用方法或者变量时，程序会检查该方法是否是本地函数，变量是否是已定义变量，如果不是，它将检查伪对象（with的参数），看它是否为该对象的方法，属性。如上面例子with语句块中的href，本地无定义，则with语句块会自动加上location.href，所以href实际上为href。这个就是with的功能。with 语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多数情况下，如果可能，最好避免使用它。在此，with语句接收的是Location对象，因此其变量对象中就包含了location对象的所有属性和方法，而这个变量对象被添加到了作用域链的最前端，buildUrl（）函数中定义了一个变量qs。当在with语句中引用变量href时(实际引用的是location.href)。可以在当前执行环境的变量对象中找到。当引用变量qs时，引用的则是在buildUrl( )中定义的那个变量，而该变量位于函数环境的变量对象中。至于with语句的内部，则定义了一个名为url的变量，因而url就成了函数执行环境的一部分，所以可以作为函数的值被返回。 4.2.2没有块级作用域 ✎添块级作用域任何一对花括号中的语句都属于一个块，在这之中定义的所有变量在代码块之外都是不可见的，我们称之为块级作用域。作用域有两种，块级作用域和函数作用域讲到这就好理解。JS没块级作用域就是说在for循环和if语句块中定义的变量是可见的，可以被外部使用的，但像其他的语言Java,C,C#语言中，在for，if语句中定义的变量在语句执行完毕之后就会被销毁。但在JavaScript中，if语句中的变量声明会将变量添加到当前执行环境中。注意只是当前执行环境，如果for循环是在一个函数里，则定义的i在函数里是确定的数，在全局环境中仍然是not defined。例子： if(true){ var color = \"blue\"; } alert(color) //\"blue\" for(var i=0; i","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"高程","slug":"高程","permalink":"https://millionqw.github.io/tags/高程/"}]},{"title":"第一个hexo博客终于建成","date":"2017-07-02T13:20:13.000Z","path":"2017/07/02/第一个hexo博客终于建成/","text":"折腾了半个下午加半个晚上，终于建成了自己的第一个hexo博客，也是自己的第一个博客ヽ(^･ω･^)丿 从开始接触技术以来，就一直知道技术人员都要有一个自己的博客，接触了两年技术，学习过程中也有把知识记录下来的习惯，但是都是记录在印象笔记里，也在博客园开过一个博客，但一直都没在那里动过笔，大概就是等一个用Hexo博客的机会吧，如果我早在博客园写日记，估计就懒得搬过来了。 虽然hexo的SEO并不好（看到别人的博客都是在简书上转过来的），但是有了博客就有了一个精神角落，放自己的技术，也督促自己记录下学到的东西吧。 第一篇博文，就记录一下自己是怎么搭建这个博客的吧！ 真的想动手搭博客是6月以来看到github上一些大神的博客，看到他们的博客都好漂亮，后来才知道是用hexo搭起来的（之前一直觉得“自己的博客”应该是从html到css都是自己写的），后来也看了一些搭hexo博客的文章，终于在6月底考完试后开始在今天做自己的博客。 首先，是阅读了 @代码咖啡 在简述上发的这篇 20分钟教你使用hexo搭建github博客 文章非常浅显易懂，这里在这篇文章的基础上补上一些我遇到的问题和我是怎么解决的： 文章中的一个步骤： 这里的终端（terminal）指的是git这个版本控制系统，需要下载在电脑中，具体的使用教程看廖雪峰大大的教程，但是在搭博客过程中我们知道怎么安装就好，然后把git bash当命令行用。文章中的命令行都是在git bash输入的。 后面的node.js和hexo的安装因为自己有学一点点node的知识所以够用，不懂的可以留言，我可以帮助你解决问题！ 还有一个是初始化博客后博客文件夹的数量会与作者的不一样，貌似会少一两个，不过不要紧接着进行。 后面的 最后的timezone不要因为你不是上海的就改成你当地的地名，根据标准，中国区只能写Asia/Shanghai、Asia/Hongkong、Asia/Taipei、Asia/Harbin. 之后@代码咖啡 又发了一篇博文 【干货】2个小时教你hexo博客添加评论、打赏、RSS等功能 是对hexo博客扩展功能的补充，他使用的博客主题是NexT，所以就这个主题做了介绍。 我使用的是yilia这个主题，似乎很多人用的都是这个类似的主题，非常受欢迎，github上有3.6k+个star。使用的时候要对配置进行一些修改。 注意在README里说到的配置_config.yml是配置themes/yilia下的_config.yml，不是根目录下的_config.yml。可以在主题里的_config.yml加上你的微博，github，知乎等链接，如果没有的，可以使用#井号注释掉。 另外当你使用这个主题的时候，点开左侧边栏的”所有文章/关于我”，打开的侧边栏会提示缺少模块，按提示下载模块后在主目录下的_config.yml配置给出的那一段配置即可，注意缩进，_config.yml的配置如果缩进错误是不生效的。 使用博客中出现的问题及解决办法 刚开始用这个主题的时候是没有头像的，一开始把图片放在source的img下用相对路径引入发现没有效果，后来用的是微博的图床，一些人似乎用了图床后也显示不出来，解决方法参考:解决头像的问题 当你更新了themes下的_config.yml且git pull后用了hexo clean hexo g //产生静态内容 hexo d //发布到github 仍然没有反应的时候，不要急，确认自己的配置无误的话，只要多刷新几遍即可，应该是网络原因造成的更新延迟。几秒后更改就会生效 我出现的问题是头像可以显示，但是样式不好看： 用F12修改了一下样式，参考了上一个问题的解决方法，在themes\\yilia\\layout_partial下找到left-col.ejs文件，在第6行中的 &lt;a href=&quot;/&quot; class=&quot;profilepic&quot;&gt; &lt;img src=&quot;&lt;%=theme.avatar%&gt;&quot; class=&quot;js-avatar&quot;&gt; &lt;/a&gt; 在img标签里添加一行行内样式： style=”position:absolute; left:-30%; top:-5%; max-width:150%; left和top的值根据你自己的图片位置调整。 如果在移动端上头像的显示仍然不理想，可以在themes\\yilia\\layout_partial下找到mobile-nav.ejs文件，在第十行&lt;img src=&quot;&lt;%=theme.avatar%&gt;&quot; class=&quot;js-avatar&quot;&gt;中添加一句style=”min-width:130%;”即可，具体数值仍然根据自己的情况调整。 几个常用的hexo命令 防止忘了又要百度，把几个命令记下来。 新建文章 hexo new \"文章标题\" 清除缓存、生成静态文件、发布 hexo clean hexo g hexo d 修改主题配置后更新 cd themes/yilia git pull 要总结的似乎就这些，接下来计划把上个寒假花了10几天写的《Javascript高级程序设计》笔记搬到上面来，可以的话，一天整理一篇。同时回顾学过的东西，再添加修改原有的笔记。最后，晚安~","tags":[{"name":"前端","slug":"前端","permalink":"https://millionqw.github.io/tags/前端/"},{"name":"生活","slug":"生活","permalink":"https://millionqw.github.io/tags/生活/"}]},{"title":"文章标题","date":"2017-07-02T08:20:23.000Z","path":"2017/07/02/文章标题/","text":"你好，欢迎来到我的个人技术博客。","tags":[]}]